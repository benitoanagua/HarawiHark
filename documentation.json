{
    "pipes": [],
    "interfaces": [
        {
            "name": "AdvancedSearchOptions",
            "id": "interface-AdvancedSearchOptions-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "contains",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 51
                },
                {
                    "name": "endsWith",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 50
                },
                {
                    "name": "maxLength",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 53
                },
                {
                    "name": "minLength",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 52
                },
                {
                    "name": "pos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 48
                },
                {
                    "name": "startsWith",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 49
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 47
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "AlliterationMatch",
            "id": "interface-AlliterationMatch-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "positions",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 35
                },
                {
                    "name": "sound",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 36
                },
                {
                    "name": "words",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 34
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "AlternativeWord",
            "id": "interface-AlternativeWord-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "pos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 30
                },
                {
                    "name": "reason",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"exact-match\" | \"rhyme-match\" | \"sound-match\" | \"semantic-rhyme\" | \"spelling-match\" | \"morphological\"",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 23
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22
                },
                {
                    "name": "word",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 21
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "AnalysisMetric",
            "id": "interface-AnalysisMetric-2b245ee2f221fd7660980b99bb7705281f89720740969f8b6fd377319e7ad0ee82c03f5c08db2e9dc1956112fb67663e8a4208df091cf46939a3b11e7b5197c9",
            "file": "src/app/components/ui/analysis-panel/analysis-panel.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CardComponent } from '../card/card.component';\n\nexport interface AnalysisMetric {\n  label: string;\n  value: number | string;\n  maxValue?: number;\n  variant?: 'default' | 'success' | 'warning' | 'error';\n  icon?: string;\n}\n\n@Component({\n  selector: 'app-analysis-panel',\n  standalone: true,\n  imports: [CardComponent],\n  templateUrl: './analysis-panel.component.html',\n})\nexport class AnalysisPanelComponent {\n  @Input() title = '';\n  @Input() metrics: AnalysisMetric[] = [];\n  @Input() compact = false;\n\n  getMetricVariant(metric: AnalysisMetric): string {\n    return `metric-${metric.variant || 'default'}`;\n  }\n\n  getProgressWidth(metric: AnalysisMetric): string {\n    if (metric.maxValue && typeof metric.value === 'number') {\n      const percentage = (metric.value / metric.maxValue) * 100;\n      return `${Math.min(percentage, 100)}%`;\n    }\n    return '0%';\n  }\n}\n",
            "properties": [
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "maxValue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number | string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "variant",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"default\" | \"success\" | \"warning\" | \"error\"",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 8
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "AppBarAction",
            "id": "interface-AppBarAction-e2b9c1c22b3661e41ffb4d97c5f3f2661396ff2f7a1d5f44a0fb7f0d1c26a8dffab14706f2858074a38dc4a9387a9f50a316802752f408c20e23b8e8daa58fe2",
            "file": "src/app/components/metro/appbar/appbar.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nexport interface AppBarAction {\n  id: string;\n  icon: string;\n  label: string;\n  disabled?: boolean;\n}\n\n@Component({\n  selector: 'app-appbar',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './appbar.component.html',\n})\nexport class AppBarComponent {\n  @Input() actions: AppBarAction[] = [];\n  @Input() hidden = false;\n  @Output() actionClick = new EventEmitter<string>();\n\n  onActionClick(actionId: string, disabled?: boolean): void {\n    if (!disabled) {\n      this.actionClick.emit(actionId);\n    }\n  }\n}\n",
            "properties": [
                {
                    "name": "disabled",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "AppState",
            "id": "interface-AppState-2e75f793629fe1f134898f8cd74c219b287af02b59dfccb819e2b15e510c6a60ca3bbe47742bfbaa5833325ff4252635e5394fca8a1da7d2354e360dd84e78a9",
            "file": "src/app/services/core/state.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, signal, computed } from '@angular/core';\nimport { POETRY_FORMS, POETRY_EXAMPLES } from '../../data/poetry-forms.data';\n\nexport interface AppState {\n  selectedForm: string;\n  poemText: string;\n  isAnalyzing: boolean;\n  hasResults: boolean;\n  shouldLoadExample: boolean;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class StateService {\n  private readonly state = signal<AppState>({\n    selectedForm: 'haiku',\n    poemText: '',\n    isAnalyzing: false,\n    hasResults: false,\n    shouldLoadExample: false,\n  });\n\n  private isUpdatingFromInternal = false;\n  private lastLoadedForm: string | null = null;\n\n  readonly selectedForm = computed(() => this.state().selectedForm);\n  readonly poemText = computed(() => this.state().poemText);\n  readonly isAnalyzing = computed(() => this.state().isAnalyzing);\n  readonly hasResults = computed(() => this.state().hasResults);\n  readonly shouldLoadExample = computed(() => this.state().shouldLoadExample);\n  readonly currentForm = computed(() => POETRY_FORMS[this.selectedForm()]);\n  readonly currentPattern = computed(() => this.currentForm()?.pattern || []);\n  readonly expectedLines = computed(() => this.currentForm()?.lines || 3);\n\n  readonly lines = computed(() =>\n    this.poemText()\n      .split('\\n')\n      .slice(0, this.expectedLines())\n      .filter((line) => line.trim().length > 0)\n  );\n\n  setSelectedForm(formId: string): void {\n    if (this.isUpdatingFromInternal || this.state().selectedForm === formId) {\n      return;\n    }\n\n    this.isUpdatingFromInternal = true;\n\n    const currentText = this.state().poemText.trim();\n    const hasContent = currentText.length > 0;\n\n    const shouldLoadNewExample = !hasContent || this.lastLoadedForm !== formId;\n\n    this.state.update((state) => ({\n      ...state,\n      selectedForm: formId,\n      shouldLoadExample: shouldLoadNewExample,\n    }));\n\n    this.lastLoadedForm = null;\n\n    setTimeout(() => {\n      this.isUpdatingFromInternal = false;\n    }, 10);\n  }\n\n  setPoemText(text: string): void {\n    this.isUpdatingFromInternal = true;\n    this.state.update((state) => ({\n      ...state,\n      poemText: text,\n      shouldLoadExample: false,\n    }));\n    setTimeout(() => {\n      this.isUpdatingFromInternal = false;\n    }, 0);\n  }\n\n  setIsAnalyzing(analyzing: boolean): void {\n    this.state.update((state) => ({ ...state, isAnalyzing: analyzing }));\n  }\n\n  setHasResults(hasResults: boolean): void {\n    this.state.update((state) => ({ ...state, hasResults }));\n  }\n\n  loadExample(): void {\n    const formId = this.selectedForm();\n    const example = POETRY_EXAMPLES[formId];\n    if (example) {\n      this.setPoemText(example.join('\\n'));\n      this.state.update((state) => ({\n        ...state,\n        shouldLoadExample: false,\n      }));\n\n      this.lastLoadedForm = formId;\n    }\n  }\n\n  clear(): void {\n    this.isUpdatingFromInternal = true;\n    this.state.update((state) => ({\n      ...state,\n      poemText: '',\n      hasResults: false,\n      shouldLoadExample: false,\n    }));\n\n    this.lastLoadedForm = null;\n    setTimeout(() => {\n      this.isUpdatingFromInternal = false;\n    }, 0);\n  }\n\n  updatePoemLines(lines: string[]): void {\n    const text = lines.join('\\n');\n    this.setPoemText(text);\n  }\n\n  consumeLoadExample(): void {\n    this.state.update((state) => ({\n      ...state,\n      shouldLoadExample: false,\n    }));\n  }\n}\n",
            "properties": [
                {
                    "name": "hasResults",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "isAnalyzing",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "poemText",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "selectedForm",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "shouldLoadExample",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 9
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "BrowserLaunchOptions",
            "id": "interface-BrowserLaunchOptions-6d1cd51da213d700331621d78703e71ec2493e97d5e3cd2a48305a04996ee567463d3331b1c5e7f4b24fdadf50f63245f0c5ac21d2bfdba23ad756114c6ce665",
            "file": "src/lib/capture/browser-utils.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { chromium, Browser, BrowserContext, Page, LaunchOptions } from 'playwright';\nimport { BROWSER_CONFIG, SHARED_CONFIG, BrowserConfig } from '../../../playwright.config';\nimport { SELECTORS, TestHelpers } from '../../e2e/selectors';\n\nexport interface BrowserLaunchOptions {\n  headless?: boolean;\n  viewport?: { width: number; height: number };\n  recordVideo?: boolean;\n  videoSize?: { width: number; height: number };\n  browserType?: 'brave' | 'chrome' | 'firefox';\n  timeout?: number;\n}\n\nexport class BrowserManager {\n  /**\n   * Lanza el navegador con la configuración especificada\n   */\n  static async launchBrowser(\n    options: BrowserLaunchOptions = {}\n  ): Promise<{ browser: Browser; context: BrowserContext; page: Page }> {\n    const {\n      headless = false,\n      viewport = { width: 1200, height: 800 },\n      recordVideo = false,\n      videoSize = { width: 1200, height: 800 },\n      browserType = 'brave',\n      timeout = 30000,\n    } = options;\n\n    const browserConfig: BrowserConfig = BROWSER_CONFIG[browserType];\n\n    const launchOptions: LaunchOptions = {\n      headless,\n      timeout,\n    };\n\n    if (browserConfig.channel) {\n      launchOptions.channel = browserConfig.channel;\n    }\n\n    if (browserConfig.launchOptions.executablePath) {\n      launchOptions.executablePath = browserConfig.launchOptions.executablePath;\n    }\n\n    launchOptions.args = [...browserConfig.launchOptions.args];\n\n    console.log(`🚀 Launching ${browserType} browser...`);\n    const browser = await chromium.launch(launchOptions);\n\n    const contextOptions = {\n      viewport,\n      baseURL: SHARED_CONFIG.baseURL,\n      ignoreHTTPSErrors: true,\n      trace: SHARED_CONFIG.trace,\n      screenshot: SHARED_CONFIG.screenshot,\n      ...(recordVideo && {\n        recordVideo: {\n          dir: 'angular-captures/videos',\n          size: videoSize,\n        },\n      }),\n    };\n\n    const context = await browser.newContext(contextOptions);\n    context.setDefaultTimeout(timeout);\n    context.setDefaultNavigationTimeout(timeout);\n\n    const page = await context.newPage();\n    page.setDefaultTimeout(timeout);\n    page.setDefaultNavigationTimeout(timeout);\n\n    return { browser, context, page };\n  }\n\n  /**\n   * Navega de forma segura a la URL especificada\n   */\n  static async safeNavigate(page: Page, url: string, timeout = 30000): Promise<boolean> {\n    try {\n      console.log(`🌐 Navigating to: ${url}`);\n      await page.goto(url, {\n        waitUntil: 'networkidle',\n        timeout,\n      });\n\n      await page\n        .waitForSelector(SELECTORS.EDITOR.CONTAINER, { timeout: 10000 })\n        .catch(() => page.waitForSelector('app-root', { timeout: 5000 }));\n\n      console.log('✅ Application loaded successfully');\n      return true;\n    } catch (error) {\n      console.error(`❌ Failed to navigate to ${url}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Espera a que la aplicación esté completamente cargada y lista\n   */\n  static async waitForAppReady(page: Page, timeout = 15000): Promise<boolean> {\n    try {\n      await page.waitForSelector(SELECTORS.EDITOR.CONTAINER, { timeout });\n      await page.waitForSelector(SELECTORS.FORM_SELECTOR, { timeout: 10000 });\n      await page.waitForSelector('.editor-actions', { timeout: 5000 });\n\n      console.log('✅ Poetry editor application ready');\n      return true;\n    } catch (error) {\n      console.error('❌ Application not ready within timeout:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Limpia recursos del navegador\n   */\n  static async cleanup(browser?: Browser, context?: BrowserContext): Promise<void> {\n    try {\n      if (context) {\n        await context.close();\n        console.log('✅ Browser context closed');\n      }\n      if (browser) {\n        await browser.close();\n        console.log('✅ Browser closed');\n      }\n    } catch (error) {\n      console.warn('⚠️ Error during browser cleanup:', error);\n    }\n  }\n\n  /**\n   * ⚡ REFACTORIZADO: Realiza acciones de demostración del editor usando TestHelpers\n   * Esto muestra las capacidades de la aplicación en videos/screenshots\n   */\n  static async performEditorActions(page: Page): Promise<void> {\n    console.log('🔄 Performing poetry editor actions using TestHelpers...');\n\n    try {\n      const forms = [\n        SELECTORS.FORM_OPTIONS.TANKA,\n        SELECTORS.FORM_OPTIONS.LIMERICK,\n        SELECTORS.FORM_OPTIONS.HAIKU,\n      ];\n\n      for (const form of forms) {\n        await TestHelpers.selectPoetryForm(page, form);\n        await this.wait(1200);\n        console.log(`✅ Form changed to: ${form}`);\n      }\n\n      const testLines = [\n        'Ancient pond so still',\n        'A frog jumps into water',\n        'Splash breaks silence',\n      ];\n\n      const firstLine = page.locator(SELECTORS.EDITOR.LINE_INPUT(0));\n      if (await firstLine.isVisible({ timeout: 2000 })) {\n        await TestHelpers.fillPoemLines(page, testLines);\n        await this.wait(1500);\n        console.log('✅ Sample poem written');\n\n        await firstLine.fill('');\n        await this.wait(500);\n      }\n\n      await TestHelpers.loadExample(page);\n      console.log('✅ Example loaded');\n\n      const analyzeButton = page.locator(SELECTORS.BUTTONS.ANALYZE).first();\n      if ((await analyzeButton.isVisible({ timeout: 2000 })) && (await analyzeButton.isEnabled())) {\n        await analyzeButton.click();\n        await this.wait(4000);\n        console.log('✅ Analysis triggered');\n      }\n\n      const clearButton = page.locator(SELECTORS.BUTTONS.CLEAR).first();\n      if ((await clearButton.isVisible({ timeout: 2000 })) && (await clearButton.isEnabled())) {\n        await clearButton.click();\n\n        try {\n          await page.waitForSelector('button:has-text(\"OK\"), button:has-text(\"Confirm\")', {\n            timeout: 1000,\n          });\n          await page.click('button:has-text(\"OK\"), button:has-text(\"Confirm\")');\n        } catch {\n          // Nothing\n        }\n\n        await this.wait(1000);\n        console.log('✅ Editor cleared');\n      }\n\n      await page.evaluate(() => window.scrollTo({ top: 300, behavior: 'smooth' }));\n      await this.wait(800);\n      await page.evaluate(() => window.scrollTo({ top: 600, behavior: 'smooth' }));\n      await this.wait(800);\n      await page.evaluate(() => window.scrollTo({ top: 0, behavior: 'smooth' }));\n      await this.wait(800);\n\n      console.log('✅ All editor actions completed successfully');\n    } catch (error) {\n      console.log(\n        '⚠️ Some actions failed, but capture continues:',\n        error instanceof Error ? error.message : error\n      );\n    }\n  }\n\n  /**\n   * Espera un número específico de milisegundos\n   */\n  static async wait(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Toma un screenshot de la página actual\n   */\n  static async takeScreenshot(page: Page, name: string, path: string): Promise<boolean> {\n    try {\n      await page.screenshot({\n        path,\n        fullPage: true,\n      });\n      console.log(`✅ Screenshot saved: ${name} -> ${path}`);\n      return true;\n    } catch (error) {\n      console.error(`❌ Failed to take screenshot ${name}:`, error);\n      return false;\n    }\n  }\n}\n",
            "properties": [
                {
                    "name": "browserType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"brave\" | \"chrome\" | \"firefox\"",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 10
                },
                {
                    "name": "headless",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "recordVideo",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "timeout",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 11
                },
                {
                    "name": "videoSize",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "viewport",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 7
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "BrowserLaunchOptions",
            "id": "interface-BrowserLaunchOptions-fe9a8243bae34e2b43061fd982f595291fbb9a92cd9fc4cc807d878a84fd25845ca6a9a12cfcdd9b37d4cff7e1396b72fcc5574343dadf88742434e9c760b741-1",
            "file": "src/lib/capture/types.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface CaptureOptions {\n  outputDir?: string;\n  url?: string;\n  viewport?: { width: number; height: number };\n  delay?: number;\n  format?: 'mp4' | 'gif' | 'webm';\n  duration?: number;\n  mode?: 'basic' | 'advanced' | 'full' | 'overview' | 'detailed' | 'all';\n  multiple?: boolean;\n  browserType?: 'brave' | 'chrome' | 'firefox';\n}\n\nexport interface CaptureResult {\n  success: boolean;\n  outputPath: string;\n  duration: number;\n  timestamp: string;\n  url: string;\n  mode?: string;\n  sections?: { name: string; path: string }[];\n  error?: string;\n}\n\nexport interface BrowserLaunchOptions {\n  headless?: boolean;\n  viewport?: { width: number; height: number };\n  recordVideo?: boolean;\n  videoSize?: { width: number; height: number };\n  browserType?: 'brave' | 'chrome' | 'firefox';\n  timeout?: number;\n}\n",
            "properties": [
                {
                    "name": "browserType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"brave\" | \"chrome\" | \"firefox\"",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 29
                },
                {
                    "name": "headless",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 25
                },
                {
                    "name": "recordVideo",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 27
                },
                {
                    "name": "timeout",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 30
                },
                {
                    "name": "videoSize",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 28
                },
                {
                    "name": "viewport",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 26
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": [],
            "isDuplicate": true,
            "duplicateId": 1,
            "duplicateName": "BrowserLaunchOptions-1"
        },
        {
            "name": "CaptureOptions",
            "id": "interface-CaptureOptions-fe9a8243bae34e2b43061fd982f595291fbb9a92cd9fc4cc807d878a84fd25845ca6a9a12cfcdd9b37d4cff7e1396b72fcc5574343dadf88742434e9c760b741",
            "file": "src/lib/capture/types.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface CaptureOptions {\n  outputDir?: string;\n  url?: string;\n  viewport?: { width: number; height: number };\n  delay?: number;\n  format?: 'mp4' | 'gif' | 'webm';\n  duration?: number;\n  mode?: 'basic' | 'advanced' | 'full' | 'overview' | 'detailed' | 'all';\n  multiple?: boolean;\n  browserType?: 'brave' | 'chrome' | 'firefox';\n}\n\nexport interface CaptureResult {\n  success: boolean;\n  outputPath: string;\n  duration: number;\n  timestamp: string;\n  url: string;\n  mode?: string;\n  sections?: { name: string; path: string }[];\n  error?: string;\n}\n\nexport interface BrowserLaunchOptions {\n  headless?: boolean;\n  viewport?: { width: number; height: number };\n  recordVideo?: boolean;\n  videoSize?: { width: number; height: number };\n  browserType?: 'brave' | 'chrome' | 'firefox';\n  timeout?: number;\n}\n",
            "properties": [
                {
                    "name": "browserType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"brave\" | \"chrome\" | \"firefox\"",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 10
                },
                {
                    "name": "delay",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "duration",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "format",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"mp4\" | \"gif\" | \"webm\"",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "mode",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"basic\" | \"advanced\" | \"full\" | \"overview\" | \"detailed\" | \"all\"",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "multiple",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "outputDir",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 2
                },
                {
                    "name": "url",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 3
                },
                {
                    "name": "viewport",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 4
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "CaptureResult",
            "id": "interface-CaptureResult-fe9a8243bae34e2b43061fd982f595291fbb9a92cd9fc4cc807d878a84fd25845ca6a9a12cfcdd9b37d4cff7e1396b72fcc5574343dadf88742434e9c760b741",
            "file": "src/lib/capture/types.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface CaptureOptions {\n  outputDir?: string;\n  url?: string;\n  viewport?: { width: number; height: number };\n  delay?: number;\n  format?: 'mp4' | 'gif' | 'webm';\n  duration?: number;\n  mode?: 'basic' | 'advanced' | 'full' | 'overview' | 'detailed' | 'all';\n  multiple?: boolean;\n  browserType?: 'brave' | 'chrome' | 'firefox';\n}\n\nexport interface CaptureResult {\n  success: boolean;\n  outputPath: string;\n  duration: number;\n  timestamp: string;\n  url: string;\n  mode?: string;\n  sections?: { name: string; path: string }[];\n  error?: string;\n}\n\nexport interface BrowserLaunchOptions {\n  headless?: boolean;\n  viewport?: { width: number; height: number };\n  recordVideo?: boolean;\n  videoSize?: { width: number; height: number };\n  browserType?: 'brave' | 'chrome' | 'firefox';\n  timeout?: number;\n}\n",
            "properties": [
                {
                    "name": "duration",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "error",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 21
                },
                {
                    "name": "mode",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 19
                },
                {
                    "name": "outputPath",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15
                },
                {
                    "name": "sections",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 20
                },
                {
                    "name": "success",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 14
                },
                {
                    "name": "timestamp",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "url",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 18
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "EnhancedLineAnalysis",
            "id": "interface-EnhancedLineAnalysis-cc01c88b56c2eb0b88baa736de26edf66653299b14fecfbb0dc7434c68b3977c7f382c4e601296066b01dfe98a03a03a66ecf008c0598e91718873cd4c5aefdb",
            "file": "src/app/services/poetry/poetry-analyzer.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject, signal } from '@angular/core';\nimport { PoetryAnalysisService } from './poetry-analysis.service';\nimport { PoetrySuggestionsService } from './poetry-suggestions.service';\nimport { PoetryPatternsService } from './poetry-patterns.service';\nimport { RhymeAnalysisService } from './rhyme-analysis.service';\nimport { PoemQualityService, type QualityMetrics } from './poem-quality.service';\nimport {\n  MeterAnalysisService,\n  type MeterAnalysis,\n  type RhythmSuggestion,\n} from './meter-analysis.service';\nimport {\n  RitaService,\n  type GrammaticalAnalysis,\n  type AlliterationMatch,\n  type AlternativeWord,\n} from './rita.service';\nimport { POETRY_FORMS, POETRY_EXAMPLES } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface EnhancedLineAnalysis extends LineAnalysis {\n  words: {\n    word: string;\n    syllables: number;\n    pos: string;\n    phones: string;\n    grammar?: GrammaticalAnalysis;\n  }[];\n  alliterations?: AlliterationMatch[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n}\n\nexport interface EnhancedPoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: EnhancedLineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n  overallAlliterations: AlliterationMatch[];\n  detectedPatterns: string[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n  meterAnalysis?: MeterAnalysis;\n}\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalyzerService {\n  private readonly analysis = inject(PoetryAnalysisService);\n  private readonly suggestions = inject(PoetrySuggestionsService);\n  private readonly patterns = inject(PoetryPatternsService);\n  private readonly rhymes = inject(RhymeAnalysisService);\n  private readonly quality = inject(PoemQualityService);\n  private readonly meterService = inject(MeterAnalysisService);\n  private readonly rita = inject(RitaService);\n\n  readonly isLoading = signal(false);\n  readonly result = signal<EnhancedPoetryResult | null>(null);\n  readonly selectedWord = signal<string | null>(null);\n  readonly wordAlternatives = signal<WordSuggestionData | null>(null);\n  readonly qualityMetrics = signal<QualityMetrics | null>(null);\n  readonly selectedForm = signal<string>('haiku');\n  readonly poemText = signal<string>('');\n  readonly rhythmSuggestions = signal<RhythmSuggestion[]>([]);\n\n  async analyze(formKey: string, rawLines: string[]): Promise<EnhancedPoetryResult> {\n    this.isLoading.set(true);\n\n    try {\n      const form = POETRY_FORMS[formKey];\n      if (!form) {\n        throw new Error(`Unknown form \"${formKey}\"`);\n      }\n\n      const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n      // Análisis dinámico basado en el poema actual\n      const typos = await this.rita.detectTypos(lines);\n      const meterAnalysis = this.meterService.detectMeter(lines);\n      const rhythmSuggestions = this.meterService.generateRhythmSuggestions(\n        lines,\n        meterAnalysis.type\n      );\n      this.rhythmSuggestions.set(rhythmSuggestions);\n\n      const lineAnalyses: EnhancedLineAnalysis[] = await Promise.all(\n        lines.map(async (line, index) => {\n          const analysis = this.rita.analyzeLine(line);\n          const words = this.rita.analyzeWords(line);\n          const alliterations = this.rita.detectAlliterations(line);\n          const expected = form.pattern[index] ?? 0;\n\n          const wordsWithGrammar = words.map((word) => ({\n            ...word,\n            grammar: this.rita.analyzeGrammar(word.word),\n          }));\n\n          return {\n            text: line,\n            count: analysis.syllables,\n            expected,\n            match: analysis.syllables === expected,\n            syllables: analysis.breakdown,\n            stresses: analysis.stresses,\n            words: wordsWithGrammar,\n            alliterations: alliterations.length > 0 ? alliterations : undefined,\n            typos: typos.filter((t) => t.line === index),\n          };\n        })\n      );\n\n      // Calcular calidad basada en el poema actual\n      const quality = this.quality.assessQuality(\n        lines,\n        form.pattern,\n        this.createResultForQualityAssessment(formKey, lineAnalyses)\n      );\n\n      const overallAlliterations = this.rhymes.detectCrossLineAlliterations(lines);\n      const detectedPatterns = [\n        ...this.detectPatterns(lineAnalyses),\n        ...this.generateMeterPatterns(meterAnalysis),\n      ];\n\n      const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n      const mismatches = lineAnalyses.filter((l) => !l.match).length;\n      const summary = ok\n        ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n            '-'\n          )} pattern`\n        : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n      const suggestions = this.generateEnhancedSuggestions(\n        lineAnalyses,\n        form.pattern,\n        meterAnalysis\n      );\n      const rhymeScheme = lines.length > 1 ? this.rita.analyzeRhymeScheme(lines) : undefined;\n\n      const result: EnhancedPoetryResult = {\n        ok,\n        form: formKey,\n        totalLines: {\n          expected: form.pattern.length,\n          actual: lineAnalyses.length,\n        },\n        lines: lineAnalyses,\n        summary,\n        rhymeScheme,\n        suggestions,\n        overallAlliterations,\n        detectedPatterns,\n        typos: typos.length > 0 ? typos : undefined,\n        meterAnalysis,\n      };\n\n      this.result.set(result);\n      this.qualityMetrics.set(quality);\n      return result;\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  async selectWordEnhanced(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) return;\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.suggestions.getWordAlternativesEnhanced(\n              word,\n              neededSyllables,\n              {\n                pos: wordAnalysis.pos,\n                lineIndex: result.lines.indexOf(line),\n                isLineEnd: line.words[line.words.length - 1]?.word === word,\n                previousWord: this.getPreviousWord(line.words, word),\n              }\n            );\n\n            this.wordAlternatives.set(alternatives);\n          } catch (error) {\n            console.warn('Error getting enhanced alternatives:', error);\n            await this.selectWord(word);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  async selectWord(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) {\n      return;\n    }\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.rita.suggestAlternatives(word, neededSyllables, 8);\n            this.wordAlternatives.set({\n              original: word,\n              currentSyllables: wordAnalysis.syllables,\n              targetSyllables: neededSyllables,\n              alternatives,\n            });\n          } catch (error) {\n            console.warn('Error getting word alternatives:', error);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  loadExample(): void {\n    const formId = this.selectedForm();\n    const example = POETRY_EXAMPLES[formId];\n    if (example) {\n      this.poemText.set(example.join('\\n'));\n      // Analizar automáticamente el ejemplo cargado\n      this.analyze(formId, example);\n    }\n  }\n\n  assessQuality(): void {\n    const result = this.result();\n    if (!result) return;\n\n    const lines = result.lines.map((l) => l.text);\n    const pattern = POETRY_FORMS[result.form].pattern;\n\n    const metrics = this.quality.assessQuality(lines, pattern, result);\n    this.qualityMetrics.set(metrics);\n  }\n\n  replaceWord(oldWord: string, newWord: string): void {\n    const result = this.result();\n    if (!result) return;\n\n    const updatedLines = result.lines.map((line) => {\n      const updatedText = line.text.replace(new RegExp(`\\\\b${oldWord}\\\\b`, 'gi'), newWord);\n      return updatedText;\n    });\n\n    this.poemText.set(updatedLines.join('\\n'));\n    this.analyze(result.form, updatedLines);\n    this.selectWordEnhanced(null);\n  }\n\n  clear(): void {\n    this.result.set(null);\n    this.selectedWord.set(null);\n    this.wordAlternatives.set(null);\n    this.qualityMetrics.set(null);\n    this.rhythmSuggestions.set([]);\n    this.poemText.set('');\n  }\n\n  private detectPatterns(lines: EnhancedLineAnalysis[]): string[] {\n    const patterns: string[] = [];\n\n    // Detectar patrones basados en el análisis real\n    const stressPatterns = lines.map((l) => l.stresses).filter((s) => s);\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent stress pattern: ${firstPattern}`);\n      }\n    }\n\n    // Detectar aliteraciones en el poema actual\n    const linesWithAlliteration = lines.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length > 0) {\n      patterns.push(\n        `${linesWithAlliteration.length} line${\n          linesWithAlliteration.length > 1 ? 's' : ''\n        } contain alliteration`\n      );\n    }\n\n    // Análisis de vocabulario del poema actual\n    const allWords = lines.flatMap((l) => l.words);\n    const nouns = allWords.filter((w) => w.pos.startsWith('nn')).length;\n    const verbs = allWords.filter((w) => w.pos.startsWith('vb')).length;\n    const adjectives = allWords.filter((w) => w.pos.startsWith('jj')).length;\n    const adverbs = allWords.filter((w) => w.pos.startsWith('rb')).length;\n\n    if (nouns > verbs * 2) {\n      patterns.push('Noun-heavy composition (descriptive style)');\n    } else if (verbs > nouns * 1.5) {\n      patterns.push('Verb-heavy composition (active style)');\n    }\n\n    if (adjectives > allWords.length * 0.2) {\n      patterns.push('High use of adjectives (vivid imagery)');\n    }\n\n    if (adverbs > allWords.length * 0.15) {\n      patterns.push('Adverb-rich language (detailed action)');\n    }\n\n    // Análisis de longitud de palabras\n    const avgWordLength =\n      allWords.reduce((sum, w) => sum + w.word.length, 0) / (allWords.length || 1);\n    if (avgWordLength > 6) {\n      patterns.push('Complex vocabulary (long words)');\n    } else if (avgWordLength < 4) {\n      patterns.push('Simple vocabulary (short words)');\n    }\n\n    return patterns;\n  }\n\n  private generateMeterPatterns(meter: MeterAnalysis): string[] {\n    const patterns: string[] = [];\n\n    if (meter.consistency > 70) {\n      patterns.push(`Strong ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    } else if (meter.consistency > 40) {\n      patterns.push(`Emerging ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    }\n\n    if (meter.type !== 'irregular') {\n      patterns.push(`Meter: ${meter.pattern}`);\n    }\n\n    return patterns;\n  }\n\n  private generateEnhancedSuggestions(\n    lineAnalyses: EnhancedLineAnalysis[],\n    pattern: number[],\n    meterAnalysis: MeterAnalysis\n  ): string[] {\n    const suggestions: string[] = [];\n\n    // Sugerencias basadas en la estructura del poema actual\n    if (lineAnalyses.length < pattern.length) {\n      const missing = pattern.length - lineAnalyses.length;\n      suggestions.push(`Add ${missing} more line${missing > 1 ? 's' : ''} to complete the pattern`);\n    } else if (lineAnalyses.length > pattern.length) {\n      const extra = lineAnalyses.length - pattern.length;\n      suggestions.push(`Remove ${extra} line${extra > 1 ? 's' : ''} to match the pattern`);\n    }\n\n    // Sugerencias rítmicas basadas en el análisis métrico\n    if (meterAnalysis.consistency < 60) {\n      suggestions.push(\n        `Improve rhythm consistency: ${meterAnalysis.type} meter detected but inconsistent`\n      );\n    }\n\n    if (meterAnalysis.type === 'irregular' && lineAnalyses.length > 2) {\n      suggestions.push('Consider using a regular meter pattern for better poetic flow');\n    }\n\n    // Sugerencias específicas por línea\n    lineAnalyses.forEach((line, index) => {\n      if (!line.match && index < pattern.length) {\n        const lineSuggestions = this.rita.generateSuggestions(line.text, pattern[index]);\n        suggestions.push(`Line ${index + 1}: ${lineSuggestions[0]}`);\n\n        const diff = pattern[index] - line.count;\n        if (diff > 0) {\n          const shortWords = line.words.filter((w) => w.syllables === 1);\n          if (shortWords.length > 0) {\n            suggestions.push(`  → Try replacing \"${shortWords[0].word}\" with a longer synonym`);\n          }\n        } else if (diff < 0) {\n          const longWords = line.words\n            .filter((w) => w.syllables > 2)\n            .sort((a, b) => b.syllables - a.syllables);\n          if (longWords.length > 0) {\n            suggestions.push(\n              `  → Try replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter word`\n            );\n          }\n        }\n      }\n    });\n\n    // Sugerencias de dispositivos literarios\n    const linesWithAlliteration = lineAnalyses.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length === 0 && lineAnalyses.length > 2) {\n      suggestions.push('Consider adding alliteration for poetic effect');\n    }\n\n    const hasRhyme = lineAnalyses.some((line) =>\n      line.words.some(\n        (word) => (word.pos && word.pos.startsWith('nn')) || word.pos.startsWith('vb')\n      )\n    );\n    if (!hasRhyme && lineAnalyses.length > 1) {\n      suggestions.push('Try incorporating rhyme for musical quality');\n    }\n\n    return suggestions.slice(0, 6);\n  }\n\n  private getPreviousWord(words: { word: string }[], currentWord: string): string | undefined {\n    const currentIndex = words.findIndex((w) => w.word.toLowerCase() === currentWord.toLowerCase());\n    return currentIndex > 0 ? words[currentIndex - 1].word : undefined;\n  }\n\n  private createResultForQualityAssessment(\n    formKey: string,\n    lineAnalyses: EnhancedLineAnalysis[]\n  ): EnhancedPoetryResult {\n    const form = POETRY_FORMS[formKey];\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n    return {\n      ok,\n      form: formKey,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      lines: lineAnalyses,\n      summary: '',\n      suggestions: [],\n      overallAlliterations: [],\n      detectedPatterns: [],\n    };\n  }\n\n  isCompletePoem(): boolean {\n    const result = this.result();\n    if (!result) return false;\n\n    return (\n      result.lines.length === result.totalLines.expected && result.lines.every((line) => line.match)\n    );\n  }\n\n  getQuickStats(): {\n    totalSyllables: number;\n    avgSyllablesPerLine: number;\n    vocabularyRichness: number;\n  } {\n    const result = this.result();\n    if (!result || result.lines.length === 0) {\n      return { totalSyllables: 0, avgSyllablesPerLine: 0, vocabularyRichness: 0 };\n    }\n\n    const totalSyllables = result.lines.reduce((sum, line) => sum + line.count, 0);\n    const avgSyllablesPerLine = totalSyllables / result.lines.length;\n\n    const allWords = result.lines.flatMap((line) => line.words.map((w) => w.word.toLowerCase()));\n    const uniqueWords = new Set(allWords);\n    const vocabularyRichness = (uniqueWords.size / allWords.length) * 100;\n\n    return {\n      totalSyllables,\n      avgSyllablesPerLine: Math.round(avgSyllablesPerLine * 10) / 10,\n      vocabularyRichness: Math.round(vocabularyRichness * 10) / 10,\n    };\n  }\n}\n",
            "properties": [
                {
                    "name": "alliterations",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "AlliterationMatch[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 29
                },
                {
                    "name": "typos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 30
                },
                {
                    "name": "words",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": [
                "LineAnalysis"
            ]
        },
        {
            "name": "EnhancedPoetryResult",
            "id": "interface-EnhancedPoetryResult-cc01c88b56c2eb0b88baa736de26edf66653299b14fecfbb0dc7434c68b3977c7f382c4e601296066b01dfe98a03a03a66ecf008c0598e91718873cd4c5aefdb",
            "file": "src/app/services/poetry/poetry-analyzer.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject, signal } from '@angular/core';\nimport { PoetryAnalysisService } from './poetry-analysis.service';\nimport { PoetrySuggestionsService } from './poetry-suggestions.service';\nimport { PoetryPatternsService } from './poetry-patterns.service';\nimport { RhymeAnalysisService } from './rhyme-analysis.service';\nimport { PoemQualityService, type QualityMetrics } from './poem-quality.service';\nimport {\n  MeterAnalysisService,\n  type MeterAnalysis,\n  type RhythmSuggestion,\n} from './meter-analysis.service';\nimport {\n  RitaService,\n  type GrammaticalAnalysis,\n  type AlliterationMatch,\n  type AlternativeWord,\n} from './rita.service';\nimport { POETRY_FORMS, POETRY_EXAMPLES } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface EnhancedLineAnalysis extends LineAnalysis {\n  words: {\n    word: string;\n    syllables: number;\n    pos: string;\n    phones: string;\n    grammar?: GrammaticalAnalysis;\n  }[];\n  alliterations?: AlliterationMatch[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n}\n\nexport interface EnhancedPoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: EnhancedLineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n  overallAlliterations: AlliterationMatch[];\n  detectedPatterns: string[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n  meterAnalysis?: MeterAnalysis;\n}\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalyzerService {\n  private readonly analysis = inject(PoetryAnalysisService);\n  private readonly suggestions = inject(PoetrySuggestionsService);\n  private readonly patterns = inject(PoetryPatternsService);\n  private readonly rhymes = inject(RhymeAnalysisService);\n  private readonly quality = inject(PoemQualityService);\n  private readonly meterService = inject(MeterAnalysisService);\n  private readonly rita = inject(RitaService);\n\n  readonly isLoading = signal(false);\n  readonly result = signal<EnhancedPoetryResult | null>(null);\n  readonly selectedWord = signal<string | null>(null);\n  readonly wordAlternatives = signal<WordSuggestionData | null>(null);\n  readonly qualityMetrics = signal<QualityMetrics | null>(null);\n  readonly selectedForm = signal<string>('haiku');\n  readonly poemText = signal<string>('');\n  readonly rhythmSuggestions = signal<RhythmSuggestion[]>([]);\n\n  async analyze(formKey: string, rawLines: string[]): Promise<EnhancedPoetryResult> {\n    this.isLoading.set(true);\n\n    try {\n      const form = POETRY_FORMS[formKey];\n      if (!form) {\n        throw new Error(`Unknown form \"${formKey}\"`);\n      }\n\n      const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n      // Análisis dinámico basado en el poema actual\n      const typos = await this.rita.detectTypos(lines);\n      const meterAnalysis = this.meterService.detectMeter(lines);\n      const rhythmSuggestions = this.meterService.generateRhythmSuggestions(\n        lines,\n        meterAnalysis.type\n      );\n      this.rhythmSuggestions.set(rhythmSuggestions);\n\n      const lineAnalyses: EnhancedLineAnalysis[] = await Promise.all(\n        lines.map(async (line, index) => {\n          const analysis = this.rita.analyzeLine(line);\n          const words = this.rita.analyzeWords(line);\n          const alliterations = this.rita.detectAlliterations(line);\n          const expected = form.pattern[index] ?? 0;\n\n          const wordsWithGrammar = words.map((word) => ({\n            ...word,\n            grammar: this.rita.analyzeGrammar(word.word),\n          }));\n\n          return {\n            text: line,\n            count: analysis.syllables,\n            expected,\n            match: analysis.syllables === expected,\n            syllables: analysis.breakdown,\n            stresses: analysis.stresses,\n            words: wordsWithGrammar,\n            alliterations: alliterations.length > 0 ? alliterations : undefined,\n            typos: typos.filter((t) => t.line === index),\n          };\n        })\n      );\n\n      // Calcular calidad basada en el poema actual\n      const quality = this.quality.assessQuality(\n        lines,\n        form.pattern,\n        this.createResultForQualityAssessment(formKey, lineAnalyses)\n      );\n\n      const overallAlliterations = this.rhymes.detectCrossLineAlliterations(lines);\n      const detectedPatterns = [\n        ...this.detectPatterns(lineAnalyses),\n        ...this.generateMeterPatterns(meterAnalysis),\n      ];\n\n      const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n      const mismatches = lineAnalyses.filter((l) => !l.match).length;\n      const summary = ok\n        ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n            '-'\n          )} pattern`\n        : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n      const suggestions = this.generateEnhancedSuggestions(\n        lineAnalyses,\n        form.pattern,\n        meterAnalysis\n      );\n      const rhymeScheme = lines.length > 1 ? this.rita.analyzeRhymeScheme(lines) : undefined;\n\n      const result: EnhancedPoetryResult = {\n        ok,\n        form: formKey,\n        totalLines: {\n          expected: form.pattern.length,\n          actual: lineAnalyses.length,\n        },\n        lines: lineAnalyses,\n        summary,\n        rhymeScheme,\n        suggestions,\n        overallAlliterations,\n        detectedPatterns,\n        typos: typos.length > 0 ? typos : undefined,\n        meterAnalysis,\n      };\n\n      this.result.set(result);\n      this.qualityMetrics.set(quality);\n      return result;\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  async selectWordEnhanced(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) return;\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.suggestions.getWordAlternativesEnhanced(\n              word,\n              neededSyllables,\n              {\n                pos: wordAnalysis.pos,\n                lineIndex: result.lines.indexOf(line),\n                isLineEnd: line.words[line.words.length - 1]?.word === word,\n                previousWord: this.getPreviousWord(line.words, word),\n              }\n            );\n\n            this.wordAlternatives.set(alternatives);\n          } catch (error) {\n            console.warn('Error getting enhanced alternatives:', error);\n            await this.selectWord(word);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  async selectWord(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) {\n      return;\n    }\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.rita.suggestAlternatives(word, neededSyllables, 8);\n            this.wordAlternatives.set({\n              original: word,\n              currentSyllables: wordAnalysis.syllables,\n              targetSyllables: neededSyllables,\n              alternatives,\n            });\n          } catch (error) {\n            console.warn('Error getting word alternatives:', error);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  loadExample(): void {\n    const formId = this.selectedForm();\n    const example = POETRY_EXAMPLES[formId];\n    if (example) {\n      this.poemText.set(example.join('\\n'));\n      // Analizar automáticamente el ejemplo cargado\n      this.analyze(formId, example);\n    }\n  }\n\n  assessQuality(): void {\n    const result = this.result();\n    if (!result) return;\n\n    const lines = result.lines.map((l) => l.text);\n    const pattern = POETRY_FORMS[result.form].pattern;\n\n    const metrics = this.quality.assessQuality(lines, pattern, result);\n    this.qualityMetrics.set(metrics);\n  }\n\n  replaceWord(oldWord: string, newWord: string): void {\n    const result = this.result();\n    if (!result) return;\n\n    const updatedLines = result.lines.map((line) => {\n      const updatedText = line.text.replace(new RegExp(`\\\\b${oldWord}\\\\b`, 'gi'), newWord);\n      return updatedText;\n    });\n\n    this.poemText.set(updatedLines.join('\\n'));\n    this.analyze(result.form, updatedLines);\n    this.selectWordEnhanced(null);\n  }\n\n  clear(): void {\n    this.result.set(null);\n    this.selectedWord.set(null);\n    this.wordAlternatives.set(null);\n    this.qualityMetrics.set(null);\n    this.rhythmSuggestions.set([]);\n    this.poemText.set('');\n  }\n\n  private detectPatterns(lines: EnhancedLineAnalysis[]): string[] {\n    const patterns: string[] = [];\n\n    // Detectar patrones basados en el análisis real\n    const stressPatterns = lines.map((l) => l.stresses).filter((s) => s);\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent stress pattern: ${firstPattern}`);\n      }\n    }\n\n    // Detectar aliteraciones en el poema actual\n    const linesWithAlliteration = lines.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length > 0) {\n      patterns.push(\n        `${linesWithAlliteration.length} line${\n          linesWithAlliteration.length > 1 ? 's' : ''\n        } contain alliteration`\n      );\n    }\n\n    // Análisis de vocabulario del poema actual\n    const allWords = lines.flatMap((l) => l.words);\n    const nouns = allWords.filter((w) => w.pos.startsWith('nn')).length;\n    const verbs = allWords.filter((w) => w.pos.startsWith('vb')).length;\n    const adjectives = allWords.filter((w) => w.pos.startsWith('jj')).length;\n    const adverbs = allWords.filter((w) => w.pos.startsWith('rb')).length;\n\n    if (nouns > verbs * 2) {\n      patterns.push('Noun-heavy composition (descriptive style)');\n    } else if (verbs > nouns * 1.5) {\n      patterns.push('Verb-heavy composition (active style)');\n    }\n\n    if (adjectives > allWords.length * 0.2) {\n      patterns.push('High use of adjectives (vivid imagery)');\n    }\n\n    if (adverbs > allWords.length * 0.15) {\n      patterns.push('Adverb-rich language (detailed action)');\n    }\n\n    // Análisis de longitud de palabras\n    const avgWordLength =\n      allWords.reduce((sum, w) => sum + w.word.length, 0) / (allWords.length || 1);\n    if (avgWordLength > 6) {\n      patterns.push('Complex vocabulary (long words)');\n    } else if (avgWordLength < 4) {\n      patterns.push('Simple vocabulary (short words)');\n    }\n\n    return patterns;\n  }\n\n  private generateMeterPatterns(meter: MeterAnalysis): string[] {\n    const patterns: string[] = [];\n\n    if (meter.consistency > 70) {\n      patterns.push(`Strong ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    } else if (meter.consistency > 40) {\n      patterns.push(`Emerging ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    }\n\n    if (meter.type !== 'irregular') {\n      patterns.push(`Meter: ${meter.pattern}`);\n    }\n\n    return patterns;\n  }\n\n  private generateEnhancedSuggestions(\n    lineAnalyses: EnhancedLineAnalysis[],\n    pattern: number[],\n    meterAnalysis: MeterAnalysis\n  ): string[] {\n    const suggestions: string[] = [];\n\n    // Sugerencias basadas en la estructura del poema actual\n    if (lineAnalyses.length < pattern.length) {\n      const missing = pattern.length - lineAnalyses.length;\n      suggestions.push(`Add ${missing} more line${missing > 1 ? 's' : ''} to complete the pattern`);\n    } else if (lineAnalyses.length > pattern.length) {\n      const extra = lineAnalyses.length - pattern.length;\n      suggestions.push(`Remove ${extra} line${extra > 1 ? 's' : ''} to match the pattern`);\n    }\n\n    // Sugerencias rítmicas basadas en el análisis métrico\n    if (meterAnalysis.consistency < 60) {\n      suggestions.push(\n        `Improve rhythm consistency: ${meterAnalysis.type} meter detected but inconsistent`\n      );\n    }\n\n    if (meterAnalysis.type === 'irregular' && lineAnalyses.length > 2) {\n      suggestions.push('Consider using a regular meter pattern for better poetic flow');\n    }\n\n    // Sugerencias específicas por línea\n    lineAnalyses.forEach((line, index) => {\n      if (!line.match && index < pattern.length) {\n        const lineSuggestions = this.rita.generateSuggestions(line.text, pattern[index]);\n        suggestions.push(`Line ${index + 1}: ${lineSuggestions[0]}`);\n\n        const diff = pattern[index] - line.count;\n        if (diff > 0) {\n          const shortWords = line.words.filter((w) => w.syllables === 1);\n          if (shortWords.length > 0) {\n            suggestions.push(`  → Try replacing \"${shortWords[0].word}\" with a longer synonym`);\n          }\n        } else if (diff < 0) {\n          const longWords = line.words\n            .filter((w) => w.syllables > 2)\n            .sort((a, b) => b.syllables - a.syllables);\n          if (longWords.length > 0) {\n            suggestions.push(\n              `  → Try replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter word`\n            );\n          }\n        }\n      }\n    });\n\n    // Sugerencias de dispositivos literarios\n    const linesWithAlliteration = lineAnalyses.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length === 0 && lineAnalyses.length > 2) {\n      suggestions.push('Consider adding alliteration for poetic effect');\n    }\n\n    const hasRhyme = lineAnalyses.some((line) =>\n      line.words.some(\n        (word) => (word.pos && word.pos.startsWith('nn')) || word.pos.startsWith('vb')\n      )\n    );\n    if (!hasRhyme && lineAnalyses.length > 1) {\n      suggestions.push('Try incorporating rhyme for musical quality');\n    }\n\n    return suggestions.slice(0, 6);\n  }\n\n  private getPreviousWord(words: { word: string }[], currentWord: string): string | undefined {\n    const currentIndex = words.findIndex((w) => w.word.toLowerCase() === currentWord.toLowerCase());\n    return currentIndex > 0 ? words[currentIndex - 1].word : undefined;\n  }\n\n  private createResultForQualityAssessment(\n    formKey: string,\n    lineAnalyses: EnhancedLineAnalysis[]\n  ): EnhancedPoetryResult {\n    const form = POETRY_FORMS[formKey];\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n    return {\n      ok,\n      form: formKey,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      lines: lineAnalyses,\n      summary: '',\n      suggestions: [],\n      overallAlliterations: [],\n      detectedPatterns: [],\n    };\n  }\n\n  isCompletePoem(): boolean {\n    const result = this.result();\n    if (!result) return false;\n\n    return (\n      result.lines.length === result.totalLines.expected && result.lines.every((line) => line.match)\n    );\n  }\n\n  getQuickStats(): {\n    totalSyllables: number;\n    avgSyllablesPerLine: number;\n    vocabularyRichness: number;\n  } {\n    const result = this.result();\n    if (!result || result.lines.length === 0) {\n      return { totalSyllables: 0, avgSyllablesPerLine: 0, vocabularyRichness: 0 };\n    }\n\n    const totalSyllables = result.lines.reduce((sum, line) => sum + line.count, 0);\n    const avgSyllablesPerLine = totalSyllables / result.lines.length;\n\n    const allWords = result.lines.flatMap((line) => line.words.map((w) => w.word.toLowerCase()));\n    const uniqueWords = new Set(allWords);\n    const vocabularyRichness = (uniqueWords.size / allWords.length) * 100;\n\n    return {\n      totalSyllables,\n      avgSyllablesPerLine: Math.round(avgSyllablesPerLine * 10) / 10,\n      vocabularyRichness: Math.round(vocabularyRichness * 10) / 10,\n    };\n  }\n}\n",
            "properties": [
                {
                    "name": "detectedPatterns",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 49
                },
                {
                    "name": "form",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 39
                },
                {
                    "name": "lines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "EnhancedLineAnalysis[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 44
                },
                {
                    "name": "meterAnalysis",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MeterAnalysis",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 55
                },
                {
                    "name": "ok",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 38
                },
                {
                    "name": "overallAlliterations",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "AlliterationMatch[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 48
                },
                {
                    "name": "rhymeScheme",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 46
                },
                {
                    "name": "suggestions",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 47
                },
                {
                    "name": "summary",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 45
                },
                {
                    "name": "totalLines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 40
                },
                {
                    "name": "typos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 50
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "GrammaticalAnalysis",
            "id": "interface-GrammaticalAnalysis-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "conjugations",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 64
                },
                {
                    "name": "isAdjective",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 62
                },
                {
                    "name": "isAdverb",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 63
                },
                {
                    "name": "isNoun",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 60
                },
                {
                    "name": "isVerb",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 61
                },
                {
                    "name": "pluralForm",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 65
                },
                {
                    "name": "pos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 58
                },
                {
                    "name": "posLabel",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 59
                },
                {
                    "name": "stemForm",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 66
                },
                {
                    "name": "word",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 57
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "LineAnalysis",
            "id": "interface-LineAnalysis-9f2e5258c8513a233d7e44d78b9506fca3eaeaafe3f4b50c162e9e041de2e3840e9864cfac6cecc24684c7a1eef955a1eafc933f527dada08a89fe2e14324029",
            "file": "src/app/models/poetry.model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface PoetryForm {\n  id: string;\n  name: string;\n  pattern: number[];\n  lines: number;\n  origin: string;\n  description: string;\n}\n\nexport interface LineAnalysis {\n  text: string;\n  count: number;\n  expected: number;\n  match: boolean;\n  syllables: string[];\n  stresses?: string;\n}\n\nexport interface PoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: LineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n}\n\nexport interface MeterAnalysis {\n  pattern: string;\n  type: string;\n  consistency: number;\n}\n",
            "properties": [
                {
                    "name": "count",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 12
                },
                {
                    "name": "expected",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 13
                },
                {
                    "name": "match",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 14
                },
                {
                    "name": "stresses",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15
                },
                {
                    "name": "text",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 11
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "LineData",
            "id": "interface-LineData-b2b38f3e364650d03899dc34d883b21b1b9e33d42f4c735755881c0d6c700eff664be1af9ccd2e4d65301e2e55a31e7a9b581178af334913b9c04dab44b87fd3",
            "file": "src/app/components/ui/multiline-input/multiline-input.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {\n  Component,\n  Input,\n  Output,\n  EventEmitter,\n  forwardRef,\n  HostListener,\n  signal,\n  computed,\n  inject,\n  effect,\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\nimport { RitaService, StateService } from '../../../services/';\n\nexport interface LineData {\n  text: string;\n  number: number;\n  focused: boolean;\n  syllables: number;\n  expectedSyllables: number;\n  isCorrect: boolean;\n  isOver: boolean;\n}\n\nexport interface SyllableSegment {\n  index: number;\n  filled: boolean;\n}\n\n@Component({\n  selector: 'app-multiline-input',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './multiline-input.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => MultilineInputComponent),\n      multi: true,\n    },\n  ],\n})\nexport class MultilineInputComponent implements ControlValueAccessor {\n  @Input() label = '';\n  @Input() placeholder = 'Write your poem line by line...';\n  @Input() error = '';\n  @Input() disabled = false;\n  @Input() rows = 12;\n  @Input() id = 'multiline-input';\n  @Input() showLineNumbers = true;\n  @Input() showLineValidation = false;\n  @Input() expectedPattern: number[] = [];\n  @Input() fontSizeClass = 'text-base';\n\n  private readonly rita = inject(RitaService);\n  private readonly stateService = inject(StateService);\n\n  readonly lines = signal<LineData[]>([]);\n  readonly focusedLineIndex = signal<number | null>(null);\n\n  readonly poemText = computed(() =>\n    this.lines()\n      .map((l) => l.text)\n      .join('\\n')\n  );\n\n  @Input()\n  get value(): string {\n    return this.poemText();\n  }\n  set value(val: string) {\n    this.initializeLines(val || '');\n    this.onChange(this.poemText());\n  }\n\n  @Output() valueChange = new EventEmitter<string>();\n  @Output() inputBlur = new EventEmitter<void>();\n  @Output() lineFocus = new EventEmitter<{ index: number; text: string }>();\n  @Output() lineValidationChange = new EventEmitter<LineData[]>();\n\n  private onChange: (value: string) => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private onTouched: () => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private isInternalUpdate = false;\n\n  constructor() {\n    this.initializeLines('');\n\n    effect(() => {\n      const pattern = this.stateService.currentPattern();\n      const newRows = this.stateService.expectedLines();\n      const sharedText = this.stateService.poemText();\n      const shouldLoadExample = this.stateService.shouldLoadExample();\n\n      if (pattern.length > 0) {\n        this.expectedPattern = pattern;\n        this.rows = newRows;\n\n        if (shouldLoadExample) {\n          this.stateService.loadExample();\n          this.stateService.consumeLoadExample();\n          return;\n        }\n\n        if (!this.isInternalUpdate && sharedText !== this.poemText()) {\n          this.initializeLines(sharedText);\n        }\n      }\n    });\n  }\n\n  private initializeLines(text: string): void {\n    const linesArray = text.split('\\n');\n    const total = this.rows;\n    const result: LineData[] = [];\n\n    for (let i = 0; i < total; i++) {\n      const expectedSyllables = this.expectedPattern[i] || 0;\n      const lineText = linesArray[i] || '';\n      const syllables = lineText ? this.rita.analyzeLine(lineText).syllables : 0;\n\n      result.push({\n        text: lineText,\n        number: i + 1,\n        focused: false,\n        syllables,\n        expectedSyllables,\n        isCorrect: syllables === expectedSyllables && syllables > 0,\n        isOver: syllables > expectedSyllables,\n      });\n    }\n\n    this.lines.set(result);\n    this.updateLineValidation();\n  }\n\n  writeValue(value: string): void {\n    if (!this.isInternalUpdate) {\n      this.initializeLines(value || '');\n    }\n  }\n\n  registerOnChange(fn: (value: string) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  onLineInput(index: number, text: string): void {\n    this.isInternalUpdate = true;\n\n    const updated = [...this.lines()];\n    updated[index].text = text;\n\n    if (this.showLineValidation) {\n      this.updateLineSyllables(updated[index]);\n    }\n\n    this.lines.set(updated);\n    this.emitChanges();\n    this.updateLineValidation();\n\n    this.stateService.updatePoemLines(updated.map((line) => line.text));\n\n    setTimeout(() => {\n      this.isInternalUpdate = false;\n    }, 0);\n  }\n\n  onLineFocus(index: number): void {\n    this.focusedLineIndex.set(index);\n    this.lineFocus.emit({ index, text: this.lines()[index].text });\n  }\n\n  onLineBlur(): void {\n    this.focusedLineIndex.set(null);\n    this.onTouched();\n    this.inputBlur.emit();\n  }\n\n  @HostListener('keydown', ['$event'])\n  handleKeyboardNavigation(event: KeyboardEvent): void {\n    const current = this.focusedLineIndex();\n    if (current === null) return;\n\n    const lines = this.lines();\n\n    switch (event.key) {\n      case 'ArrowUp':\n        event.preventDefault();\n        if (current > 0) this.focusLine(current - 1);\n        break;\n\n      case 'ArrowDown':\n        event.preventDefault();\n        if (current < lines.length - 1) this.focusLine(current + 1);\n        break;\n\n      case 'Enter':\n        if (!event.shiftKey) {\n          event.preventDefault();\n          if (current < lines.length - 1) {\n            this.focusLine(current + 1);\n          }\n        }\n        break;\n\n      case 'Tab':\n        event.preventDefault();\n        this.insertTextAtCursor('  ');\n        break;\n    }\n  }\n\n  private focusLine(index: number): void {\n    const input = document.getElementById(`${this.id}-line-${index}`) as HTMLInputElement;\n    if (!input) return;\n\n    input.focus();\n    this.focusedLineIndex.set(index);\n  }\n\n  private insertTextAtCursor(text: string): void {\n    const current = this.focusedLineIndex();\n    if (current === null) return;\n\n    const input = document.getElementById(`${this.id}-line-${current}`) as HTMLInputElement;\n    if (!input) return;\n\n    const start = input.selectionStart || 0;\n    const end = input.selectionEnd || 0;\n    const currentText = this.lines()[current].text;\n\n    const newText = currentText.substring(0, start) + text + currentText.substring(end);\n\n    const updated = [...this.lines()];\n    updated[current].text = newText;\n\n    if (this.showLineValidation) {\n      this.updateLineSyllables(updated[current]);\n    }\n\n    this.lines.set(updated);\n    this.emitChanges();\n    this.updateLineValidation();\n\n    setTimeout(() => {\n      input.focus();\n      input.setSelectionRange(start + text.length, start + text.length);\n    });\n  }\n\n  private updateLineSyllables(line: LineData): void {\n    if (!line.text.trim()) {\n      line.syllables = 0;\n      line.isCorrect = false;\n      line.isOver = false;\n      return;\n    }\n\n    const analysis = this.rita.analyzeLine(line.text);\n    line.syllables = analysis.syllables;\n    line.isCorrect = line.syllables === line.expectedSyllables;\n    line.isOver = line.syllables > line.expectedSyllables;\n  }\n\n  private updateLineValidation(): void {\n    if (this.showLineValidation) {\n      const lines = this.lines();\n      lines.forEach((line) => {\n        if (line.text.trim()) {\n          this.updateLineSyllables(line);\n        }\n      });\n      this.lineValidationChange.emit(lines);\n    }\n  }\n\n  private emitChanges(): void {\n    this.onChange(this.poemText());\n    this.valueChange.emit(this.poemText());\n  }\n\n  getSyllableSegments(line: LineData): SyllableSegment[] {\n    const segments: SyllableSegment[] = [];\n    const expected = line.expectedSyllables;\n    const current = line.syllables;\n\n    for (let i = 0; i < expected; i++) {\n      segments.push({\n        index: i,\n        filled: i < current,\n      });\n    }\n\n    return segments;\n  }\n\n  getSyllableCountClass(line: LineData): string {\n    if (line.syllables === 0) return 'syllable-count-empty';\n    if (line.syllables === line.expectedSyllables) return 'syllable-count-perfect';\n    if (line.syllables > line.expectedSyllables) return 'syllable-count-over';\n\n    const progress = (line.syllables / line.expectedSyllables) * 100;\n    if (progress >= 75) return 'syllable-count-close';\n    if (progress >= 50) return 'syllable-count-medium';\n    return 'syllable-count-low';\n  }\n\n  clear(): void {\n    this.initializeLines('');\n    this.emitChanges();\n    this.focusLine(0);\n  }\n\n  focus(): void {\n    this.focusLine(0);\n  }\n\n  setText(text: string): void {\n    this.initializeLines(text);\n    this.emitChanges();\n  }\n\n  handleLineInput(event: Event, index: number): void {\n    const target = event.target as HTMLInputElement;\n    this.onLineInput(index, target.value);\n  }\n}\n",
            "properties": [
                {
                    "name": "expectedSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22
                },
                {
                    "name": "focused",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 20
                },
                {
                    "name": "isCorrect",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 23
                },
                {
                    "name": "isOver",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 24
                },
                {
                    "name": "number",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 19
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 21
                },
                {
                    "name": "text",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 18
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "MeterAnalysis",
            "id": "interface-MeterAnalysis-9f2e5258c8513a233d7e44d78b9506fca3eaeaafe3f4b50c162e9e041de2e3840e9864cfac6cecc24684c7a1eef955a1eafc933f527dada08a89fe2e14324029",
            "file": "src/app/models/poetry.model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface PoetryForm {\n  id: string;\n  name: string;\n  pattern: number[];\n  lines: number;\n  origin: string;\n  description: string;\n}\n\nexport interface LineAnalysis {\n  text: string;\n  count: number;\n  expected: number;\n  match: boolean;\n  syllables: string[];\n  stresses?: string;\n}\n\nexport interface PoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: LineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n}\n\nexport interface MeterAnalysis {\n  pattern: string;\n  type: string;\n  consistency: number;\n}\n",
            "properties": [
                {
                    "name": "consistency",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 35
                },
                {
                    "name": "pattern",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 33
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 34
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "MeterAnalysis",
            "id": "interface-MeterAnalysis-c8ff5e422e8554e34650a202a0a41732300cf56a1ad0853b3fc676499f4c2ce0c687dd9ecb78f3df657e4274fec3fdc34b0adea4b92825d6d4813ddbc9d71d07-1",
            "file": "src/app/services/poetry/meter-analysis.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService } from './rita.service';\n\nexport type MeterType = 'iambic' | 'trochaic' | 'anapestic' | 'dactylic' | 'irregular';\n\nexport interface MeterAnalysis {\n  type: MeterType;\n  consistency: number;\n  pattern: string;\n  description: string;\n  examples: string[];\n}\n\nexport interface RhythmSuggestion {\n  line: number;\n  current: string;\n  issue: string;\n  suggestion: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class MeterAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  detectMeter(lines: string[]): MeterAnalysis {\n    const stressPatterns = lines\n      .map((line) => this.rita.analyzeLine(line).stresses)\n      .filter((s) => s && s.length > 0);\n\n    if (stressPatterns.length === 0) {\n      return this.getIrregularMeter();\n    }\n\n    const meterCounts = {\n      iambic: 0,\n      trochaic: 0,\n      anapestic: 0,\n      dactylic: 0,\n    };\n\n    stressPatterns.forEach((pattern) => {\n      const stresses = pattern.split('/').map((s) => parseInt(s));\n      const type = this.classifyStressPattern(stresses);\n      if (type !== 'irregular') {\n        meterCounts[type]++;\n      }\n    });\n\n    const total = stressPatterns.length;\n    const dominant = Object.entries(meterCounts).sort(([, a], [, b]) => b - a)[0];\n\n    if (!dominant) {\n      return this.getIrregularMeter();\n    }\n\n    const [type, count] = dominant as [MeterType, number];\n    const consistency = (count / total) * 100;\n\n    if (consistency < 40) {\n      return this.getIrregularMeter();\n    }\n\n    return {\n      type,\n      consistency,\n      pattern: this.getMeterPattern(type),\n      description: this.getMeterDescription(type),\n      examples: this.getMeterExamples(type),\n    };\n  }\n\n  private classifyStressPattern(stresses: number[]): MeterType | 'irregular' {\n    if (stresses.length < 2) return 'irregular';\n\n    const pairs: string[] = [];\n    for (let i = 0; i < stresses.length - 1; i++) {\n      pairs.push(`${stresses[i]}${stresses[i + 1]}`);\n    }\n\n    const pairCounts = {\n      '01': 0,\n      '10': 0,\n      '001': 0,\n      '100': 0,\n    };\n\n    pairs.forEach((pair) => {\n      if (pair === '01') pairCounts['01']++;\n      if (pair === '10') pairCounts['10']++;\n    });\n\n    for (let i = 0; i < stresses.length - 2; i++) {\n      const triplet = `${stresses[i]}${stresses[i + 1]}${stresses[i + 2]}`;\n      if (triplet === '001') pairCounts['001']++;\n      if (triplet === '100') pairCounts['100']++;\n    }\n\n    const max = Math.max(...Object.values(pairCounts));\n    if (max === 0) return 'irregular';\n\n    if (pairCounts['01'] === max) return 'iambic';\n    if (pairCounts['10'] === max) return 'trochaic';\n    if (pairCounts['001'] === max) return 'anapestic';\n    if (pairCounts['100'] === max) return 'dactylic';\n\n    return 'irregular';\n  }\n\n  generateRhythmSuggestions(lines: string[], targetMeter?: MeterType): RhythmSuggestion[] {\n    const suggestions: RhythmSuggestion[] = [];\n    const detectedMeter = this.detectMeter(lines);\n    const target = targetMeter || detectedMeter.type;\n\n    if (target === 'irregular') {\n      return suggestions;\n    }\n\n    lines.forEach((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      if (!analysis.stresses) return;\n\n      const stresses = analysis.stresses.split('/').map((s) => parseInt(s));\n      const lineType = this.classifyStressPattern(stresses);\n\n      if (lineType !== target) {\n        suggestions.push({\n          line: index + 1,\n          current: analysis.stresses,\n          issue: `This line follows a ${lineType} pattern instead of ${target}`,\n          suggestion: `Try restructuring to match the ${target} rhythm (${this.getMeterPattern(\n            target\n          )})`,\n        });\n      }\n    });\n\n    return suggestions;\n  }\n\n  private getMeterPattern(type: MeterType): string {\n    const patterns: Record<MeterType, string> = {\n      iambic: 'da-DUM (0/1)',\n      trochaic: 'DUM-da (1/0)',\n      anapestic: 'da-da-DUM (0/0/1)',\n      dactylic: 'DUM-da-da (1/0/0)',\n      irregular: 'mixed or free verse',\n    };\n    return patterns[type];\n  }\n\n  private getMeterDescription(type: MeterType): string {\n    const descriptions: Record<MeterType, string> = {\n      iambic: 'Most common in English poetry. Sounds natural and flowing.',\n      trochaic: \"Strong, emphatic rhythm. Common in children's verse.\",\n      anapestic: 'Galloping, energetic rhythm. Creates sense of movement.',\n      dactylic: 'Falling rhythm. Rare in English, common in ancient Greek.',\n      irregular: 'No consistent metrical pattern. Free verse or mixed meters.',\n    };\n    return descriptions[type];\n  }\n\n  private getMeterExamples(type: MeterType): string[] {\n    const examples: Record<MeterType, string[]> = {\n      iambic: [\n        \"Shall I compare thee to a summer's day?\",\n        'The curfew tolls the knell of parting day',\n      ],\n      trochaic: ['Tell me not in mournful numbers', 'Tiger, tiger, burning bright'],\n      anapestic: ['Twas the night before Christmas', 'And the sound of a voice that is still'],\n      dactylic: ['This is the forest primeval', 'Cannon to right of them'],\n      irregular: ['Free verse has no set pattern', 'Modern poetry often breaks rules'],\n    };\n    return examples[type];\n  }\n\n  private getIrregularMeter(): MeterAnalysis {\n    return {\n      type: 'irregular',\n      consistency: 0,\n      pattern: 'mixed or free verse',\n      description:\n        'No consistent metrical pattern detected. This could be free verse or mixed meters.',\n      examples: [],\n    };\n  }\n}\n",
            "properties": [
                {
                    "name": "consistency",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "description",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 10
                },
                {
                    "name": "examples",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 11
                },
                {
                    "name": "pattern",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MeterType",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": [],
            "isDuplicate": true,
            "duplicateId": 1,
            "duplicateName": "MeterAnalysis-1"
        },
        {
            "name": "PivotItem",
            "id": "interface-PivotItem-abfe3bd76968416e3e585932504a29deab143cbe42168579def4858ffb8ad907f8caec6ed31cf18d91b80838fe19c44217aa33eeb57eab9e0dc27c36be543685",
            "file": "src/app/components/metro/pivot/pivot.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nexport interface PivotItem {\n  id: string;\n  label: string;\n  disabled?: boolean;\n}\n\n@Component({\n  selector: 'app-pivot',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './pivot.component.html',\n})\nexport class PivotComponent {\n  @Input() items: PivotItem[] = [];\n  @Input() selectedId = '';\n  @Output() selectedChange = new EventEmitter<string>();\n\n  select(id: string): void {\n    if (this.selectedId !== id) {\n      this.selectedId = id;\n      this.selectedChange.emit(id);\n    }\n  }\n}\n",
            "properties": [
                {
                    "name": "disabled",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "PoetryForm",
            "id": "interface-PoetryForm-9f2e5258c8513a233d7e44d78b9506fca3eaeaafe3f4b50c162e9e041de2e3840e9864cfac6cecc24684c7a1eef955a1eafc933f527dada08a89fe2e14324029",
            "file": "src/app/models/poetry.model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface PoetryForm {\n  id: string;\n  name: string;\n  pattern: number[];\n  lines: number;\n  origin: string;\n  description: string;\n}\n\nexport interface LineAnalysis {\n  text: string;\n  count: number;\n  expected: number;\n  match: boolean;\n  syllables: string[];\n  stresses?: string;\n}\n\nexport interface PoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: LineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n}\n\nexport interface MeterAnalysis {\n  pattern: string;\n  type: string;\n  consistency: number;\n}\n",
            "properties": [
                {
                    "name": "description",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 2
                },
                {
                    "name": "lines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 3
                },
                {
                    "name": "origin",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "pattern",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 4
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "PoetryFormTestData",
            "id": "interface-PoetryFormTestData-788d44a8adc3880b125d0b7200c681f4cfc9a04403eff45b143893e7b6242a7935488ac3939d7101ee9c38bd302474afef30d1cac0617c3832556b963553eb22",
            "file": "src/app/data/poetry-test.utils.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { POETRY_FORMS, POETRY_EXAMPLES } from './poetry-forms.data';\n\nexport interface PoetryFormTestData {\n  lines: number;\n  pattern: number[];\n}\n\nexport type MockPoetryData = Record<string, string[]>;\n\nexport const getPoetryFormTestData = (): Record<string, PoetryFormTestData> => {\n  return Object.entries(POETRY_FORMS).reduce((acc, [id, form]) => {\n    acc[id] = {\n      lines: form.lines,\n      pattern: form.pattern,\n    };\n    return acc;\n  }, {} as Record<string, PoetryFormTestData>);\n};\n\nexport const getMockPoetryData = (): MockPoetryData => {\n  const mockData: MockPoetryData = { ...POETRY_EXAMPLES };\n\n  mockData['haikuWithErrors'] = [\n    'A very old silent pond in the forest',\n    'A small green frog jumps',\n    'Big splash sound and then quiet',\n  ];\n\n  return mockData;\n};\n\nexport const getPoetryFormsForTests = () => {\n  return Object.values(POETRY_FORMS).map((form) => ({\n    id: form.id,\n    name: form.name,\n    pattern: form.pattern.join('-'),\n  }));\n};\n\nexport const TEST_EXAMPLES = {\n  HAIKU_WITH_ERRORS: [\n    'A very old silent pond in the forest',\n    'A small green frog jumps',\n    'Big splash sound and then quiet',\n  ] as string[],\n};\n",
            "properties": [
                {
                    "name": "lines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 4
                },
                {
                    "name": "pattern",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "PoetryResult",
            "id": "interface-PoetryResult-9f2e5258c8513a233d7e44d78b9506fca3eaeaafe3f4b50c162e9e041de2e3840e9864cfac6cecc24684c7a1eef955a1eafc933f527dada08a89fe2e14324029",
            "file": "src/app/models/poetry.model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface PoetryForm {\n  id: string;\n  name: string;\n  pattern: number[];\n  lines: number;\n  origin: string;\n  description: string;\n}\n\nexport interface LineAnalysis {\n  text: string;\n  count: number;\n  expected: number;\n  match: boolean;\n  syllables: string[];\n  stresses?: string;\n}\n\nexport interface PoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: LineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n}\n\nexport interface MeterAnalysis {\n  pattern: string;\n  type: string;\n  consistency: number;\n}\n",
            "properties": [
                {
                    "name": "form",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 21
                },
                {
                    "name": "lines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "LineAnalysis[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 26
                },
                {
                    "name": "ok",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 20
                },
                {
                    "name": "rhymeScheme",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 28
                },
                {
                    "name": "suggestions",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 29
                },
                {
                    "name": "summary",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 27
                },
                {
                    "name": "totalLines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "PoetryStructure",
            "id": "interface-PoetryStructure-87839deece079bc7847173139a67015b54b1d00fdeef757ab3e95c0a0bdf68b78cba002925ff807dfb5be309a363c259bd762ca785914d525a6a44d20747e0bd",
            "file": "src/app/services/poetry/poetry-analysis.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService } from './rita.service';\nimport { POETRY_FORMS } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface PoetryStructure {\n  lines: LineAnalysis[];\n  totalLines: { expected: number; actual: number };\n  ok: boolean;\n  summary: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  analyzePoemStructure(rawLines: string[], formKey: string): PoetryStructure {\n    const form = POETRY_FORMS[formKey];\n    if (!form) {\n      throw new Error(`Unknown form \"${formKey}\"`);\n    }\n\n    const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n    const lineAnalyses: LineAnalysis[] = lines.map((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      const expected = form.pattern[index] ?? 0;\n\n      return {\n        text: line,\n        count: analysis.syllables,\n        expected,\n        match: analysis.syllables === expected,\n        syllables: analysis.breakdown,\n        stresses: analysis.stresses,\n      };\n    });\n\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n    const mismatches = lineAnalyses.filter((l) => !l.match).length;\n    const summary = ok\n      ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n          '-'\n        )} pattern`\n      : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n    return {\n      lines: lineAnalyses,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      ok,\n      summary,\n    };\n  }\n\n  validateLineSyllables(\n    line: string,\n    expectedSyllables: number\n  ): { valid: boolean; actual: number } {\n    const analysis = this.rita.analyzeLine(line);\n    return {\n      valid: analysis.syllables === expectedSyllables,\n      actual: analysis.syllables,\n    };\n  }\n\n  calculateSyllableAccuracy(lines: string[], pattern: number[]): number {\n    if (lines.length !== pattern.length) return 0;\n\n    let matches = 0;\n    lines.forEach((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      if (analysis.syllables === pattern[index]) {\n        matches++;\n      }\n    });\n\n    return (matches / pattern.length) * 100;\n  }\n\n  detectMeterPattern(lines: string[]): string[] {\n    const patterns: string[] = [];\n    const stressPatterns = lines\n      .map((line) => {\n        const analysis = this.rita.analyzeLine(line);\n        return analysis.stresses;\n      })\n      .filter((s) => s && s.length > 0);\n\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent meter: ${firstPattern}`);\n      }\n    }\n\n    return patterns;\n  }\n}\n",
            "properties": [
                {
                    "name": "lines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "LineAnalysis[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "ok",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "summary",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 10
                },
                {
                    "name": "totalLines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "QualityMetrics",
            "id": "interface-QualityMetrics-7ce486a65750df1898e54ad355d397e9260f98fe45ae68caa60242e267f5634701e7c08a6a7f0953319376c9e4cf54f03e3ba75dc7c2cb9a7365b440b75ed93d",
            "file": "src/app/services/poetry/poem-quality.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { RitaService } from './rita.service';\nimport type { EnhancedPoetryResult } from './poetry-analyzer.service';\n\nexport interface QualityMetrics {\n  score: number;\n  breakdown: {\n    syllableAccuracy: number;\n    phoneticsRichness: number;\n    vocabularyDiversity: number;\n    rhythmConsistency: number;\n    rhetoricalDevices: number;\n  };\n  strengths: string[];\n  improvements: string[];\n  grade: 'A+' | 'A' | 'B+' | 'B' | 'C+' | 'C' | 'D' | 'F';\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoemQualityService {\n  private readonly rita = inject(RitaService);\n\n  assessQuality(lines: string[], pattern: number[], result: EnhancedPoetryResult): QualityMetrics {\n    const metrics = {\n      syllableAccuracy: this.calculateSyllableAccuracy(result, pattern),\n      phoneticsRichness: this.calculatePhoneticRichness(lines),\n      vocabularyDiversity: this.calculateVocabularyDiversity(lines),\n      rhythmConsistency: this.calculateRhythmConsistency(result),\n      rhetoricalDevices: this.calculateRhetoricalDevices(result),\n    };\n\n    const score = this.computeOverallScore(metrics);\n    const grade = this.assignGrade(score);\n    const strengths = this.identifyStrengths(metrics);\n    const improvements = this.suggestImprovements(metrics);\n\n    return {\n      score,\n      breakdown: metrics,\n      strengths,\n      improvements,\n      grade,\n    };\n  }\n\n  private calculateSyllableAccuracy(result: EnhancedPoetryResult, pattern: number[]): number {\n    if (result.lines.length !== pattern.length) return 0;\n\n    const matches = result.lines.filter((line) => line.match).length;\n    return (matches / pattern.length) * 100;\n  }\n\n  private calculatePhoneticRichness(lines: string[]): number {\n    const text = lines.join(' ');\n    const words = RiTa.tokens(text);\n\n    if (words.length === 0) return 0;\n\n    const uniquePhonemes = new Set<string>();\n    words.forEach((word) => {\n      const phones = RiTa.phones(word);\n      if (phones) {\n        phones.split('-').forEach((p) => uniquePhonemes.add(p));\n      }\n    });\n\n    return Math.min(100, (uniquePhonemes.size / 15) * 100);\n  }\n\n  private calculateVocabularyDiversity(lines: string[]): number {\n    const text = lines.join(' ');\n    const tokens = RiTa.tokenize(text);\n    const words = tokens.filter((t) => !RiTa.isPunct(t));\n\n    if (words.length === 0) return 0;\n\n    const unique = new Set(words.map((w) => w.toLowerCase()));\n    const ttr = unique.size / words.length;\n\n    return Math.min(100, (ttr / 0.6) * 100);\n  }\n\n  private calculateRhythmConsistency(result: EnhancedPoetryResult): number {\n    const stressPatterns = result.lines\n      .map((l) => l.stresses)\n      .filter((s): s is string => s !== undefined && s.length > 0);\n\n    if (stressPatterns.length < 2) return 50;\n\n    const firstPattern = stressPatterns[0];\n    const similarCount = stressPatterns.filter(\n      (p) => this.stressSimilarity(firstPattern, p) > 0.6\n    ).length;\n\n    return (similarCount / stressPatterns.length) * 100;\n  }\n\n  private calculateRhetoricalDevices(result: EnhancedPoetryResult): number {\n    let score = 0;\n\n    if (result.overallAlliterations.length > 0) {\n      score += Math.min(20, result.overallAlliterations.length * 5);\n    }\n\n    if (result.rhymeScheme && result.rhymeScheme !== 'A'.repeat(result.lines.length)) {\n      score += 30;\n    }\n\n    const concordance = RiTa.concordance(result.lines.map((l) => l.text).join(' '));\n    const repeatedWords = Object.values(concordance).filter((count) => count > 1).length;\n    if (repeatedWords > 0) {\n      score += Math.min(20, repeatedWords * 4);\n    }\n\n    const allWords = result.lines.flatMap((l) => l.words);\n    const uniquePOS = new Set(allWords.map((w) => w.pos));\n    if (uniquePOS.size >= 4) {\n      score += 15;\n    }\n\n    const sensoryWords = this.countSensoryWords(allWords.map((w) => w.word));\n    if (sensoryWords >= 3) {\n      score += 15;\n    }\n\n    return Math.min(100, score);\n  }\n\n  private computeOverallScore(metrics: QualityMetrics['breakdown']): number {\n    const weights = {\n      syllableAccuracy: 0.35,\n      phoneticsRichness: 0.15,\n      vocabularyDiversity: 0.2,\n      rhythmConsistency: 0.15,\n      rhetoricalDevices: 0.15,\n    };\n\n    return Object.entries(weights).reduce((total, [key, weight]) => {\n      return total + metrics[key as keyof typeof metrics] * weight;\n    }, 0);\n  }\n\n  private assignGrade(score: number): QualityMetrics['grade'] {\n    if (score >= 95) return 'A+';\n    if (score >= 90) return 'A';\n    if (score >= 85) return 'B+';\n    if (score >= 80) return 'B';\n    if (score >= 75) return 'C+';\n    if (score >= 70) return 'C';\n    if (score >= 60) return 'D';\n    return 'F';\n  }\n\n  private identifyStrengths(metrics: QualityMetrics['breakdown']): string[] {\n    const strengths: string[] = [];\n\n    if (metrics.syllableAccuracy === 100) {\n      strengths.push('Perfect syllable matching');\n    } else if (metrics.syllableAccuracy >= 80) {\n      strengths.push('Good syllable accuracy');\n    }\n\n    if (metrics.phoneticsRichness > 80) {\n      strengths.push('Rich phonetic variety');\n    }\n\n    if (metrics.vocabularyDiversity > 75) {\n      strengths.push('Diverse vocabulary');\n    }\n\n    if (metrics.rhythmConsistency > 80) {\n      strengths.push('Consistent rhythm');\n    }\n\n    if (metrics.rhetoricalDevices > 70) {\n      strengths.push('Strong use of literary devices');\n    }\n\n    return strengths.length > 0 ? strengths : ['Good foundation - keep practicing!'];\n  }\n\n  private suggestImprovements(metrics: QualityMetrics['breakdown']): string[] {\n    const improvements: string[] = [];\n\n    if (metrics.syllableAccuracy < 100) {\n      improvements.push('Adjust syllable counts to match the pattern');\n    }\n\n    if (metrics.phoneticsRichness < 60) {\n      improvements.push('Use more varied sounds and phonemes');\n    }\n\n    if (metrics.vocabularyDiversity < 50) {\n      improvements.push('Avoid repeating the same words');\n    }\n\n    if (metrics.rhythmConsistency < 60) {\n      improvements.push('Create more consistent stress patterns');\n    }\n\n    if (metrics.rhetoricalDevices < 50) {\n      improvements.push('Add alliteration, rhyme, or other literary devices');\n    }\n\n    return improvements.length > 0\n      ? improvements\n      : ['Excellent work! Consider experimenting with more complex forms.'];\n  }\n\n  private stressSimilarity(pattern1: string, pattern2: string): number {\n    const arr1 = pattern1.split('/');\n    const arr2 = pattern2.split('/');\n    const maxLen = Math.max(arr1.length, arr2.length);\n\n    let matches = 0;\n    for (let i = 0; i < maxLen; i++) {\n      if (arr1[i] === arr2[i]) matches++;\n    }\n\n    return matches / maxLen;\n  }\n\n  private countSensoryWords(words: string[]): number {\n    const sensoryPatterns = [\n      /bright|dark|color|hue|shade/i,\n      /loud|quiet|sound|music|voice|echo/i,\n      /soft|hard|smooth|rough|warm|cold/i,\n      /sweet|bitter|fragrant|scent|smell/i,\n      /taste|flavor|savory|delicious/i,\n    ];\n\n    return words.filter((word) => sensoryPatterns.some((pattern) => pattern.test(word))).length;\n  }\n}\n",
            "properties": [
                {
                    "name": "breakdown",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "grade",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"A+\" | \"A\" | \"B+\" | \"B\" | \"C+\" | \"C\" | \"D\" | \"F\"",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "improvements",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "score",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "strengths",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "QuickStats",
            "id": "interface-QuickStats-3f49d7f8281c5927dfb1d212c11ba1d8a512667d01e0a77670a5f5e4d23d74709367137484311992e8105bfe5030b3147ac178d701edea0396acf24cd86cab32",
            "file": "src/app/components/poetry/quick-stats-panel/quick-stats-panel.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CardComponent } from '../../ui';\n\nexport interface QuickStats {\n  totalSyllables: number;\n  avgSyllablesPerLine: number;\n  vocabularyRichness: number;\n  patternMatch: string;\n}\n\n@Component({\n  selector: 'app-quick-stats-panel',\n  standalone: true,\n  imports: [CardComponent],\n  templateUrl: './quick-stats-panel.component.html',\n})\nexport class QuickStatsPanelComponent {\n  @Input({ required: true }) stats!: QuickStats;\n}\n",
            "properties": [
                {
                    "name": "avgSyllablesPerLine",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "patternMatch",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "totalSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "vocabularyRichness",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "RhymeMatch",
            "id": "interface-RhymeMatch-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "nearRhymes",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 43
                },
                {
                    "name": "perfectRhymes",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 42
                },
                {
                    "name": "rhymesWith",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 41
                },
                {
                    "name": "word",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 40
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "RhythmSuggestion",
            "id": "interface-RhythmSuggestion-c8ff5e422e8554e34650a202a0a41732300cf56a1ad0853b3fc676499f4c2ce0c687dd9ecb78f3df657e4274fec3fdc34b0adea4b92825d6d4813ddbc9d71d07",
            "file": "src/app/services/poetry/meter-analysis.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService } from './rita.service';\n\nexport type MeterType = 'iambic' | 'trochaic' | 'anapestic' | 'dactylic' | 'irregular';\n\nexport interface MeterAnalysis {\n  type: MeterType;\n  consistency: number;\n  pattern: string;\n  description: string;\n  examples: string[];\n}\n\nexport interface RhythmSuggestion {\n  line: number;\n  current: string;\n  issue: string;\n  suggestion: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class MeterAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  detectMeter(lines: string[]): MeterAnalysis {\n    const stressPatterns = lines\n      .map((line) => this.rita.analyzeLine(line).stresses)\n      .filter((s) => s && s.length > 0);\n\n    if (stressPatterns.length === 0) {\n      return this.getIrregularMeter();\n    }\n\n    const meterCounts = {\n      iambic: 0,\n      trochaic: 0,\n      anapestic: 0,\n      dactylic: 0,\n    };\n\n    stressPatterns.forEach((pattern) => {\n      const stresses = pattern.split('/').map((s) => parseInt(s));\n      const type = this.classifyStressPattern(stresses);\n      if (type !== 'irregular') {\n        meterCounts[type]++;\n      }\n    });\n\n    const total = stressPatterns.length;\n    const dominant = Object.entries(meterCounts).sort(([, a], [, b]) => b - a)[0];\n\n    if (!dominant) {\n      return this.getIrregularMeter();\n    }\n\n    const [type, count] = dominant as [MeterType, number];\n    const consistency = (count / total) * 100;\n\n    if (consistency < 40) {\n      return this.getIrregularMeter();\n    }\n\n    return {\n      type,\n      consistency,\n      pattern: this.getMeterPattern(type),\n      description: this.getMeterDescription(type),\n      examples: this.getMeterExamples(type),\n    };\n  }\n\n  private classifyStressPattern(stresses: number[]): MeterType | 'irregular' {\n    if (stresses.length < 2) return 'irregular';\n\n    const pairs: string[] = [];\n    for (let i = 0; i < stresses.length - 1; i++) {\n      pairs.push(`${stresses[i]}${stresses[i + 1]}`);\n    }\n\n    const pairCounts = {\n      '01': 0,\n      '10': 0,\n      '001': 0,\n      '100': 0,\n    };\n\n    pairs.forEach((pair) => {\n      if (pair === '01') pairCounts['01']++;\n      if (pair === '10') pairCounts['10']++;\n    });\n\n    for (let i = 0; i < stresses.length - 2; i++) {\n      const triplet = `${stresses[i]}${stresses[i + 1]}${stresses[i + 2]}`;\n      if (triplet === '001') pairCounts['001']++;\n      if (triplet === '100') pairCounts['100']++;\n    }\n\n    const max = Math.max(...Object.values(pairCounts));\n    if (max === 0) return 'irregular';\n\n    if (pairCounts['01'] === max) return 'iambic';\n    if (pairCounts['10'] === max) return 'trochaic';\n    if (pairCounts['001'] === max) return 'anapestic';\n    if (pairCounts['100'] === max) return 'dactylic';\n\n    return 'irregular';\n  }\n\n  generateRhythmSuggestions(lines: string[], targetMeter?: MeterType): RhythmSuggestion[] {\n    const suggestions: RhythmSuggestion[] = [];\n    const detectedMeter = this.detectMeter(lines);\n    const target = targetMeter || detectedMeter.type;\n\n    if (target === 'irregular') {\n      return suggestions;\n    }\n\n    lines.forEach((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      if (!analysis.stresses) return;\n\n      const stresses = analysis.stresses.split('/').map((s) => parseInt(s));\n      const lineType = this.classifyStressPattern(stresses);\n\n      if (lineType !== target) {\n        suggestions.push({\n          line: index + 1,\n          current: analysis.stresses,\n          issue: `This line follows a ${lineType} pattern instead of ${target}`,\n          suggestion: `Try restructuring to match the ${target} rhythm (${this.getMeterPattern(\n            target\n          )})`,\n        });\n      }\n    });\n\n    return suggestions;\n  }\n\n  private getMeterPattern(type: MeterType): string {\n    const patterns: Record<MeterType, string> = {\n      iambic: 'da-DUM (0/1)',\n      trochaic: 'DUM-da (1/0)',\n      anapestic: 'da-da-DUM (0/0/1)',\n      dactylic: 'DUM-da-da (1/0/0)',\n      irregular: 'mixed or free verse',\n    };\n    return patterns[type];\n  }\n\n  private getMeterDescription(type: MeterType): string {\n    const descriptions: Record<MeterType, string> = {\n      iambic: 'Most common in English poetry. Sounds natural and flowing.',\n      trochaic: \"Strong, emphatic rhythm. Common in children's verse.\",\n      anapestic: 'Galloping, energetic rhythm. Creates sense of movement.',\n      dactylic: 'Falling rhythm. Rare in English, common in ancient Greek.',\n      irregular: 'No consistent metrical pattern. Free verse or mixed meters.',\n    };\n    return descriptions[type];\n  }\n\n  private getMeterExamples(type: MeterType): string[] {\n    const examples: Record<MeterType, string[]> = {\n      iambic: [\n        \"Shall I compare thee to a summer's day?\",\n        'The curfew tolls the knell of parting day',\n      ],\n      trochaic: ['Tell me not in mournful numbers', 'Tiger, tiger, burning bright'],\n      anapestic: ['Twas the night before Christmas', 'And the sound of a voice that is still'],\n      dactylic: ['This is the forest primeval', 'Cannon to right of them'],\n      irregular: ['Free verse has no set pattern', 'Modern poetry often breaks rules'],\n    };\n    return examples[type];\n  }\n\n  private getIrregularMeter(): MeterAnalysis {\n    return {\n      type: 'irregular',\n      consistency: 0,\n      pattern: 'mixed or free verse',\n      description:\n        'No consistent metrical pattern detected. This could be free verse or mixed meters.',\n      examples: [],\n    };\n  }\n}\n",
            "properties": [
                {
                    "name": "current",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "issue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "line",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15
                },
                {
                    "name": "suggestion",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 18
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "ScreenshotCaptureOptions",
            "id": "interface-ScreenshotCaptureOptions-04e6fde45fa39098bfe44a724002245a76b692f340f1d8bbc1c474f346fe5d2df0c8154e888ace1f7772308e6ddcd96c950a5292bbeedadac08d48b03ebb2903",
            "file": "src/lib/capture/screenshot-capture.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { existsSync, mkdirSync, writeFileSync, statSync } from 'fs';\nimport { join } from 'path';\nimport type { CaptureOptions, CaptureResult } from './types';\nimport { BrowserManager } from './browser-utils';\nimport { Browser, BrowserContext, Page } from 'playwright';\nimport { SHARED_CONFIG } from '../../../playwright.config';\nimport { SELECTORS, TestHelpers } from '../../e2e/selectors';\n\ninterface ScreenshotCaptureOptions extends CaptureOptions {\n  multiple?: boolean;\n  browserType?: 'brave' | 'chrome' | 'firefox';\n  screenshotType?: 'png' | 'jpeg';\n  quality?: number;\n  fullPage?: boolean;\n  captureInteractions?: boolean;\n}\n\nexport class ScreenshotCapture {\n  private options: Required<ScreenshotCaptureOptions>;\n\n  constructor(options: ScreenshotCaptureOptions = {}) {\n    this.options = {\n      url: options.url || SHARED_CONFIG.baseURL,\n      outputDir: options.outputDir || 'angular-captures/screenshots',\n      viewport: options.viewport || { width: 1200, height: 800 },\n      delay: options.delay || 2000,\n      format: options.format || 'mp4',\n      multiple: options.multiple || false,\n      browserType: options.browserType || 'brave',\n      mode: options.mode || 'detailed',\n      duration: options.duration || 0,\n      screenshotType: options.screenshotType || 'png',\n      quality: options.quality || 80,\n      fullPage: options.fullPage ?? true,\n      captureInteractions: options.captureInteractions ?? true,\n    };\n  }\n\n  async capture(): Promise<CaptureResult> {\n    const startTime = Date.now();\n    const outputDir = this.options.outputDir;\n\n    if (!existsSync(outputDir)) {\n      mkdirSync(outputDir, { recursive: true });\n    }\n\n    console.log('📸 Starting screenshot capture...');\n    console.log(`🌐 URL: ${this.options.url}`);\n    console.log(`🌐 Browser: ${this.options.browserType}`);\n    console.log(`🖼️ Type: ${this.options.screenshotType.toUpperCase()}`);\n    console.log(`📁 Output: ${outputDir}`);\n\n    let browser: Browser | undefined;\n    let context: BrowserContext | undefined;\n    let page: Page | undefined;\n\n    try {\n      const browserSetup = await BrowserManager.launchBrowser({\n        headless: false,\n        viewport: this.options.viewport,\n        recordVideo: false,\n        browserType: this.options.browserType,\n      });\n\n      browser = browserSetup.browser;\n      context = browserSetup.context;\n      page = browserSetup.page;\n\n      const navigationSuccess = await BrowserManager.safeNavigate(page, this.options.url);\n      if (!navigationSuccess) {\n        throw new Error('Failed to navigate to application');\n      }\n\n      await BrowserManager.waitForAppReady(page);\n      await BrowserManager.wait(this.options.delay);\n\n      const screenshotResults: { name: string; path: string }[] = [];\n\n      if (this.options.multiple) {\n        await this.captureMultipleSections(page, outputDir, screenshotResults);\n      } else {\n        await this.captureFullPage(page, outputDir, screenshotResults);\n      }\n\n      if (this.options.captureInteractions) {\n        await this.captureInteractionStates(page, outputDir, screenshotResults);\n      }\n\n      await this.generateReport(screenshotResults, outputDir);\n      await BrowserManager.cleanup(browser, context);\n\n      const duration = Date.now() - startTime;\n\n      console.log('✅ Screenshot capture completed');\n      console.log(`📊 Total screenshots: ${screenshotResults.length}`);\n      console.log(`⏱️ Duration: ${duration}ms`);\n\n      return {\n        success: true,\n        outputPath: outputDir,\n        duration,\n        timestamp: new Date().toISOString(),\n        url: this.options.url,\n        mode: this.options.mode,\n        sections: screenshotResults,\n      };\n    } catch (error) {\n      await BrowserManager.cleanup(browser, context);\n      console.error('❌ Error during screenshot capture:', error);\n\n      return {\n        success: false,\n        outputPath: '',\n        duration: Date.now() - startTime,\n        timestamp: new Date().toISOString(),\n        url: this.options.url,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  private async captureMultipleSections(\n    page: Page,\n    outputDir: string,\n    results: { name: string; path: string }[]\n  ): Promise<void> {\n    const sections = [\n      { name: 'fullpage', selector: 'body', fullPage: true },\n      { name: 'header', selector: 'app-header', fullPage: false },\n      { name: 'editor', selector: SELECTORS.EDITOR.CONTAINER, fullPage: false },\n      { name: 'results', selector: SELECTORS.RESULTS.CONTAINER, fullPage: false },\n      { name: 'analysis-tabs', selector: '.metro-pivot', fullPage: false },\n      { name: 'analysis-tabs-alt', selector: '[role=\"tablist\"]', fullPage: false },\n      { name: 'quick-nav', selector: '.quick-nav-buttons', fullPage: false },\n      { name: 'footer', selector: 'app-footer', fullPage: false },\n    ];\n\n    for (const section of sections) {\n      try {\n        const timestamp = Date.now();\n        const screenshotPath = join(\n          outputDir,\n          `${section.name}-${timestamp}.${this.options.screenshotType}`\n        );\n\n        if (section.fullPage) {\n          await page.screenshot({\n            path: screenshotPath,\n            fullPage: true,\n            type: this.options.screenshotType as 'png' | 'jpeg',\n            ...(this.options.screenshotType === 'jpeg' && { quality: this.options.quality }),\n          });\n        } else {\n          const element = page.locator(section.selector);\n          if (await element.isVisible({ timeout: 2000 })) {\n            await element.screenshot({\n              path: screenshotPath,\n              type: this.options.screenshotType as 'png' | 'jpeg',\n              ...(this.options.screenshotType === 'jpeg' && { quality: this.options.quality }),\n            });\n          } else {\n            console.log(`⚠️ Element not visible: ${section.selector}`);\n            continue;\n          }\n        }\n\n        results.push({\n          name: section.name,\n          path: screenshotPath,\n        });\n        console.log(`✅ ${section.name} captured: ${screenshotPath}`);\n\n        await BrowserManager.wait(500);\n      } catch (error) {\n        console.log(\n          `⚠️ Could not capture ${section.name}:`,\n          error instanceof Error ? error.message : 'Unknown error'\n        );\n      }\n    }\n  }\n\n  /**\n   * ⚡ REFACTORIZADO: Usa TestHelpers y SELECTORS\n   */\n  private async captureInteractionStates(\n    page: Page,\n    outputDir: string,\n    results: { name: string; path: string }[]\n  ): Promise<void> {\n    console.log('🔄 Capturing interaction states...');\n\n    try {\n      const formSelect = page.locator(SELECTORS.FORM_SELECTOR);\n\n      if (await formSelect.isVisible({ timeout: 2000 })) {\n        const forms = [\n          SELECTORS.FORM_OPTIONS.TANKA,\n          SELECTORS.FORM_OPTIONS.LIMERICK,\n          SELECTORS.FORM_OPTIONS.CINQUAIN,\n        ];\n\n        for (const form of forms) {\n          await TestHelpers.selectPoetryForm(page, form);\n          await BrowserManager.wait(1500);\n\n          const screenshotPath = join(\n            outputDir,\n            `form-${form}-${Date.now()}.${this.options.screenshotType}`\n          );\n\n          await page.screenshot({\n            path: screenshotPath,\n            fullPage: this.options.fullPage,\n            type: this.options.screenshotType as 'png' | 'jpeg',\n            ...(this.options.screenshotType === 'jpeg' && { quality: this.options.quality }),\n          });\n\n          results.push({ name: `form-${form}`, path: screenshotPath });\n          console.log(`✅ Form ${form} captured`);\n        }\n\n        await TestHelpers.selectPoetryForm(page, SELECTORS.FORM_OPTIONS.HAIKU);\n        await BrowserManager.wait(1000);\n      }\n\n      await TestHelpers.loadExample(page);\n      await BrowserManager.wait(3000);\n\n      const examplePath = join(\n        outputDir,\n        `with-example-${Date.now()}.${this.options.screenshotType}`\n      );\n\n      await page.screenshot({\n        path: examplePath,\n        fullPage: this.options.fullPage,\n        type: this.options.screenshotType as 'png' | 'jpeg',\n        ...(this.options.screenshotType === 'jpeg' && { quality: this.options.quality }),\n      });\n\n      results.push({ name: 'with-example', path: examplePath });\n      console.log('✅ Example loaded state captured');\n\n      const analyzeButton = page.locator(SELECTORS.BUTTONS.ANALYZE).first();\n      if ((await analyzeButton.isVisible({ timeout: 2000 })) && (await analyzeButton.isEnabled())) {\n        await analyzeButton.click();\n        console.log('🔍 Analysis started, waiting for results...');\n        await BrowserManager.wait(6000);\n\n        const resultsVisible = await page\n          .locator(SELECTORS.RESULTS.CONTAINER)\n          .isVisible({ timeout: 3000 })\n          .catch(() => false);\n\n        if (resultsVisible) {\n          console.log('✅ Results are visible');\n\n          const resultsPath = join(\n            outputDir,\n            `with-results-${Date.now()}.${this.options.screenshotType}`\n          );\n\n          await page.screenshot({\n            path: resultsPath,\n            fullPage: this.options.fullPage,\n            type: this.options.screenshotType as 'png' | 'jpeg',\n            ...(this.options.screenshotType === 'jpeg' && { quality: this.options.quality }),\n          });\n\n          results.push({ name: 'with-results', path: resultsPath });\n          console.log('✅ Results captured');\n\n          const analysisTabs = ['structure', 'rhythm', 'quality', 'stats'];\n          for (const tab of analysisTabs) {\n            try {\n              const tabButton = page.locator(`.metro-pivot-item:has-text(\"${tab}\")`);\n              if (await tabButton.isVisible({ timeout: 2000 })) {\n                await tabButton.click();\n                await BrowserManager.wait(1500);\n\n                const tabPath = join(\n                  outputDir,\n                  `tab-${tab}-${Date.now()}.${this.options.screenshotType}`\n                );\n\n                await page.screenshot({\n                  path: tabPath,\n                  fullPage: this.options.fullPage,\n                  type: this.options.screenshotType as 'png' | 'jpeg',\n                  ...(this.options.screenshotType === 'jpeg' && { quality: this.options.quality }),\n                });\n\n                results.push({ name: `tab-${tab}`, path: tabPath });\n                console.log(`✅ Tab ${tab} captured`);\n              }\n            } catch (error) {\n              console.log(`⚠️ Could not capture tab ${tab}`, error);\n            }\n          }\n        } else {\n          console.log('⚠️ Results not visible after analysis');\n        }\n      }\n    } catch (error) {\n      console.log(\n        '⚠️ Some interaction captures failed:',\n        error instanceof Error ? error.message : error\n      );\n    }\n  }\n\n  private async captureFullPage(\n    page: Page,\n    outputDir: string,\n    results: { name: string; path: string }[]\n  ): Promise<void> {\n    const timestamp = Date.now();\n    const fullPagePath = join(outputDir, `fullpage-${timestamp}.${this.options.screenshotType}`);\n\n    await page.screenshot({\n      path: fullPagePath,\n      fullPage: this.options.fullPage,\n      type: this.options.screenshotType as 'png' | 'jpeg',\n      ...(this.options.screenshotType === 'jpeg' && { quality: this.options.quality }),\n    });\n\n    results.push({\n      name: 'fullpage',\n      path: fullPagePath,\n    });\n  }\n\n  private async generateReport(\n    screenshots: { name: string; path: string }[],\n    outputDir: string\n  ): Promise<void> {\n    const report = {\n      generatedAt: new Date().toISOString(),\n      totalScreenshots: screenshots.length,\n      viewport: this.options.viewport,\n      settings: {\n        screenshotType: this.options.screenshotType,\n        quality: this.options.quality,\n        fullPage: this.options.fullPage,\n        multiple: this.options.multiple,\n        browserType: this.options.browserType,\n      },\n      screenshots: screenshots.map((s) => ({\n        name: s.name,\n        path: s.path,\n        filename: s.path.split('/').pop(),\n        size: this.getFileSize(s.path),\n      })),\n    };\n\n    const reportPath = join(outputDir, 'screenshots-report.json');\n    writeFileSync(reportPath, JSON.stringify(report, null, 2));\n    console.log(`📊 Report generated: ${reportPath}`);\n  }\n\n  private getFileSize(filePath: string): string {\n    try {\n      const stats = statSync(filePath);\n      const sizeInKB = Math.round(stats.size / 1024);\n      return `${sizeInKB} KB`;\n    } catch {\n      return 'Unknown';\n    }\n  }\n\n  static async quickScreenshot(\n    url: string = SHARED_CONFIG.baseURL,\n    options: Partial<ScreenshotCaptureOptions> = {}\n  ): Promise<CaptureResult> {\n    const capture = new ScreenshotCapture({\n      url,\n      ...options,\n      browserType: 'brave',\n    });\n    return await capture.capture();\n  }\n\n  static async captureApplicationOverview(): Promise<CaptureResult> {\n    return await this.quickScreenshot(SHARED_CONFIG.baseURL, {\n      multiple: true,\n      captureInteractions: true,\n      mode: 'overview',\n    });\n  }\n}\n\nexport async function captureScreenshots(\n  options?: ScreenshotCaptureOptions\n): Promise<CaptureResult> {\n  const capture = new ScreenshotCapture(options);\n  return await capture.capture();\n}\n",
            "properties": [
                {
                    "name": "browserType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"brave\" | \"chrome\" | \"firefox\"",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 11
                },
                {
                    "name": "captureInteractions",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 15
                },
                {
                    "name": "fullPage",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 14
                },
                {
                    "name": "multiple",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 10
                },
                {
                    "name": "quality",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 13
                },
                {
                    "name": "screenshotType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"png\" | \"jpeg\"",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 12
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": [
                "CaptureOptions"
            ]
        },
        {
            "name": "SelectOption",
            "id": "interface-SelectOption-7edb87c8685ce9aa66b6c7c1b88f364f847e0878595029b3d42eac185c907c102a5ebd68f11888b4aed97a9b049cba0df0a3d2db7a44dc5c164fbcd8bfefab85",
            "file": "src/app/components/ui/select/select.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {\n  Component,\n  Input,\n  Output,\n  EventEmitter,\n  forwardRef,\n  inject,\n  effect,\n  ChangeDetectorRef,\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { StateService } from '../../../services/';\n\nexport interface SelectOption {\n  value: string;\n  label: string;\n  description?: string;\n}\n\n@Component({\n  selector: 'app-select',\n  standalone: true,\n  templateUrl: './select.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => SelectComponent),\n      multi: true,\n    },\n  ],\n})\nexport class SelectComponent implements ControlValueAccessor {\n  private readonly stateService = inject(StateService);\n  private readonly cdr = inject(ChangeDetectorRef);\n\n  @Input() options: SelectOption[] = [];\n  @Input() label = '';\n  @Input() disabled = false;\n  @Input() id = '';\n\n  @Input()\n  get value(): string {\n    return this._value;\n  }\n  set value(val: string) {\n    if (this._value !== val) {\n      this._value = val || '';\n      this.onChange(this._value);\n      this.cdr.markForCheck();\n    }\n  }\n\n  _value = '';\n\n  @Output() selectChange = new EventEmitter<string>();\n\n  private onChange: (value: string) => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private onTouched: () => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private isInternalUpdate = false;\n\n  constructor() {\n    if (this.id === 'poetry-form-selector') {\n      effect(() => {\n        const selectedForm = this.stateService.selectedForm();\n\n        if (this._value !== selectedForm && !this.isInternalUpdate) {\n          this._value = selectedForm;\n          this.cdr.detectChanges();\n        }\n      });\n    }\n  }\n\n  writeValue(value: string): void {\n    if (!this.isInternalUpdate) {\n      this._value = value || '';\n      this.cdr.markForCheck();\n    }\n  }\n\n  registerOnChange(fn: (value: string) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n    this.cdr.markForCheck();\n  }\n\n  onSelectChange(event: Event): void {\n    const target = event.target as HTMLSelectElement;\n    const newValue = target.value;\n\n    if (this._value === newValue) {\n      return;\n    }\n\n    this.isInternalUpdate = true;\n    this._value = newValue;\n    this.onChange(this._value);\n    this.selectChange.emit(this._value);\n\n    if (this.id === 'poetry-form-selector') {\n      this.stateService.setSelectedForm(this._value);\n    }\n\n    setTimeout(() => {\n      this.isInternalUpdate = false;\n    }, 0);\n  }\n\n  onBlur(): void {\n    this.onTouched();\n  }\n}\n",
            "properties": [
                {
                    "name": "description",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "SuggestionContext",
            "id": "interface-SuggestionContext-24eb12fada130bc88b863f4d93cc015155ad8963e6b439cd89626c34ffadb8c508817746d6d4f5f7e11b910ca3bb30339b231a1a9016833254b2677222c8462e",
            "file": "src/app/services/poetry/poetry-suggestions.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService, type AlternativeWord } from './rita.service';\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\nexport interface SuggestionContext {\n  pos?: string;\n  lineIndex?: number;\n  isLineEnd?: boolean;\n  previousWord?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetrySuggestionsService {\n  private readonly rita = inject(RitaService);\n\n  async getWordAlternativesEnhanced(\n    word: string,\n    targetSyllables: number,\n    context: SuggestionContext = {}\n  ): Promise<WordSuggestionData> {\n    const currentSyllables = this.rita.analyzeLine(word).syllables;\n\n    // Búsqueda simple y efectiva - CORREGIR parámetros\n    const [exactMatches, rhymes, phonetic] = await Promise.all([\n      this.searchBySyllables(targetSyllables), // ❌ Eliminar context.pos\n      context.isLineEnd\n        ? this.rita.findRhymes(word, targetSyllables).then((r) => r.perfectRhymes)\n        : Promise.resolve([]),\n      this.rita.suggestAlternatives(word, targetSyllables, 6),\n    ]);\n\n    const allAlternatives = [\n      ...exactMatches,\n      ...rhymes.map((w) => ({\n        word: w, // ✅ w es string, no AlternativeWord\n        syllables: targetSyllables,\n        reason: 'rhyme-match' as const,\n        pos: this.rita.analyzeGrammar(w).pos,\n      })),\n      ...phonetic,\n    ];\n\n    const unique = this.deduplicateAndRank(allAlternatives, word, context);\n\n    return {\n      original: word,\n      currentSyllables,\n      targetSyllables,\n      alternatives: unique.slice(0, 10),\n    };\n  }\n\n  private async searchBySyllables(syllables: number): Promise<AlternativeWord[]> {\n    // ❌ Eliminar pos parameter\n    try {\n      // Búsqueda simple por primera letra y sílabas\n      const results = await this.rita.suggestAlternatives('a', syllables, 8);\n\n      // CORREGIR: results ya son AlternativeWord[], no strings\n      return results.map((altWord) => ({\n        // ✅ altWord es AlternativeWord\n        ...altWord,\n        reason: 'exact-match' as const,\n      }));\n    } catch (error) {\n      console.warn('Search by syllables failed:', error);\n      return [];\n    }\n  }\n\n  private deduplicateAndRank(\n    alternatives: AlternativeWord[],\n    originalWord: string,\n    context: SuggestionContext\n  ): AlternativeWord[] {\n    const seen = new Set<string>();\n    const unique = alternatives.filter((alt) => {\n      const key = alt.word.toLowerCase();\n      if (seen.has(key) || key === originalWord.toLowerCase()) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n\n    return unique.sort((a, b) => {\n      if (a.reason === 'exact-match' && b.reason !== 'exact-match') return -1;\n      if (b.reason === 'exact-match' && a.reason !== 'exact-match') return 1;\n\n      if (context.isLineEnd) {\n        if (a.reason === 'rhyme-match' && b.reason !== 'rhyme-match') return -1;\n        if (b.reason === 'rhyme-match' && a.reason !== 'rhyme-match') return 1;\n      }\n\n      if (context.pos) {\n        const aMatchesPOS = a.pos === context.pos;\n        const bMatchesPOS = b.pos === context.pos;\n        if (aMatchesPOS && !bMatchesPOS) return -1;\n        if (bMatchesPOS && !aMatchesPOS) return 1;\n      }\n\n      return 0;\n    });\n  }\n\n  async getWordAlternatives(word: string, targetSyllables: number): Promise<WordSuggestionData> {\n    return this.getWordAlternativesEnhanced(word, targetSyllables);\n  }\n\n  generateLineSuggestions(line: string, targetSyllables: number): string[] {\n    return this.rita.generateSuggestions(line, targetSyllables);\n  }\n}\n",
            "properties": [
                {
                    "name": "isLineEnd",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 14
                },
                {
                    "name": "lineIndex",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 13
                },
                {
                    "name": "pos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 12
                },
                {
                    "name": "previousWord",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 15
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "SyllableAnalysis",
            "id": "interface-SyllableAnalysis-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "breakdown",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "phones",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "stresses",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "SyllableSegment",
            "id": "interface-SyllableSegment-b2b38f3e364650d03899dc34d883b21b1b9e33d42f4c735755881c0d6c700eff664be1af9ccd2e4d65301e2e55a31e7a9b581178af334913b9c04dab44b87fd3",
            "file": "src/app/components/ui/multiline-input/multiline-input.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {\n  Component,\n  Input,\n  Output,\n  EventEmitter,\n  forwardRef,\n  HostListener,\n  signal,\n  computed,\n  inject,\n  effect,\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\nimport { RitaService, StateService } from '../../../services/';\n\nexport interface LineData {\n  text: string;\n  number: number;\n  focused: boolean;\n  syllables: number;\n  expectedSyllables: number;\n  isCorrect: boolean;\n  isOver: boolean;\n}\n\nexport interface SyllableSegment {\n  index: number;\n  filled: boolean;\n}\n\n@Component({\n  selector: 'app-multiline-input',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './multiline-input.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => MultilineInputComponent),\n      multi: true,\n    },\n  ],\n})\nexport class MultilineInputComponent implements ControlValueAccessor {\n  @Input() label = '';\n  @Input() placeholder = 'Write your poem line by line...';\n  @Input() error = '';\n  @Input() disabled = false;\n  @Input() rows = 12;\n  @Input() id = 'multiline-input';\n  @Input() showLineNumbers = true;\n  @Input() showLineValidation = false;\n  @Input() expectedPattern: number[] = [];\n  @Input() fontSizeClass = 'text-base';\n\n  private readonly rita = inject(RitaService);\n  private readonly stateService = inject(StateService);\n\n  readonly lines = signal<LineData[]>([]);\n  readonly focusedLineIndex = signal<number | null>(null);\n\n  readonly poemText = computed(() =>\n    this.lines()\n      .map((l) => l.text)\n      .join('\\n')\n  );\n\n  @Input()\n  get value(): string {\n    return this.poemText();\n  }\n  set value(val: string) {\n    this.initializeLines(val || '');\n    this.onChange(this.poemText());\n  }\n\n  @Output() valueChange = new EventEmitter<string>();\n  @Output() inputBlur = new EventEmitter<void>();\n  @Output() lineFocus = new EventEmitter<{ index: number; text: string }>();\n  @Output() lineValidationChange = new EventEmitter<LineData[]>();\n\n  private onChange: (value: string) => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private onTouched: () => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private isInternalUpdate = false;\n\n  constructor() {\n    this.initializeLines('');\n\n    effect(() => {\n      const pattern = this.stateService.currentPattern();\n      const newRows = this.stateService.expectedLines();\n      const sharedText = this.stateService.poemText();\n      const shouldLoadExample = this.stateService.shouldLoadExample();\n\n      if (pattern.length > 0) {\n        this.expectedPattern = pattern;\n        this.rows = newRows;\n\n        if (shouldLoadExample) {\n          this.stateService.loadExample();\n          this.stateService.consumeLoadExample();\n          return;\n        }\n\n        if (!this.isInternalUpdate && sharedText !== this.poemText()) {\n          this.initializeLines(sharedText);\n        }\n      }\n    });\n  }\n\n  private initializeLines(text: string): void {\n    const linesArray = text.split('\\n');\n    const total = this.rows;\n    const result: LineData[] = [];\n\n    for (let i = 0; i < total; i++) {\n      const expectedSyllables = this.expectedPattern[i] || 0;\n      const lineText = linesArray[i] || '';\n      const syllables = lineText ? this.rita.analyzeLine(lineText).syllables : 0;\n\n      result.push({\n        text: lineText,\n        number: i + 1,\n        focused: false,\n        syllables,\n        expectedSyllables,\n        isCorrect: syllables === expectedSyllables && syllables > 0,\n        isOver: syllables > expectedSyllables,\n      });\n    }\n\n    this.lines.set(result);\n    this.updateLineValidation();\n  }\n\n  writeValue(value: string): void {\n    if (!this.isInternalUpdate) {\n      this.initializeLines(value || '');\n    }\n  }\n\n  registerOnChange(fn: (value: string) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  onLineInput(index: number, text: string): void {\n    this.isInternalUpdate = true;\n\n    const updated = [...this.lines()];\n    updated[index].text = text;\n\n    if (this.showLineValidation) {\n      this.updateLineSyllables(updated[index]);\n    }\n\n    this.lines.set(updated);\n    this.emitChanges();\n    this.updateLineValidation();\n\n    this.stateService.updatePoemLines(updated.map((line) => line.text));\n\n    setTimeout(() => {\n      this.isInternalUpdate = false;\n    }, 0);\n  }\n\n  onLineFocus(index: number): void {\n    this.focusedLineIndex.set(index);\n    this.lineFocus.emit({ index, text: this.lines()[index].text });\n  }\n\n  onLineBlur(): void {\n    this.focusedLineIndex.set(null);\n    this.onTouched();\n    this.inputBlur.emit();\n  }\n\n  @HostListener('keydown', ['$event'])\n  handleKeyboardNavigation(event: KeyboardEvent): void {\n    const current = this.focusedLineIndex();\n    if (current === null) return;\n\n    const lines = this.lines();\n\n    switch (event.key) {\n      case 'ArrowUp':\n        event.preventDefault();\n        if (current > 0) this.focusLine(current - 1);\n        break;\n\n      case 'ArrowDown':\n        event.preventDefault();\n        if (current < lines.length - 1) this.focusLine(current + 1);\n        break;\n\n      case 'Enter':\n        if (!event.shiftKey) {\n          event.preventDefault();\n          if (current < lines.length - 1) {\n            this.focusLine(current + 1);\n          }\n        }\n        break;\n\n      case 'Tab':\n        event.preventDefault();\n        this.insertTextAtCursor('  ');\n        break;\n    }\n  }\n\n  private focusLine(index: number): void {\n    const input = document.getElementById(`${this.id}-line-${index}`) as HTMLInputElement;\n    if (!input) return;\n\n    input.focus();\n    this.focusedLineIndex.set(index);\n  }\n\n  private insertTextAtCursor(text: string): void {\n    const current = this.focusedLineIndex();\n    if (current === null) return;\n\n    const input = document.getElementById(`${this.id}-line-${current}`) as HTMLInputElement;\n    if (!input) return;\n\n    const start = input.selectionStart || 0;\n    const end = input.selectionEnd || 0;\n    const currentText = this.lines()[current].text;\n\n    const newText = currentText.substring(0, start) + text + currentText.substring(end);\n\n    const updated = [...this.lines()];\n    updated[current].text = newText;\n\n    if (this.showLineValidation) {\n      this.updateLineSyllables(updated[current]);\n    }\n\n    this.lines.set(updated);\n    this.emitChanges();\n    this.updateLineValidation();\n\n    setTimeout(() => {\n      input.focus();\n      input.setSelectionRange(start + text.length, start + text.length);\n    });\n  }\n\n  private updateLineSyllables(line: LineData): void {\n    if (!line.text.trim()) {\n      line.syllables = 0;\n      line.isCorrect = false;\n      line.isOver = false;\n      return;\n    }\n\n    const analysis = this.rita.analyzeLine(line.text);\n    line.syllables = analysis.syllables;\n    line.isCorrect = line.syllables === line.expectedSyllables;\n    line.isOver = line.syllables > line.expectedSyllables;\n  }\n\n  private updateLineValidation(): void {\n    if (this.showLineValidation) {\n      const lines = this.lines();\n      lines.forEach((line) => {\n        if (line.text.trim()) {\n          this.updateLineSyllables(line);\n        }\n      });\n      this.lineValidationChange.emit(lines);\n    }\n  }\n\n  private emitChanges(): void {\n    this.onChange(this.poemText());\n    this.valueChange.emit(this.poemText());\n  }\n\n  getSyllableSegments(line: LineData): SyllableSegment[] {\n    const segments: SyllableSegment[] = [];\n    const expected = line.expectedSyllables;\n    const current = line.syllables;\n\n    for (let i = 0; i < expected; i++) {\n      segments.push({\n        index: i,\n        filled: i < current,\n      });\n    }\n\n    return segments;\n  }\n\n  getSyllableCountClass(line: LineData): string {\n    if (line.syllables === 0) return 'syllable-count-empty';\n    if (line.syllables === line.expectedSyllables) return 'syllable-count-perfect';\n    if (line.syllables > line.expectedSyllables) return 'syllable-count-over';\n\n    const progress = (line.syllables / line.expectedSyllables) * 100;\n    if (progress >= 75) return 'syllable-count-close';\n    if (progress >= 50) return 'syllable-count-medium';\n    return 'syllable-count-low';\n  }\n\n  clear(): void {\n    this.initializeLines('');\n    this.emitChanges();\n    this.focusLine(0);\n  }\n\n  focus(): void {\n    this.focusLine(0);\n  }\n\n  setText(text: string): void {\n    this.initializeLines(text);\n    this.emitChanges();\n  }\n\n  handleLineInput(event: Event, index: number): void {\n    const target = event.target as HTMLInputElement;\n    this.onLineInput(index, target.value);\n  }\n}\n",
            "properties": [
                {
                    "name": "filled",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 29
                },
                {
                    "name": "index",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 28
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "ThemeColor",
            "id": "interface-ThemeColor-29cfd58f74de1dba14f11aa909802f2e70d9e93dcf90e3100a1d0aa8c6d81a367c96a7f818a276a876bd9065787802d4cb308f76a4f67e543e96d47808c31a60",
            "file": "src/lib/material-theme/theme.config.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {\n  SchemeTonalSpot,\n  SchemeNeutral,\n  SchemeVibrant,\n  SchemeExpressive,\n  SchemeMonochrome,\n  SchemeContent,\n  SchemeFidelity,\n  SchemeFruitSalad,\n  SchemeRainbow,\n  Hct,\n  type DynamicScheme,\n} from '@material/material-color-utilities';\n\nexport type SchemeConstructor = new (\n  sourceColorHct: Hct,\n  isDark: boolean,\n  contrastLevel: number\n) => DynamicScheme;\n\nexport const SEED_COLOR = '#F4C2C2';\n\nexport const SCHEMES: { name: string; variant: SchemeConstructor }[] = [\n  { name: 'tonal-spot', variant: SchemeTonalSpot },\n  { name: 'neutral', variant: SchemeNeutral },\n  { name: 'vibrant', variant: SchemeVibrant },\n  { name: 'expressive', variant: SchemeExpressive },\n  { name: 'monochrome', variant: SchemeMonochrome },\n  { name: 'content', variant: SchemeContent },\n  { name: 'fidelity', variant: SchemeFidelity },\n  { name: 'fruit-salad', variant: SchemeFruitSalad },\n  { name: 'rainbow', variant: SchemeRainbow },\n];\n\nexport const SELECTED_SCHEME = 'fidelity';\n\nexport const TERMINAL_COLORS_CONFIG = {\n  red: { hue: 10, chroma: 84, tone: 50 },\n  green: { hue: 145, chroma: 48, tone: 50 },\n  yellow: { hue: 90, chroma: 70, tone: 60 },\n  blue: { hue: 245, chroma: 80, tone: 50 },\n  magenta: { hue: 330, chroma: 68, tone: 50 },\n  cyan: { hue: 200, chroma: 48, tone: 50 },\n};\n\nexport const THEME_CSS_VARS = [\n  'primary',\n  'onPrimary',\n  'primaryContainer',\n  'onPrimaryContainer',\n  'secondary',\n  'onSecondary',\n  'secondaryContainer',\n  'onSecondaryContainer',\n  'tertiary',\n  'onTertiary',\n  'tertiaryContainer',\n  'onTertiaryContainer',\n  'error',\n  'onError',\n  'errorContainer',\n  'onErrorContainer',\n  'background',\n  'onBackground',\n  'surface',\n  'surfaceDim',\n  'surfaceBright',\n  'surfaceContainerLowest',\n  'surfaceContainerLow',\n  'surfaceContainer',\n  'surfaceContainerHigh',\n  'surfaceContainerHighest',\n  'onSurface',\n  'surfaceVariant',\n  'onSurfaceVariant',\n  'outline',\n  'outlineVariant',\n  'shadow',\n  'scrim',\n  'inverseSurface',\n  'inverseOnSurface',\n  'inversePrimary',\n];\n\nexport const TERMINAL_CSS_VARS = [\n  'red',\n  'redContainer',\n  'onRedContainer',\n  'green',\n  'greenContainer',\n  'onGreenContainer',\n  'yellow',\n  'yellowContainer',\n  'onYellowContainer',\n  'blue',\n  'blueContainer',\n  'onBlueContainer',\n  'magenta',\n  'magentaContainer',\n  'onMagentaContainer',\n  'cyan',\n  'cyanContainer',\n  'onCyanContainer',\n\n  'inverseRed',\n  'inverseRedContainer',\n  'inverseOnRedContainer',\n  'inverseGreen',\n  'inverseGreenContainer',\n  'inverseOnGreenContainer',\n  'inverseYellow',\n  'inverseYellowContainer',\n  'inverseOnYellowContainer',\n  'inverseBlue',\n  'inverseBlueContainer',\n  'inverseOnBlueContainer',\n  'inverseMagenta',\n  'inverseMagentaContainer',\n  'inverseOnMagentaContainer',\n  'inverseCyan',\n  'inverseCyanContainer',\n  'inverseOnCyanContainer',\n];\n\nexport const ALL_CSS_VARS = [...THEME_CSS_VARS, ...TERMINAL_CSS_VARS];\n\nexport const THEME_CONFIG = {\n  seedColor: SEED_COLOR,\n  selectedScheme: SELECTED_SCHEME,\n  availableSchemes: SCHEMES.map((s) => s.name),\n  materialVariables: THEME_CSS_VARS.length,\n  terminalVariables: TERMINAL_CSS_VARS.length,\n  totalVariables: ALL_CSS_VARS.length,\n};\n\nexport interface ThemeColor {\n  hue: number;\n  chroma: number;\n  tone: number;\n}\n\nexport type TerminalColors = keyof typeof TERMINAL_COLORS_CONFIG;\nexport type MaterialColors = (typeof THEME_CSS_VARS)[number];\nexport type AllColors = MaterialColors | TerminalColors;\n\nexport function getSchemeConstructor(schemeName: string): SchemeConstructor {\n  const scheme = SCHEMES.find((s) => s.name === schemeName);\n  if (!scheme) {\n    throw new Error(\n      `Scheme not found: ${schemeName}. Available schemes: ${SCHEMES.map((s) => s.name).join(', ')}`\n    );\n  }\n  return scheme.variant;\n}\n\nexport function isValidScheme(schemeName: string): boolean {\n  return SCHEMES.some((s) => s.name === schemeName);\n}\n\nexport function getAvailableSchemes(): string[] {\n  return SCHEMES.map((s) => s.name);\n}\n\nexport function getConfigInfo(): string {\n  return `\nTheme Configuration:\n-------------------\nSeed Color: ${SEED_COLOR}\nSelected Scheme: ${SELECTED_SCHEME}\nAvailable Schemes: ${getAvailableSchemes().join(', ')}\nMaterial Variables: ${THEME_CSS_VARS.length}\nTerminal Variables: ${TERMINAL_CSS_VARS.length}\nTotal Variables: ${ALL_CSS_VARS.length}\n  `.trim();\n}\n",
            "properties": [
                {
                    "name": "chroma",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 138
                },
                {
                    "name": "hue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 137
                },
                {
                    "name": "tone",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 139
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "Toast",
            "id": "interface-Toast-205f8fc4fe55ff61e7a3cf41dd3a9d73f11125462cf7913be0245820b502a81c21aa52c8693e3125c6a9cacd729836a9ad71c7771ba8cb8c9178a57c63c1e422",
            "file": "src/app/services/core/toast.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, signal } from '@angular/core';\n\nexport interface Toast {\n  id: string;\n  title: string;\n  message?: string;\n  type: 'info' | 'success' | 'warning' | 'error';\n  duration?: number;\n}\n\n@Injectable({ providedIn: 'root' })\nexport class ToastService {\n  readonly toasts = signal<Toast[]>([]);\n\n  show(toast: Omit<Toast, 'id'>): void {\n    const id = crypto.randomUUID();\n    const duration = toast.duration ?? 3000;\n\n    this.toasts.update((toasts) => [...toasts, { ...toast, id }]);\n\n    if (duration > 0) {\n      setTimeout(() => this.remove(id), duration);\n    }\n  }\n\n  remove(id: string): void {\n    this.toasts.update((toasts) => toasts.filter((t) => t.id !== id));\n  }\n\n  success(title: string, message?: string, duration?: number): void {\n    this.show({ title, message, type: 'success', duration });\n  }\n\n  error(title: string, message?: string, duration?: number): void {\n    this.show({ title, message, type: 'error', duration });\n  }\n\n  info(title: string, message?: string, duration?: number): void {\n    this.show({ title, message, type: 'info', duration });\n  }\n\n  warning(title: string, message?: string, duration?: number): void {\n    this.show({ title, message, type: 'warning', duration });\n  }\n}\n",
            "properties": [
                {
                    "name": "duration",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "message",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "title",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"info\" | \"success\" | \"warning\" | \"error\"",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "VideoCaptureOptions",
            "id": "interface-VideoCaptureOptions-840e69b8d5b79da86dc82c94b284308b890860126fa6920b495552184c5b9822d10d261a7a4ab58cf8a5d5ed3e5d5ee1df578c225bbdd06dad111e99c36b5366",
            "file": "src/lib/capture/video-capture.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { existsSync, mkdirSync } from 'fs';\nimport { join } from 'path';\nimport type { CaptureOptions, CaptureResult } from './types';\nimport { BrowserManager } from './browser-utils';\nimport { Browser, BrowserContext, Page } from 'playwright';\nimport { SHARED_CONFIG } from '../../../playwright.config';\nimport { SELECTORS, TestHelpers } from '../../e2e/selectors';\n\ninterface VideoCaptureOptions extends Omit<CaptureOptions, 'multiple'> {\n  duration?: number;\n  browserType?: 'brave' | 'chrome' | 'firefox';\n  showInteractions?: boolean;\n  includeAdvancedDemo?: boolean;\n}\n\nexport class VideoCapture {\n  private options: Required<Omit<VideoCaptureOptions, 'multiple'>>;\n\n  constructor(options: VideoCaptureOptions = {}) {\n    this.options = {\n      url: options.url || SHARED_CONFIG.baseURL,\n      outputDir: options.outputDir || 'angular-captures/videos',\n      viewport: options.viewport || { width: 1200, height: 800 },\n      delay: options.delay || 3000,\n      format: options.format || 'mp4',\n      duration: options.duration || 15000,\n      browserType: options.browserType || 'brave',\n      mode: options.mode || 'full',\n      showInteractions: options.showInteractions ?? true,\n      includeAdvancedDemo: options.includeAdvancedDemo ?? false,\n    };\n  }\n\n  async capture(): Promise<CaptureResult> {\n    const startTime = Date.now();\n    const outputDir = this.options.outputDir;\n\n    if (!existsSync(outputDir)) {\n      mkdirSync(outputDir, { recursive: true });\n    }\n\n    console.log('🎬 Starting video capture...');\n    console.log(`🌐 URL: ${this.options.url}`);\n    console.log(`⏱️ Duration: ${this.options.duration}ms`);\n    console.log(`🌐 Browser: ${this.options.browserType}`);\n    console.log(`🖥️ Viewport: ${this.options.viewport.width}x${this.options.viewport.height}`);\n    console.log(`🎯 Interactions: ${this.options.showInteractions ? 'Enabled' : 'Disabled'}`);\n\n    let browser: Browser | undefined;\n    let context: BrowserContext | undefined;\n    let page: Page | undefined;\n\n    try {\n      const browserSetup = await BrowserManager.launchBrowser({\n        headless: false,\n        viewport: this.options.viewport,\n        recordVideo: true,\n        videoSize: this.options.viewport,\n        browserType: this.options.browserType,\n        timeout: this.options.duration + 10000,\n      });\n\n      browser = browserSetup.browser;\n      context = browserSetup.context;\n      page = browserSetup.page;\n\n      const navigationSuccess = await BrowserManager.safeNavigate(page, this.options.url);\n      if (!navigationSuccess) {\n        throw new Error('Failed to navigate to application');\n      }\n\n      await BrowserManager.waitForAppReady(page);\n      await BrowserManager.wait(this.options.delay);\n\n      if (this.options.showInteractions) {\n        if (this.options.includeAdvancedDemo) {\n          await this.performAdvancedDemo(page);\n        } else {\n          await BrowserManager.performEditorActions(page);\n        }\n      }\n\n      const elapsedTime = Date.now() - startTime;\n      const remainingTime = this.options.duration - elapsedTime;\n\n      if (remainingTime > 0) {\n        console.log(`⏳ Recording for ${Math.round(remainingTime / 1000)}s more...`);\n        await BrowserManager.wait(remainingTime);\n      }\n\n      await BrowserManager.cleanup(browser, context);\n\n      const duration = Date.now() - startTime;\n      const outputPath = await this.findLatestVideoFile(outputDir);\n\n      if (outputPath) {\n        console.log('✅ Video recorded successfully');\n        console.log(`📊 Capture duration: ${duration}ms`);\n        console.log(`💾 Output: ${outputPath}`);\n      } else {\n        console.log('⚠️ Video file not found, but capture completed');\n      }\n\n      return {\n        success: true,\n        outputPath,\n        duration,\n        timestamp: new Date().toISOString(),\n        url: this.options.url,\n        mode: this.options.mode,\n      };\n    } catch (error) {\n      await BrowserManager.cleanup(browser, context);\n      console.error('❌ Error during video capture:', error);\n\n      return {\n        success: false,\n        outputPath: '',\n        duration: Date.now() - startTime,\n        timestamp: new Date().toISOString(),\n        url: this.options.url,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  /**\n   * ⚡ NUEVO: Demo avanzada que muestra más características\n   */\n  private async performAdvancedDemo(page: Page): Promise<void> {\n    console.log('🎯 Performing advanced demo with full workflow...');\n\n    try {\n      const forms = [\n        { id: SELECTORS.FORM_OPTIONS.HAIKU, wait: 1500 },\n        { id: SELECTORS.FORM_OPTIONS.TANKA, wait: 1500 },\n        { id: SELECTORS.FORM_OPTIONS.LIMERICK, wait: 1500 },\n      ];\n\n      for (const form of forms) {\n        await TestHelpers.selectPoetryForm(page, form.id);\n        await BrowserManager.wait(form.wait);\n        console.log(`✅ Demo: Form ${form.id}`);\n      }\n\n      await TestHelpers.selectPoetryForm(page, SELECTORS.FORM_OPTIONS.HAIKU);\n      await BrowserManager.wait(1000);\n\n      const demoPoem = [\n        'Silent morning light',\n        'Cherry blossoms gently fall',\n        'Spring awakens slow',\n      ];\n\n      await TestHelpers.fillPoemLines(page, demoPoem);\n      await BrowserManager.wait(2000);\n      console.log('✅ Demo: Custom poem written');\n\n      const analyzeButton = page.locator(SELECTORS.BUTTONS.ANALYZE).first();\n      if ((await analyzeButton.isVisible()) && (await analyzeButton.isEnabled())) {\n        await analyzeButton.click();\n        console.log('🔍 Demo: Analysis started');\n\n        await BrowserManager.wait(6000);\n\n        const resultsVisible = await page\n          .locator(SELECTORS.RESULTS.CONTAINER)\n          .isVisible({ timeout: 3000 })\n          .catch(() => false);\n\n        if (resultsVisible) {\n          console.log('✅ Demo: Results displayed');\n\n          await page.evaluate(() => {\n            const results = document.querySelector('app-poem-results');\n            if (results) {\n              results.scrollTo({ top: 200, behavior: 'smooth' });\n            }\n          });\n          await BrowserManager.wait(1500);\n\n          await page.evaluate(() => {\n            const results = document.querySelector('app-poem-results');\n            if (results) {\n              results.scrollTo({ top: 0, behavior: 'smooth' });\n            }\n          });\n          await BrowserManager.wait(1000);\n\n          const tabs = ['structure', 'rhythm', 'quality'];\n          for (const tab of tabs) {\n            try {\n              const tabButton = page.locator(`.metro-pivot-item:has-text(\"${tab}\")`);\n              if (await tabButton.isVisible({ timeout: 2000 })) {\n                await tabButton.click();\n                await BrowserManager.wait(2000);\n                console.log(`✅ Demo: Switched to ${tab} tab`);\n              }\n            } catch {\n              console.log(`⚠️ Demo: Tab ${tab} not available`);\n            }\n          }\n        }\n      }\n\n      const copyButton = page.locator(SELECTORS.BUTTONS.COPY).first();\n      if ((await copyButton.isVisible()) && (await copyButton.isEnabled())) {\n        await copyButton.click();\n        await BrowserManager.wait(1500);\n        console.log('✅ Demo: Copy function');\n      }\n\n      await TestHelpers.loadExample(page);\n      await BrowserManager.wait(2000);\n      console.log('✅ Demo: Official example loaded');\n\n      await page.evaluate(() => window.scrollTo({ top: 400, behavior: 'smooth' }));\n      await BrowserManager.wait(1000);\n      await page.evaluate(() => window.scrollTo({ top: 0, behavior: 'smooth' }));\n      await BrowserManager.wait(1000);\n\n      console.log('✅ Advanced demo completed successfully');\n    } catch (error) {\n      console.log(\n        '⚠️ Some advanced demo actions failed:',\n        error instanceof Error ? error.message : error\n      );\n    }\n  }\n\n  /**\n   * Busca el archivo de video más reciente en el directorio de salida\n   */\n  private async findLatestVideoFile(outputDir: string): Promise<string> {\n    try {\n      const fs = await import('fs/promises');\n\n      if (!existsSync(outputDir)) {\n        console.log('⚠️ Output directory does not exist');\n        return '';\n      }\n\n      const files = await fs.readdir(outputDir);\n\n      const videoFiles = files\n        .filter((f) => f.endsWith('.webm') || f.endsWith('.mp4') || f.endsWith('.mkv'))\n        .map((f) => ({\n          name: f,\n          path: join(outputDir, f),\n          time: fs.stat(join(outputDir, f)).then((stat) => stat.mtime),\n        }));\n\n      if (videoFiles.length === 0) {\n        console.log('⚠️ No video files found in directory');\n        return '';\n      }\n\n      const filesWithStats = await Promise.all(\n        videoFiles.map(async (file) => ({\n          ...file,\n          time: await file.time,\n        }))\n      );\n\n      filesWithStats.sort((a, b) => b.time.getTime() - a.time.getTime());\n\n      const latestFile = filesWithStats[0]?.path || '';\n\n      if (latestFile) {\n        console.log(`📹 Latest video file: ${latestFile}`);\n      }\n\n      return latestFile;\n    } catch (error) {\n      console.warn('⚠️ Error finding video file:', error);\n      return '';\n    }\n  }\n\n  /**\n   * Captura rápida de video con configuración predeterminada\n   */\n  static async quickCapture(\n    url: string = SHARED_CONFIG.baseURL,\n    duration = 15000\n  ): Promise<CaptureResult> {\n    const capture = new VideoCapture({\n      url,\n      duration,\n      browserType: 'brave',\n      showInteractions: true,\n    });\n    return await capture.capture();\n  }\n\n  /**\n   * Captura de demo básica (15 segundos con interacciones estándar)\n   */\n  static async captureDemo(): Promise<CaptureResult> {\n    return await this.quickCapture(SHARED_CONFIG.baseURL, 20000);\n  }\n\n  /**\n   * Captura de demo completa (30 segundos con workflow completo)\n   */\n  static async captureFullDemo(): Promise<CaptureResult> {\n    const capture = new VideoCapture({\n      url: SHARED_CONFIG.baseURL,\n      duration: 30000,\n      browserType: 'brave',\n      showInteractions: true,\n      includeAdvancedDemo: true,\n    });\n    return await capture.capture();\n  }\n}\n\nexport async function captureVideo(options?: VideoCaptureOptions): Promise<CaptureResult> {\n  const capture = new VideoCapture(options);\n  return await capture.capture();\n}\n",
            "properties": [
                {
                    "name": "browserType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"brave\" | \"chrome\" | \"firefox\"",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 11
                },
                {
                    "name": "duration",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 10
                },
                {
                    "name": "includeAdvancedDemo",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 13
                },
                {
                    "name": "showInteractions",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 12
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": [
                "Omit"
            ]
        },
        {
            "name": "WordAnalysis",
            "id": "interface-WordAnalysis-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "phones",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15
                },
                {
                    "name": "pos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "stresses",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 14
                },
                {
                    "name": "word",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 13
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "WordSuggestionData",
            "id": "interface-WordSuggestionData-cc01c88b56c2eb0b88baa736de26edf66653299b14fecfbb0dc7434c68b3977c7f382c4e601296066b01dfe98a03a03a66ecf008c0598e91718873cd4c5aefdb",
            "file": "src/app/services/poetry/poetry-analyzer.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject, signal } from '@angular/core';\nimport { PoetryAnalysisService } from './poetry-analysis.service';\nimport { PoetrySuggestionsService } from './poetry-suggestions.service';\nimport { PoetryPatternsService } from './poetry-patterns.service';\nimport { RhymeAnalysisService } from './rhyme-analysis.service';\nimport { PoemQualityService, type QualityMetrics } from './poem-quality.service';\nimport {\n  MeterAnalysisService,\n  type MeterAnalysis,\n  type RhythmSuggestion,\n} from './meter-analysis.service';\nimport {\n  RitaService,\n  type GrammaticalAnalysis,\n  type AlliterationMatch,\n  type AlternativeWord,\n} from './rita.service';\nimport { POETRY_FORMS, POETRY_EXAMPLES } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface EnhancedLineAnalysis extends LineAnalysis {\n  words: {\n    word: string;\n    syllables: number;\n    pos: string;\n    phones: string;\n    grammar?: GrammaticalAnalysis;\n  }[];\n  alliterations?: AlliterationMatch[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n}\n\nexport interface EnhancedPoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: EnhancedLineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n  overallAlliterations: AlliterationMatch[];\n  detectedPatterns: string[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n  meterAnalysis?: MeterAnalysis;\n}\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalyzerService {\n  private readonly analysis = inject(PoetryAnalysisService);\n  private readonly suggestions = inject(PoetrySuggestionsService);\n  private readonly patterns = inject(PoetryPatternsService);\n  private readonly rhymes = inject(RhymeAnalysisService);\n  private readonly quality = inject(PoemQualityService);\n  private readonly meterService = inject(MeterAnalysisService);\n  private readonly rita = inject(RitaService);\n\n  readonly isLoading = signal(false);\n  readonly result = signal<EnhancedPoetryResult | null>(null);\n  readonly selectedWord = signal<string | null>(null);\n  readonly wordAlternatives = signal<WordSuggestionData | null>(null);\n  readonly qualityMetrics = signal<QualityMetrics | null>(null);\n  readonly selectedForm = signal<string>('haiku');\n  readonly poemText = signal<string>('');\n  readonly rhythmSuggestions = signal<RhythmSuggestion[]>([]);\n\n  async analyze(formKey: string, rawLines: string[]): Promise<EnhancedPoetryResult> {\n    this.isLoading.set(true);\n\n    try {\n      const form = POETRY_FORMS[formKey];\n      if (!form) {\n        throw new Error(`Unknown form \"${formKey}\"`);\n      }\n\n      const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n      // Análisis dinámico basado en el poema actual\n      const typos = await this.rita.detectTypos(lines);\n      const meterAnalysis = this.meterService.detectMeter(lines);\n      const rhythmSuggestions = this.meterService.generateRhythmSuggestions(\n        lines,\n        meterAnalysis.type\n      );\n      this.rhythmSuggestions.set(rhythmSuggestions);\n\n      const lineAnalyses: EnhancedLineAnalysis[] = await Promise.all(\n        lines.map(async (line, index) => {\n          const analysis = this.rita.analyzeLine(line);\n          const words = this.rita.analyzeWords(line);\n          const alliterations = this.rita.detectAlliterations(line);\n          const expected = form.pattern[index] ?? 0;\n\n          const wordsWithGrammar = words.map((word) => ({\n            ...word,\n            grammar: this.rita.analyzeGrammar(word.word),\n          }));\n\n          return {\n            text: line,\n            count: analysis.syllables,\n            expected,\n            match: analysis.syllables === expected,\n            syllables: analysis.breakdown,\n            stresses: analysis.stresses,\n            words: wordsWithGrammar,\n            alliterations: alliterations.length > 0 ? alliterations : undefined,\n            typos: typos.filter((t) => t.line === index),\n          };\n        })\n      );\n\n      // Calcular calidad basada en el poema actual\n      const quality = this.quality.assessQuality(\n        lines,\n        form.pattern,\n        this.createResultForQualityAssessment(formKey, lineAnalyses)\n      );\n\n      const overallAlliterations = this.rhymes.detectCrossLineAlliterations(lines);\n      const detectedPatterns = [\n        ...this.detectPatterns(lineAnalyses),\n        ...this.generateMeterPatterns(meterAnalysis),\n      ];\n\n      const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n      const mismatches = lineAnalyses.filter((l) => !l.match).length;\n      const summary = ok\n        ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n            '-'\n          )} pattern`\n        : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n      const suggestions = this.generateEnhancedSuggestions(\n        lineAnalyses,\n        form.pattern,\n        meterAnalysis\n      );\n      const rhymeScheme = lines.length > 1 ? this.rita.analyzeRhymeScheme(lines) : undefined;\n\n      const result: EnhancedPoetryResult = {\n        ok,\n        form: formKey,\n        totalLines: {\n          expected: form.pattern.length,\n          actual: lineAnalyses.length,\n        },\n        lines: lineAnalyses,\n        summary,\n        rhymeScheme,\n        suggestions,\n        overallAlliterations,\n        detectedPatterns,\n        typos: typos.length > 0 ? typos : undefined,\n        meterAnalysis,\n      };\n\n      this.result.set(result);\n      this.qualityMetrics.set(quality);\n      return result;\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  async selectWordEnhanced(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) return;\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.suggestions.getWordAlternativesEnhanced(\n              word,\n              neededSyllables,\n              {\n                pos: wordAnalysis.pos,\n                lineIndex: result.lines.indexOf(line),\n                isLineEnd: line.words[line.words.length - 1]?.word === word,\n                previousWord: this.getPreviousWord(line.words, word),\n              }\n            );\n\n            this.wordAlternatives.set(alternatives);\n          } catch (error) {\n            console.warn('Error getting enhanced alternatives:', error);\n            await this.selectWord(word);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  async selectWord(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) {\n      return;\n    }\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.rita.suggestAlternatives(word, neededSyllables, 8);\n            this.wordAlternatives.set({\n              original: word,\n              currentSyllables: wordAnalysis.syllables,\n              targetSyllables: neededSyllables,\n              alternatives,\n            });\n          } catch (error) {\n            console.warn('Error getting word alternatives:', error);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  loadExample(): void {\n    const formId = this.selectedForm();\n    const example = POETRY_EXAMPLES[formId];\n    if (example) {\n      this.poemText.set(example.join('\\n'));\n      // Analizar automáticamente el ejemplo cargado\n      this.analyze(formId, example);\n    }\n  }\n\n  assessQuality(): void {\n    const result = this.result();\n    if (!result) return;\n\n    const lines = result.lines.map((l) => l.text);\n    const pattern = POETRY_FORMS[result.form].pattern;\n\n    const metrics = this.quality.assessQuality(lines, pattern, result);\n    this.qualityMetrics.set(metrics);\n  }\n\n  replaceWord(oldWord: string, newWord: string): void {\n    const result = this.result();\n    if (!result) return;\n\n    const updatedLines = result.lines.map((line) => {\n      const updatedText = line.text.replace(new RegExp(`\\\\b${oldWord}\\\\b`, 'gi'), newWord);\n      return updatedText;\n    });\n\n    this.poemText.set(updatedLines.join('\\n'));\n    this.analyze(result.form, updatedLines);\n    this.selectWordEnhanced(null);\n  }\n\n  clear(): void {\n    this.result.set(null);\n    this.selectedWord.set(null);\n    this.wordAlternatives.set(null);\n    this.qualityMetrics.set(null);\n    this.rhythmSuggestions.set([]);\n    this.poemText.set('');\n  }\n\n  private detectPatterns(lines: EnhancedLineAnalysis[]): string[] {\n    const patterns: string[] = [];\n\n    // Detectar patrones basados en el análisis real\n    const stressPatterns = lines.map((l) => l.stresses).filter((s) => s);\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent stress pattern: ${firstPattern}`);\n      }\n    }\n\n    // Detectar aliteraciones en el poema actual\n    const linesWithAlliteration = lines.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length > 0) {\n      patterns.push(\n        `${linesWithAlliteration.length} line${\n          linesWithAlliteration.length > 1 ? 's' : ''\n        } contain alliteration`\n      );\n    }\n\n    // Análisis de vocabulario del poema actual\n    const allWords = lines.flatMap((l) => l.words);\n    const nouns = allWords.filter((w) => w.pos.startsWith('nn')).length;\n    const verbs = allWords.filter((w) => w.pos.startsWith('vb')).length;\n    const adjectives = allWords.filter((w) => w.pos.startsWith('jj')).length;\n    const adverbs = allWords.filter((w) => w.pos.startsWith('rb')).length;\n\n    if (nouns > verbs * 2) {\n      patterns.push('Noun-heavy composition (descriptive style)');\n    } else if (verbs > nouns * 1.5) {\n      patterns.push('Verb-heavy composition (active style)');\n    }\n\n    if (adjectives > allWords.length * 0.2) {\n      patterns.push('High use of adjectives (vivid imagery)');\n    }\n\n    if (adverbs > allWords.length * 0.15) {\n      patterns.push('Adverb-rich language (detailed action)');\n    }\n\n    // Análisis de longitud de palabras\n    const avgWordLength =\n      allWords.reduce((sum, w) => sum + w.word.length, 0) / (allWords.length || 1);\n    if (avgWordLength > 6) {\n      patterns.push('Complex vocabulary (long words)');\n    } else if (avgWordLength < 4) {\n      patterns.push('Simple vocabulary (short words)');\n    }\n\n    return patterns;\n  }\n\n  private generateMeterPatterns(meter: MeterAnalysis): string[] {\n    const patterns: string[] = [];\n\n    if (meter.consistency > 70) {\n      patterns.push(`Strong ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    } else if (meter.consistency > 40) {\n      patterns.push(`Emerging ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    }\n\n    if (meter.type !== 'irregular') {\n      patterns.push(`Meter: ${meter.pattern}`);\n    }\n\n    return patterns;\n  }\n\n  private generateEnhancedSuggestions(\n    lineAnalyses: EnhancedLineAnalysis[],\n    pattern: number[],\n    meterAnalysis: MeterAnalysis\n  ): string[] {\n    const suggestions: string[] = [];\n\n    // Sugerencias basadas en la estructura del poema actual\n    if (lineAnalyses.length < pattern.length) {\n      const missing = pattern.length - lineAnalyses.length;\n      suggestions.push(`Add ${missing} more line${missing > 1 ? 's' : ''} to complete the pattern`);\n    } else if (lineAnalyses.length > pattern.length) {\n      const extra = lineAnalyses.length - pattern.length;\n      suggestions.push(`Remove ${extra} line${extra > 1 ? 's' : ''} to match the pattern`);\n    }\n\n    // Sugerencias rítmicas basadas en el análisis métrico\n    if (meterAnalysis.consistency < 60) {\n      suggestions.push(\n        `Improve rhythm consistency: ${meterAnalysis.type} meter detected but inconsistent`\n      );\n    }\n\n    if (meterAnalysis.type === 'irregular' && lineAnalyses.length > 2) {\n      suggestions.push('Consider using a regular meter pattern for better poetic flow');\n    }\n\n    // Sugerencias específicas por línea\n    lineAnalyses.forEach((line, index) => {\n      if (!line.match && index < pattern.length) {\n        const lineSuggestions = this.rita.generateSuggestions(line.text, pattern[index]);\n        suggestions.push(`Line ${index + 1}: ${lineSuggestions[0]}`);\n\n        const diff = pattern[index] - line.count;\n        if (diff > 0) {\n          const shortWords = line.words.filter((w) => w.syllables === 1);\n          if (shortWords.length > 0) {\n            suggestions.push(`  → Try replacing \"${shortWords[0].word}\" with a longer synonym`);\n          }\n        } else if (diff < 0) {\n          const longWords = line.words\n            .filter((w) => w.syllables > 2)\n            .sort((a, b) => b.syllables - a.syllables);\n          if (longWords.length > 0) {\n            suggestions.push(\n              `  → Try replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter word`\n            );\n          }\n        }\n      }\n    });\n\n    // Sugerencias de dispositivos literarios\n    const linesWithAlliteration = lineAnalyses.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length === 0 && lineAnalyses.length > 2) {\n      suggestions.push('Consider adding alliteration for poetic effect');\n    }\n\n    const hasRhyme = lineAnalyses.some((line) =>\n      line.words.some(\n        (word) => (word.pos && word.pos.startsWith('nn')) || word.pos.startsWith('vb')\n      )\n    );\n    if (!hasRhyme && lineAnalyses.length > 1) {\n      suggestions.push('Try incorporating rhyme for musical quality');\n    }\n\n    return suggestions.slice(0, 6);\n  }\n\n  private getPreviousWord(words: { word: string }[], currentWord: string): string | undefined {\n    const currentIndex = words.findIndex((w) => w.word.toLowerCase() === currentWord.toLowerCase());\n    return currentIndex > 0 ? words[currentIndex - 1].word : undefined;\n  }\n\n  private createResultForQualityAssessment(\n    formKey: string,\n    lineAnalyses: EnhancedLineAnalysis[]\n  ): EnhancedPoetryResult {\n    const form = POETRY_FORMS[formKey];\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n    return {\n      ok,\n      form: formKey,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      lines: lineAnalyses,\n      summary: '',\n      suggestions: [],\n      overallAlliterations: [],\n      detectedPatterns: [],\n    };\n  }\n\n  isCompletePoem(): boolean {\n    const result = this.result();\n    if (!result) return false;\n\n    return (\n      result.lines.length === result.totalLines.expected && result.lines.every((line) => line.match)\n    );\n  }\n\n  getQuickStats(): {\n    totalSyllables: number;\n    avgSyllablesPerLine: number;\n    vocabularyRichness: number;\n  } {\n    const result = this.result();\n    if (!result || result.lines.length === 0) {\n      return { totalSyllables: 0, avgSyllablesPerLine: 0, vocabularyRichness: 0 };\n    }\n\n    const totalSyllables = result.lines.reduce((sum, line) => sum + line.count, 0);\n    const avgSyllablesPerLine = totalSyllables / result.lines.length;\n\n    const allWords = result.lines.flatMap((line) => line.words.map((w) => w.word.toLowerCase()));\n    const uniqueWords = new Set(allWords);\n    const vocabularyRichness = (uniqueWords.size / allWords.length) * 100;\n\n    return {\n      totalSyllables,\n      avgSyllablesPerLine: Math.round(avgSyllablesPerLine * 10) / 10,\n      vocabularyRichness: Math.round(vocabularyRichness * 10) / 10,\n    };\n  }\n}\n",
            "properties": [
                {
                    "name": "alternatives",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "AlternativeWord[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 62
                },
                {
                    "name": "currentSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 60
                },
                {
                    "name": "original",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 59
                },
                {
                    "name": "targetSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 61
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "WordSuggestionData",
            "id": "interface-WordSuggestionData-24eb12fada130bc88b863f4d93cc015155ad8963e6b439cd89626c34ffadb8c508817746d6d4f5f7e11b910ca3bb30339b231a1a9016833254b2677222c8462e-1",
            "file": "src/app/services/poetry/poetry-suggestions.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService, type AlternativeWord } from './rita.service';\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\nexport interface SuggestionContext {\n  pos?: string;\n  lineIndex?: number;\n  isLineEnd?: boolean;\n  previousWord?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetrySuggestionsService {\n  private readonly rita = inject(RitaService);\n\n  async getWordAlternativesEnhanced(\n    word: string,\n    targetSyllables: number,\n    context: SuggestionContext = {}\n  ): Promise<WordSuggestionData> {\n    const currentSyllables = this.rita.analyzeLine(word).syllables;\n\n    // Búsqueda simple y efectiva - CORREGIR parámetros\n    const [exactMatches, rhymes, phonetic] = await Promise.all([\n      this.searchBySyllables(targetSyllables), // ❌ Eliminar context.pos\n      context.isLineEnd\n        ? this.rita.findRhymes(word, targetSyllables).then((r) => r.perfectRhymes)\n        : Promise.resolve([]),\n      this.rita.suggestAlternatives(word, targetSyllables, 6),\n    ]);\n\n    const allAlternatives = [\n      ...exactMatches,\n      ...rhymes.map((w) => ({\n        word: w, // ✅ w es string, no AlternativeWord\n        syllables: targetSyllables,\n        reason: 'rhyme-match' as const,\n        pos: this.rita.analyzeGrammar(w).pos,\n      })),\n      ...phonetic,\n    ];\n\n    const unique = this.deduplicateAndRank(allAlternatives, word, context);\n\n    return {\n      original: word,\n      currentSyllables,\n      targetSyllables,\n      alternatives: unique.slice(0, 10),\n    };\n  }\n\n  private async searchBySyllables(syllables: number): Promise<AlternativeWord[]> {\n    // ❌ Eliminar pos parameter\n    try {\n      // Búsqueda simple por primera letra y sílabas\n      const results = await this.rita.suggestAlternatives('a', syllables, 8);\n\n      // CORREGIR: results ya son AlternativeWord[], no strings\n      return results.map((altWord) => ({\n        // ✅ altWord es AlternativeWord\n        ...altWord,\n        reason: 'exact-match' as const,\n      }));\n    } catch (error) {\n      console.warn('Search by syllables failed:', error);\n      return [];\n    }\n  }\n\n  private deduplicateAndRank(\n    alternatives: AlternativeWord[],\n    originalWord: string,\n    context: SuggestionContext\n  ): AlternativeWord[] {\n    const seen = new Set<string>();\n    const unique = alternatives.filter((alt) => {\n      const key = alt.word.toLowerCase();\n      if (seen.has(key) || key === originalWord.toLowerCase()) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n\n    return unique.sort((a, b) => {\n      if (a.reason === 'exact-match' && b.reason !== 'exact-match') return -1;\n      if (b.reason === 'exact-match' && a.reason !== 'exact-match') return 1;\n\n      if (context.isLineEnd) {\n        if (a.reason === 'rhyme-match' && b.reason !== 'rhyme-match') return -1;\n        if (b.reason === 'rhyme-match' && a.reason !== 'rhyme-match') return 1;\n      }\n\n      if (context.pos) {\n        const aMatchesPOS = a.pos === context.pos;\n        const bMatchesPOS = b.pos === context.pos;\n        if (aMatchesPOS && !bMatchesPOS) return -1;\n        if (bMatchesPOS && !aMatchesPOS) return 1;\n      }\n\n      return 0;\n    });\n  }\n\n  async getWordAlternatives(word: string, targetSyllables: number): Promise<WordSuggestionData> {\n    return this.getWordAlternativesEnhanced(word, targetSyllables);\n  }\n\n  generateLineSuggestions(line: string, targetSyllables: number): string[] {\n    return this.rita.generateSuggestions(line, targetSyllables);\n  }\n}\n",
            "properties": [
                {
                    "name": "alternatives",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "AlternativeWord[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "currentSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "original",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "targetSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": [],
            "isDuplicate": true,
            "duplicateId": 1,
            "duplicateName": "WordSuggestionData-1"
        }
    ],
    "injectables": [
        {
            "name": "MeterAnalysisService",
            "id": "injectable-MeterAnalysisService-c8ff5e422e8554e34650a202a0a41732300cf56a1ad0853b3fc676499f4c2ce0c687dd9ecb78f3df657e4274fec3fdc34b0adea4b92825d6d4813ddbc9d71d07",
            "file": "src/app/services/poetry/meter-analysis.service.ts",
            "properties": [
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 25,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "classifyStressPattern",
                    "args": [
                        {
                            "name": "stresses",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "MeterType | \"irregular\"",
                    "typeParameters": [],
                    "line": 74,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "stresses",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectMeter",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "MeterAnalysis",
                    "typeParameters": [],
                    "line": 27,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateRhythmSuggestions",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetMeter",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "RhythmSuggestion[]",
                    "typeParameters": [],
                    "line": 111,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetMeter",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getIrregularMeter",
                    "args": [],
                    "optional": false,
                    "returnType": "MeterAnalysis",
                    "typeParameters": [],
                    "line": 178,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "getMeterDescription",
                    "args": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 153,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getMeterExamples",
                    "args": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 164,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getMeterPattern",
                    "args": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 142,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService } from './rita.service';\n\nexport type MeterType = 'iambic' | 'trochaic' | 'anapestic' | 'dactylic' | 'irregular';\n\nexport interface MeterAnalysis {\n  type: MeterType;\n  consistency: number;\n  pattern: string;\n  description: string;\n  examples: string[];\n}\n\nexport interface RhythmSuggestion {\n  line: number;\n  current: string;\n  issue: string;\n  suggestion: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class MeterAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  detectMeter(lines: string[]): MeterAnalysis {\n    const stressPatterns = lines\n      .map((line) => this.rita.analyzeLine(line).stresses)\n      .filter((s) => s && s.length > 0);\n\n    if (stressPatterns.length === 0) {\n      return this.getIrregularMeter();\n    }\n\n    const meterCounts = {\n      iambic: 0,\n      trochaic: 0,\n      anapestic: 0,\n      dactylic: 0,\n    };\n\n    stressPatterns.forEach((pattern) => {\n      const stresses = pattern.split('/').map((s) => parseInt(s));\n      const type = this.classifyStressPattern(stresses);\n      if (type !== 'irregular') {\n        meterCounts[type]++;\n      }\n    });\n\n    const total = stressPatterns.length;\n    const dominant = Object.entries(meterCounts).sort(([, a], [, b]) => b - a)[0];\n\n    if (!dominant) {\n      return this.getIrregularMeter();\n    }\n\n    const [type, count] = dominant as [MeterType, number];\n    const consistency = (count / total) * 100;\n\n    if (consistency < 40) {\n      return this.getIrregularMeter();\n    }\n\n    return {\n      type,\n      consistency,\n      pattern: this.getMeterPattern(type),\n      description: this.getMeterDescription(type),\n      examples: this.getMeterExamples(type),\n    };\n  }\n\n  private classifyStressPattern(stresses: number[]): MeterType | 'irregular' {\n    if (stresses.length < 2) return 'irregular';\n\n    const pairs: string[] = [];\n    for (let i = 0; i < stresses.length - 1; i++) {\n      pairs.push(`${stresses[i]}${stresses[i + 1]}`);\n    }\n\n    const pairCounts = {\n      '01': 0,\n      '10': 0,\n      '001': 0,\n      '100': 0,\n    };\n\n    pairs.forEach((pair) => {\n      if (pair === '01') pairCounts['01']++;\n      if (pair === '10') pairCounts['10']++;\n    });\n\n    for (let i = 0; i < stresses.length - 2; i++) {\n      const triplet = `${stresses[i]}${stresses[i + 1]}${stresses[i + 2]}`;\n      if (triplet === '001') pairCounts['001']++;\n      if (triplet === '100') pairCounts['100']++;\n    }\n\n    const max = Math.max(...Object.values(pairCounts));\n    if (max === 0) return 'irregular';\n\n    if (pairCounts['01'] === max) return 'iambic';\n    if (pairCounts['10'] === max) return 'trochaic';\n    if (pairCounts['001'] === max) return 'anapestic';\n    if (pairCounts['100'] === max) return 'dactylic';\n\n    return 'irregular';\n  }\n\n  generateRhythmSuggestions(lines: string[], targetMeter?: MeterType): RhythmSuggestion[] {\n    const suggestions: RhythmSuggestion[] = [];\n    const detectedMeter = this.detectMeter(lines);\n    const target = targetMeter || detectedMeter.type;\n\n    if (target === 'irregular') {\n      return suggestions;\n    }\n\n    lines.forEach((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      if (!analysis.stresses) return;\n\n      const stresses = analysis.stresses.split('/').map((s) => parseInt(s));\n      const lineType = this.classifyStressPattern(stresses);\n\n      if (lineType !== target) {\n        suggestions.push({\n          line: index + 1,\n          current: analysis.stresses,\n          issue: `This line follows a ${lineType} pattern instead of ${target}`,\n          suggestion: `Try restructuring to match the ${target} rhythm (${this.getMeterPattern(\n            target\n          )})`,\n        });\n      }\n    });\n\n    return suggestions;\n  }\n\n  private getMeterPattern(type: MeterType): string {\n    const patterns: Record<MeterType, string> = {\n      iambic: 'da-DUM (0/1)',\n      trochaic: 'DUM-da (1/0)',\n      anapestic: 'da-da-DUM (0/0/1)',\n      dactylic: 'DUM-da-da (1/0/0)',\n      irregular: 'mixed or free verse',\n    };\n    return patterns[type];\n  }\n\n  private getMeterDescription(type: MeterType): string {\n    const descriptions: Record<MeterType, string> = {\n      iambic: 'Most common in English poetry. Sounds natural and flowing.',\n      trochaic: \"Strong, emphatic rhythm. Common in children's verse.\",\n      anapestic: 'Galloping, energetic rhythm. Creates sense of movement.',\n      dactylic: 'Falling rhythm. Rare in English, common in ancient Greek.',\n      irregular: 'No consistent metrical pattern. Free verse or mixed meters.',\n    };\n    return descriptions[type];\n  }\n\n  private getMeterExamples(type: MeterType): string[] {\n    const examples: Record<MeterType, string[]> = {\n      iambic: [\n        \"Shall I compare thee to a summer's day?\",\n        'The curfew tolls the knell of parting day',\n      ],\n      trochaic: ['Tell me not in mournful numbers', 'Tiger, tiger, burning bright'],\n      anapestic: ['Twas the night before Christmas', 'And the sound of a voice that is still'],\n      dactylic: ['This is the forest primeval', 'Cannon to right of them'],\n      irregular: ['Free verse has no set pattern', 'Modern poetry often breaks rules'],\n    };\n    return examples[type];\n  }\n\n  private getIrregularMeter(): MeterAnalysis {\n    return {\n      type: 'irregular',\n      consistency: 0,\n      pattern: 'mixed or free verse',\n      description:\n        'No consistent metrical pattern detected. This could be free verse or mixed meters.',\n      examples: [],\n    };\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "PoemQualityService",
            "id": "injectable-PoemQualityService-7ce486a65750df1898e54ad355d397e9260f98fe45ae68caa60242e267f5634701e7c08a6a7f0953319376c9e4cf54f03e3ba75dc7c2cb9a7365b440b75ed93d",
            "file": "src/app/services/poetry/poem-quality.service.ts",
            "properties": [
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 24,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "assessQuality",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "QualityMetrics",
                    "typeParameters": [],
                    "line": 26,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "assignGrade",
                    "args": [
                        {
                            "name": "score",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "",
                    "typeParameters": [],
                    "line": 146,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "score",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculatePhoneticRichness",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 56,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculateRhetoricalDevices",
                    "args": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 101,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculateRhythmConsistency",
                    "args": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 86,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculateSyllableAccuracy",
                    "args": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 49,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculateVocabularyDiversity",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 73,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "computeOverallScore",
                    "args": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 132,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "countSensoryWords",
                    "args": [
                        {
                            "name": "words",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 226,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "words",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "identifyStrengths",
                    "args": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 157,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "stressSimilarity",
                    "args": [
                        {
                            "name": "pattern1",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "pattern2",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 213,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "pattern1",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "pattern2",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "suggestImprovements",
                    "args": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 185,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { RitaService } from './rita.service';\nimport type { EnhancedPoetryResult } from './poetry-analyzer.service';\n\nexport interface QualityMetrics {\n  score: number;\n  breakdown: {\n    syllableAccuracy: number;\n    phoneticsRichness: number;\n    vocabularyDiversity: number;\n    rhythmConsistency: number;\n    rhetoricalDevices: number;\n  };\n  strengths: string[];\n  improvements: string[];\n  grade: 'A+' | 'A' | 'B+' | 'B' | 'C+' | 'C' | 'D' | 'F';\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoemQualityService {\n  private readonly rita = inject(RitaService);\n\n  assessQuality(lines: string[], pattern: number[], result: EnhancedPoetryResult): QualityMetrics {\n    const metrics = {\n      syllableAccuracy: this.calculateSyllableAccuracy(result, pattern),\n      phoneticsRichness: this.calculatePhoneticRichness(lines),\n      vocabularyDiversity: this.calculateVocabularyDiversity(lines),\n      rhythmConsistency: this.calculateRhythmConsistency(result),\n      rhetoricalDevices: this.calculateRhetoricalDevices(result),\n    };\n\n    const score = this.computeOverallScore(metrics);\n    const grade = this.assignGrade(score);\n    const strengths = this.identifyStrengths(metrics);\n    const improvements = this.suggestImprovements(metrics);\n\n    return {\n      score,\n      breakdown: metrics,\n      strengths,\n      improvements,\n      grade,\n    };\n  }\n\n  private calculateSyllableAccuracy(result: EnhancedPoetryResult, pattern: number[]): number {\n    if (result.lines.length !== pattern.length) return 0;\n\n    const matches = result.lines.filter((line) => line.match).length;\n    return (matches / pattern.length) * 100;\n  }\n\n  private calculatePhoneticRichness(lines: string[]): number {\n    const text = lines.join(' ');\n    const words = RiTa.tokens(text);\n\n    if (words.length === 0) return 0;\n\n    const uniquePhonemes = new Set<string>();\n    words.forEach((word) => {\n      const phones = RiTa.phones(word);\n      if (phones) {\n        phones.split('-').forEach((p) => uniquePhonemes.add(p));\n      }\n    });\n\n    return Math.min(100, (uniquePhonemes.size / 15) * 100);\n  }\n\n  private calculateVocabularyDiversity(lines: string[]): number {\n    const text = lines.join(' ');\n    const tokens = RiTa.tokenize(text);\n    const words = tokens.filter((t) => !RiTa.isPunct(t));\n\n    if (words.length === 0) return 0;\n\n    const unique = new Set(words.map((w) => w.toLowerCase()));\n    const ttr = unique.size / words.length;\n\n    return Math.min(100, (ttr / 0.6) * 100);\n  }\n\n  private calculateRhythmConsistency(result: EnhancedPoetryResult): number {\n    const stressPatterns = result.lines\n      .map((l) => l.stresses)\n      .filter((s): s is string => s !== undefined && s.length > 0);\n\n    if (stressPatterns.length < 2) return 50;\n\n    const firstPattern = stressPatterns[0];\n    const similarCount = stressPatterns.filter(\n      (p) => this.stressSimilarity(firstPattern, p) > 0.6\n    ).length;\n\n    return (similarCount / stressPatterns.length) * 100;\n  }\n\n  private calculateRhetoricalDevices(result: EnhancedPoetryResult): number {\n    let score = 0;\n\n    if (result.overallAlliterations.length > 0) {\n      score += Math.min(20, result.overallAlliterations.length * 5);\n    }\n\n    if (result.rhymeScheme && result.rhymeScheme !== 'A'.repeat(result.lines.length)) {\n      score += 30;\n    }\n\n    const concordance = RiTa.concordance(result.lines.map((l) => l.text).join(' '));\n    const repeatedWords = Object.values(concordance).filter((count) => count > 1).length;\n    if (repeatedWords > 0) {\n      score += Math.min(20, repeatedWords * 4);\n    }\n\n    const allWords = result.lines.flatMap((l) => l.words);\n    const uniquePOS = new Set(allWords.map((w) => w.pos));\n    if (uniquePOS.size >= 4) {\n      score += 15;\n    }\n\n    const sensoryWords = this.countSensoryWords(allWords.map((w) => w.word));\n    if (sensoryWords >= 3) {\n      score += 15;\n    }\n\n    return Math.min(100, score);\n  }\n\n  private computeOverallScore(metrics: QualityMetrics['breakdown']): number {\n    const weights = {\n      syllableAccuracy: 0.35,\n      phoneticsRichness: 0.15,\n      vocabularyDiversity: 0.2,\n      rhythmConsistency: 0.15,\n      rhetoricalDevices: 0.15,\n    };\n\n    return Object.entries(weights).reduce((total, [key, weight]) => {\n      return total + metrics[key as keyof typeof metrics] * weight;\n    }, 0);\n  }\n\n  private assignGrade(score: number): QualityMetrics['grade'] {\n    if (score >= 95) return 'A+';\n    if (score >= 90) return 'A';\n    if (score >= 85) return 'B+';\n    if (score >= 80) return 'B';\n    if (score >= 75) return 'C+';\n    if (score >= 70) return 'C';\n    if (score >= 60) return 'D';\n    return 'F';\n  }\n\n  private identifyStrengths(metrics: QualityMetrics['breakdown']): string[] {\n    const strengths: string[] = [];\n\n    if (metrics.syllableAccuracy === 100) {\n      strengths.push('Perfect syllable matching');\n    } else if (metrics.syllableAccuracy >= 80) {\n      strengths.push('Good syllable accuracy');\n    }\n\n    if (metrics.phoneticsRichness > 80) {\n      strengths.push('Rich phonetic variety');\n    }\n\n    if (metrics.vocabularyDiversity > 75) {\n      strengths.push('Diverse vocabulary');\n    }\n\n    if (metrics.rhythmConsistency > 80) {\n      strengths.push('Consistent rhythm');\n    }\n\n    if (metrics.rhetoricalDevices > 70) {\n      strengths.push('Strong use of literary devices');\n    }\n\n    return strengths.length > 0 ? strengths : ['Good foundation - keep practicing!'];\n  }\n\n  private suggestImprovements(metrics: QualityMetrics['breakdown']): string[] {\n    const improvements: string[] = [];\n\n    if (metrics.syllableAccuracy < 100) {\n      improvements.push('Adjust syllable counts to match the pattern');\n    }\n\n    if (metrics.phoneticsRichness < 60) {\n      improvements.push('Use more varied sounds and phonemes');\n    }\n\n    if (metrics.vocabularyDiversity < 50) {\n      improvements.push('Avoid repeating the same words');\n    }\n\n    if (metrics.rhythmConsistency < 60) {\n      improvements.push('Create more consistent stress patterns');\n    }\n\n    if (metrics.rhetoricalDevices < 50) {\n      improvements.push('Add alliteration, rhyme, or other literary devices');\n    }\n\n    return improvements.length > 0\n      ? improvements\n      : ['Excellent work! Consider experimenting with more complex forms.'];\n  }\n\n  private stressSimilarity(pattern1: string, pattern2: string): number {\n    const arr1 = pattern1.split('/');\n    const arr2 = pattern2.split('/');\n    const maxLen = Math.max(arr1.length, arr2.length);\n\n    let matches = 0;\n    for (let i = 0; i < maxLen; i++) {\n      if (arr1[i] === arr2[i]) matches++;\n    }\n\n    return matches / maxLen;\n  }\n\n  private countSensoryWords(words: string[]): number {\n    const sensoryPatterns = [\n      /bright|dark|color|hue|shade/i,\n      /loud|quiet|sound|music|voice|echo/i,\n      /soft|hard|smooth|rough|warm|cold/i,\n      /sweet|bitter|fragrant|scent|smell/i,\n      /taste|flavor|savory|delicious/i,\n    ];\n\n    return words.filter((word) => sensoryPatterns.some((pattern) => pattern.test(word))).length;\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "PoetryAnalysisService",
            "id": "injectable-PoetryAnalysisService-87839deece079bc7847173139a67015b54b1d00fdeef757ab3e95c0a0bdf68b78cba002925ff807dfb5be309a363c259bd762ca785914d525a6a44d20747e0bd",
            "file": "src/app/services/poetry/poetry-analysis.service.ts",
            "properties": [
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "analyzePoemStructure",
                    "args": [
                        {
                            "name": "rawLines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "PoetryStructure",
                    "typeParameters": [],
                    "line": 19,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "rawLines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculateSyllableAccuracy",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 71,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectMeterPattern",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 85,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "validateLineSyllables",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "expectedSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "literal type",
                    "typeParameters": [],
                    "line": 60,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "expectedSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService } from './rita.service';\nimport { POETRY_FORMS } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface PoetryStructure {\n  lines: LineAnalysis[];\n  totalLines: { expected: number; actual: number };\n  ok: boolean;\n  summary: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  analyzePoemStructure(rawLines: string[], formKey: string): PoetryStructure {\n    const form = POETRY_FORMS[formKey];\n    if (!form) {\n      throw new Error(`Unknown form \"${formKey}\"`);\n    }\n\n    const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n    const lineAnalyses: LineAnalysis[] = lines.map((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      const expected = form.pattern[index] ?? 0;\n\n      return {\n        text: line,\n        count: analysis.syllables,\n        expected,\n        match: analysis.syllables === expected,\n        syllables: analysis.breakdown,\n        stresses: analysis.stresses,\n      };\n    });\n\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n    const mismatches = lineAnalyses.filter((l) => !l.match).length;\n    const summary = ok\n      ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n          '-'\n        )} pattern`\n      : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n    return {\n      lines: lineAnalyses,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      ok,\n      summary,\n    };\n  }\n\n  validateLineSyllables(\n    line: string,\n    expectedSyllables: number\n  ): { valid: boolean; actual: number } {\n    const analysis = this.rita.analyzeLine(line);\n    return {\n      valid: analysis.syllables === expectedSyllables,\n      actual: analysis.syllables,\n    };\n  }\n\n  calculateSyllableAccuracy(lines: string[], pattern: number[]): number {\n    if (lines.length !== pattern.length) return 0;\n\n    let matches = 0;\n    lines.forEach((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      if (analysis.syllables === pattern[index]) {\n        matches++;\n      }\n    });\n\n    return (matches / pattern.length) * 100;\n  }\n\n  detectMeterPattern(lines: string[]): string[] {\n    const patterns: string[] = [];\n    const stressPatterns = lines\n      .map((line) => {\n        const analysis = this.rita.analyzeLine(line);\n        return analysis.stresses;\n      })\n      .filter((s) => s && s.length > 0);\n\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent meter: ${firstPattern}`);\n      }\n    }\n\n    return patterns;\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "PoetryAnalyzerService",
            "id": "injectable-PoetryAnalyzerService-cc01c88b56c2eb0b88baa736de26edf66653299b14fecfbb0dc7434c68b3977c7f382c4e601296066b01dfe98a03a03a66ecf008c0598e91718873cd4c5aefdb",
            "file": "src/app/services/poetry/poetry-analyzer.service.ts",
            "properties": [
                {
                    "name": "analysis",
                    "defaultValue": "inject(PoetryAnalysisService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 69,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "isLoading",
                    "defaultValue": "signal(false)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 77,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "meterService",
                    "defaultValue": "inject(MeterAnalysisService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 74,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "patterns",
                    "defaultValue": "inject(PoetryPatternsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 71,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "poemText",
                    "defaultValue": "signal<string>('')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 83,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "quality",
                    "defaultValue": "inject(PoemQualityService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 73,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "qualityMetrics",
                    "defaultValue": "signal<QualityMetrics | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 81,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "result",
                    "defaultValue": "signal<EnhancedPoetryResult | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 78,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "rhymes",
                    "defaultValue": "inject(RhymeAnalysisService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 72,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "rhythmSuggestions",
                    "defaultValue": "signal<RhythmSuggestion[]>([])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 84,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 75,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "selectedForm",
                    "defaultValue": "signal<string>('haiku')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 82,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "selectedWord",
                    "defaultValue": "signal<string | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 79,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "suggestions",
                    "defaultValue": "inject(PoetrySuggestionsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 70,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "wordAlternatives",
                    "defaultValue": "signal<WordSuggestionData | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 80,
                    "modifierKind": [
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "analyze",
                    "args": [
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "rawLines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<EnhancedPoetryResult>",
                    "typeParameters": [],
                    "line": 86,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "rawLines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "assessQuality",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 275,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "clear",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 300,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "createResultForQualityAssessment",
                    "args": [
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "lineAnalyses",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "EnhancedPoetryResult",
                    "typeParameters": [],
                    "line": 460,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "lineAnalyses",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectPatterns",
                    "args": [
                        {
                            "name": "lines",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 309,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateEnhancedSuggestions",
                    "args": [
                        {
                            "name": "lineAnalyses",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "meterAnalysis",
                            "type": "MeterAnalysis",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 383,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "lineAnalyses",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "meterAnalysis",
                            "type": "MeterAnalysis",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateMeterPatterns",
                    "args": [
                        {
                            "name": "meter",
                            "type": "MeterAnalysis",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 367,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "meter",
                            "type": "MeterAnalysis",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getPreviousWord",
                    "args": [
                        {
                            "name": "words",
                            "type": "literal type[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "currentWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string | undefined",
                    "typeParameters": [],
                    "line": 455,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "words",
                            "type": "literal type[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "currentWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getQuickStats",
                    "args": [],
                    "optional": false,
                    "returnType": "literal type",
                    "typeParameters": [],
                    "line": 491,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "isCompletePoem",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 482,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "loadExample",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 265,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "replaceWord",
                    "args": [
                        {
                            "name": "oldWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "newWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 286,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "oldWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "newWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "selectWord",
                    "args": [
                        {
                            "name": "word",
                            "type": "string | null",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 228,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string | null",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "selectWordEnhanced",
                    "args": [
                        {
                            "name": "word",
                            "type": "string | null",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 186,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string | null",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject, signal } from '@angular/core';\nimport { PoetryAnalysisService } from './poetry-analysis.service';\nimport { PoetrySuggestionsService } from './poetry-suggestions.service';\nimport { PoetryPatternsService } from './poetry-patterns.service';\nimport { RhymeAnalysisService } from './rhyme-analysis.service';\nimport { PoemQualityService, type QualityMetrics } from './poem-quality.service';\nimport {\n  MeterAnalysisService,\n  type MeterAnalysis,\n  type RhythmSuggestion,\n} from './meter-analysis.service';\nimport {\n  RitaService,\n  type GrammaticalAnalysis,\n  type AlliterationMatch,\n  type AlternativeWord,\n} from './rita.service';\nimport { POETRY_FORMS, POETRY_EXAMPLES } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface EnhancedLineAnalysis extends LineAnalysis {\n  words: {\n    word: string;\n    syllables: number;\n    pos: string;\n    phones: string;\n    grammar?: GrammaticalAnalysis;\n  }[];\n  alliterations?: AlliterationMatch[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n}\n\nexport interface EnhancedPoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: EnhancedLineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n  overallAlliterations: AlliterationMatch[];\n  detectedPatterns: string[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n  meterAnalysis?: MeterAnalysis;\n}\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalyzerService {\n  private readonly analysis = inject(PoetryAnalysisService);\n  private readonly suggestions = inject(PoetrySuggestionsService);\n  private readonly patterns = inject(PoetryPatternsService);\n  private readonly rhymes = inject(RhymeAnalysisService);\n  private readonly quality = inject(PoemQualityService);\n  private readonly meterService = inject(MeterAnalysisService);\n  private readonly rita = inject(RitaService);\n\n  readonly isLoading = signal(false);\n  readonly result = signal<EnhancedPoetryResult | null>(null);\n  readonly selectedWord = signal<string | null>(null);\n  readonly wordAlternatives = signal<WordSuggestionData | null>(null);\n  readonly qualityMetrics = signal<QualityMetrics | null>(null);\n  readonly selectedForm = signal<string>('haiku');\n  readonly poemText = signal<string>('');\n  readonly rhythmSuggestions = signal<RhythmSuggestion[]>([]);\n\n  async analyze(formKey: string, rawLines: string[]): Promise<EnhancedPoetryResult> {\n    this.isLoading.set(true);\n\n    try {\n      const form = POETRY_FORMS[formKey];\n      if (!form) {\n        throw new Error(`Unknown form \"${formKey}\"`);\n      }\n\n      const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n      // Análisis dinámico basado en el poema actual\n      const typos = await this.rita.detectTypos(lines);\n      const meterAnalysis = this.meterService.detectMeter(lines);\n      const rhythmSuggestions = this.meterService.generateRhythmSuggestions(\n        lines,\n        meterAnalysis.type\n      );\n      this.rhythmSuggestions.set(rhythmSuggestions);\n\n      const lineAnalyses: EnhancedLineAnalysis[] = await Promise.all(\n        lines.map(async (line, index) => {\n          const analysis = this.rita.analyzeLine(line);\n          const words = this.rita.analyzeWords(line);\n          const alliterations = this.rita.detectAlliterations(line);\n          const expected = form.pattern[index] ?? 0;\n\n          const wordsWithGrammar = words.map((word) => ({\n            ...word,\n            grammar: this.rita.analyzeGrammar(word.word),\n          }));\n\n          return {\n            text: line,\n            count: analysis.syllables,\n            expected,\n            match: analysis.syllables === expected,\n            syllables: analysis.breakdown,\n            stresses: analysis.stresses,\n            words: wordsWithGrammar,\n            alliterations: alliterations.length > 0 ? alliterations : undefined,\n            typos: typos.filter((t) => t.line === index),\n          };\n        })\n      );\n\n      // Calcular calidad basada en el poema actual\n      const quality = this.quality.assessQuality(\n        lines,\n        form.pattern,\n        this.createResultForQualityAssessment(formKey, lineAnalyses)\n      );\n\n      const overallAlliterations = this.rhymes.detectCrossLineAlliterations(lines);\n      const detectedPatterns = [\n        ...this.detectPatterns(lineAnalyses),\n        ...this.generateMeterPatterns(meterAnalysis),\n      ];\n\n      const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n      const mismatches = lineAnalyses.filter((l) => !l.match).length;\n      const summary = ok\n        ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n            '-'\n          )} pattern`\n        : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n      const suggestions = this.generateEnhancedSuggestions(\n        lineAnalyses,\n        form.pattern,\n        meterAnalysis\n      );\n      const rhymeScheme = lines.length > 1 ? this.rita.analyzeRhymeScheme(lines) : undefined;\n\n      const result: EnhancedPoetryResult = {\n        ok,\n        form: formKey,\n        totalLines: {\n          expected: form.pattern.length,\n          actual: lineAnalyses.length,\n        },\n        lines: lineAnalyses,\n        summary,\n        rhymeScheme,\n        suggestions,\n        overallAlliterations,\n        detectedPatterns,\n        typos: typos.length > 0 ? typos : undefined,\n        meterAnalysis,\n      };\n\n      this.result.set(result);\n      this.qualityMetrics.set(quality);\n      return result;\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  async selectWordEnhanced(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) return;\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.suggestions.getWordAlternativesEnhanced(\n              word,\n              neededSyllables,\n              {\n                pos: wordAnalysis.pos,\n                lineIndex: result.lines.indexOf(line),\n                isLineEnd: line.words[line.words.length - 1]?.word === word,\n                previousWord: this.getPreviousWord(line.words, word),\n              }\n            );\n\n            this.wordAlternatives.set(alternatives);\n          } catch (error) {\n            console.warn('Error getting enhanced alternatives:', error);\n            await this.selectWord(word);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  async selectWord(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) {\n      return;\n    }\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.rita.suggestAlternatives(word, neededSyllables, 8);\n            this.wordAlternatives.set({\n              original: word,\n              currentSyllables: wordAnalysis.syllables,\n              targetSyllables: neededSyllables,\n              alternatives,\n            });\n          } catch (error) {\n            console.warn('Error getting word alternatives:', error);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  loadExample(): void {\n    const formId = this.selectedForm();\n    const example = POETRY_EXAMPLES[formId];\n    if (example) {\n      this.poemText.set(example.join('\\n'));\n      // Analizar automáticamente el ejemplo cargado\n      this.analyze(formId, example);\n    }\n  }\n\n  assessQuality(): void {\n    const result = this.result();\n    if (!result) return;\n\n    const lines = result.lines.map((l) => l.text);\n    const pattern = POETRY_FORMS[result.form].pattern;\n\n    const metrics = this.quality.assessQuality(lines, pattern, result);\n    this.qualityMetrics.set(metrics);\n  }\n\n  replaceWord(oldWord: string, newWord: string): void {\n    const result = this.result();\n    if (!result) return;\n\n    const updatedLines = result.lines.map((line) => {\n      const updatedText = line.text.replace(new RegExp(`\\\\b${oldWord}\\\\b`, 'gi'), newWord);\n      return updatedText;\n    });\n\n    this.poemText.set(updatedLines.join('\\n'));\n    this.analyze(result.form, updatedLines);\n    this.selectWordEnhanced(null);\n  }\n\n  clear(): void {\n    this.result.set(null);\n    this.selectedWord.set(null);\n    this.wordAlternatives.set(null);\n    this.qualityMetrics.set(null);\n    this.rhythmSuggestions.set([]);\n    this.poemText.set('');\n  }\n\n  private detectPatterns(lines: EnhancedLineAnalysis[]): string[] {\n    const patterns: string[] = [];\n\n    // Detectar patrones basados en el análisis real\n    const stressPatterns = lines.map((l) => l.stresses).filter((s) => s);\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent stress pattern: ${firstPattern}`);\n      }\n    }\n\n    // Detectar aliteraciones en el poema actual\n    const linesWithAlliteration = lines.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length > 0) {\n      patterns.push(\n        `${linesWithAlliteration.length} line${\n          linesWithAlliteration.length > 1 ? 's' : ''\n        } contain alliteration`\n      );\n    }\n\n    // Análisis de vocabulario del poema actual\n    const allWords = lines.flatMap((l) => l.words);\n    const nouns = allWords.filter((w) => w.pos.startsWith('nn')).length;\n    const verbs = allWords.filter((w) => w.pos.startsWith('vb')).length;\n    const adjectives = allWords.filter((w) => w.pos.startsWith('jj')).length;\n    const adverbs = allWords.filter((w) => w.pos.startsWith('rb')).length;\n\n    if (nouns > verbs * 2) {\n      patterns.push('Noun-heavy composition (descriptive style)');\n    } else if (verbs > nouns * 1.5) {\n      patterns.push('Verb-heavy composition (active style)');\n    }\n\n    if (adjectives > allWords.length * 0.2) {\n      patterns.push('High use of adjectives (vivid imagery)');\n    }\n\n    if (adverbs > allWords.length * 0.15) {\n      patterns.push('Adverb-rich language (detailed action)');\n    }\n\n    // Análisis de longitud de palabras\n    const avgWordLength =\n      allWords.reduce((sum, w) => sum + w.word.length, 0) / (allWords.length || 1);\n    if (avgWordLength > 6) {\n      patterns.push('Complex vocabulary (long words)');\n    } else if (avgWordLength < 4) {\n      patterns.push('Simple vocabulary (short words)');\n    }\n\n    return patterns;\n  }\n\n  private generateMeterPatterns(meter: MeterAnalysis): string[] {\n    const patterns: string[] = [];\n\n    if (meter.consistency > 70) {\n      patterns.push(`Strong ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    } else if (meter.consistency > 40) {\n      patterns.push(`Emerging ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    }\n\n    if (meter.type !== 'irregular') {\n      patterns.push(`Meter: ${meter.pattern}`);\n    }\n\n    return patterns;\n  }\n\n  private generateEnhancedSuggestions(\n    lineAnalyses: EnhancedLineAnalysis[],\n    pattern: number[],\n    meterAnalysis: MeterAnalysis\n  ): string[] {\n    const suggestions: string[] = [];\n\n    // Sugerencias basadas en la estructura del poema actual\n    if (lineAnalyses.length < pattern.length) {\n      const missing = pattern.length - lineAnalyses.length;\n      suggestions.push(`Add ${missing} more line${missing > 1 ? 's' : ''} to complete the pattern`);\n    } else if (lineAnalyses.length > pattern.length) {\n      const extra = lineAnalyses.length - pattern.length;\n      suggestions.push(`Remove ${extra} line${extra > 1 ? 's' : ''} to match the pattern`);\n    }\n\n    // Sugerencias rítmicas basadas en el análisis métrico\n    if (meterAnalysis.consistency < 60) {\n      suggestions.push(\n        `Improve rhythm consistency: ${meterAnalysis.type} meter detected but inconsistent`\n      );\n    }\n\n    if (meterAnalysis.type === 'irregular' && lineAnalyses.length > 2) {\n      suggestions.push('Consider using a regular meter pattern for better poetic flow');\n    }\n\n    // Sugerencias específicas por línea\n    lineAnalyses.forEach((line, index) => {\n      if (!line.match && index < pattern.length) {\n        const lineSuggestions = this.rita.generateSuggestions(line.text, pattern[index]);\n        suggestions.push(`Line ${index + 1}: ${lineSuggestions[0]}`);\n\n        const diff = pattern[index] - line.count;\n        if (diff > 0) {\n          const shortWords = line.words.filter((w) => w.syllables === 1);\n          if (shortWords.length > 0) {\n            suggestions.push(`  → Try replacing \"${shortWords[0].word}\" with a longer synonym`);\n          }\n        } else if (diff < 0) {\n          const longWords = line.words\n            .filter((w) => w.syllables > 2)\n            .sort((a, b) => b.syllables - a.syllables);\n          if (longWords.length > 0) {\n            suggestions.push(\n              `  → Try replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter word`\n            );\n          }\n        }\n      }\n    });\n\n    // Sugerencias de dispositivos literarios\n    const linesWithAlliteration = lineAnalyses.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length === 0 && lineAnalyses.length > 2) {\n      suggestions.push('Consider adding alliteration for poetic effect');\n    }\n\n    const hasRhyme = lineAnalyses.some((line) =>\n      line.words.some(\n        (word) => (word.pos && word.pos.startsWith('nn')) || word.pos.startsWith('vb')\n      )\n    );\n    if (!hasRhyme && lineAnalyses.length > 1) {\n      suggestions.push('Try incorporating rhyme for musical quality');\n    }\n\n    return suggestions.slice(0, 6);\n  }\n\n  private getPreviousWord(words: { word: string }[], currentWord: string): string | undefined {\n    const currentIndex = words.findIndex((w) => w.word.toLowerCase() === currentWord.toLowerCase());\n    return currentIndex > 0 ? words[currentIndex - 1].word : undefined;\n  }\n\n  private createResultForQualityAssessment(\n    formKey: string,\n    lineAnalyses: EnhancedLineAnalysis[]\n  ): EnhancedPoetryResult {\n    const form = POETRY_FORMS[formKey];\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n    return {\n      ok,\n      form: formKey,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      lines: lineAnalyses,\n      summary: '',\n      suggestions: [],\n      overallAlliterations: [],\n      detectedPatterns: [],\n    };\n  }\n\n  isCompletePoem(): boolean {\n    const result = this.result();\n    if (!result) return false;\n\n    return (\n      result.lines.length === result.totalLines.expected && result.lines.every((line) => line.match)\n    );\n  }\n\n  getQuickStats(): {\n    totalSyllables: number;\n    avgSyllablesPerLine: number;\n    vocabularyRichness: number;\n  } {\n    const result = this.result();\n    if (!result || result.lines.length === 0) {\n      return { totalSyllables: 0, avgSyllablesPerLine: 0, vocabularyRichness: 0 };\n    }\n\n    const totalSyllables = result.lines.reduce((sum, line) => sum + line.count, 0);\n    const avgSyllablesPerLine = totalSyllables / result.lines.length;\n\n    const allWords = result.lines.flatMap((line) => line.words.map((w) => w.word.toLowerCase()));\n    const uniqueWords = new Set(allWords);\n    const vocabularyRichness = (uniqueWords.size / allWords.length) * 100;\n\n    return {\n      totalSyllables,\n      avgSyllablesPerLine: Math.round(avgSyllablesPerLine * 10) / 10,\n      vocabularyRichness: Math.round(vocabularyRichness * 10) / 10,\n    };\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "PoetryPatternsService",
            "id": "injectable-PoetryPatternsService-80b0cf2d8c512fa3d287dcf6c2c96e860136e9c66d1f6e82cb0d45daeff632996b97a6abb3d5c058c7715e20051557c5974bec052e4c26a8d90bee1cedbfa98b",
            "file": "src/app/services/poetry/poetry-patterns.service.ts",
            "properties": [
                {
                    "name": "forms",
                    "defaultValue": "POETRY_FORMS",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "detectPossibleForms",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 27,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getAllForms",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 18,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getFormInfo",
                    "args": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 14,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getFormOptions",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 40,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getFormPattern",
                    "args": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number[]",
                    "typeParameters": [],
                    "line": 10,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "validateFormCompatibility",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 22,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable } from '@angular/core';\nimport { POETRY_FORMS } from '../../data/poetry-forms.data';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryPatternsService {\n  private readonly forms = POETRY_FORMS;\n\n  getFormPattern(formId: string): number[] {\n    return this.forms[formId]?.pattern || [];\n  }\n\n  getFormInfo(formId: string) {\n    return this.forms[formId];\n  }\n\n  getAllForms() {\n    return Object.values(this.forms);\n  }\n\n  validateFormCompatibility(lines: string[], formId: string): boolean {\n    const pattern = this.getFormPattern(formId);\n    return lines.length === pattern.length;\n  }\n\n  detectPossibleForms(lines: string[]): string[] {\n    const possibleForms: string[] = [];\n    const lineCount = lines.length;\n\n    Object.entries(this.forms).forEach(([formId, form]) => {\n      if (form.lines === lineCount) {\n        possibleForms.push(formId);\n      }\n    });\n\n    return possibleForms;\n  }\n\n  getFormOptions() {\n    return Object.values(this.forms).map((form) => ({\n      value: form.id,\n      label: form.name,\n      description: form.pattern.join('-'),\n    }));\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "PoetrySuggestionsService",
            "id": "injectable-PoetrySuggestionsService-24eb12fada130bc88b863f4d93cc015155ad8963e6b439cd89626c34ffadb8c508817746d6d4f5f7e11b910ca3bb30339b231a1a9016833254b2677222c8462e",
            "file": "src/app/services/poetry/poetry-suggestions.service.ts",
            "properties": [
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "deduplicateAndRank",
                    "args": [
                        {
                            "name": "alternatives",
                            "type": "AlternativeWord[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "originalWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "context",
                            "type": "SuggestionContext",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "AlternativeWord[]",
                    "typeParameters": [],
                    "line": 79,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "alternatives",
                            "type": "AlternativeWord[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "originalWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "context",
                            "type": "SuggestionContext",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateLineSuggestions",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 118,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getWordAlternatives",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<WordSuggestionData>",
                    "typeParameters": [],
                    "line": 114,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getWordAlternativesEnhanced",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "context",
                            "type": "SuggestionContext",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "{}"
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<WordSuggestionData>",
                    "typeParameters": [],
                    "line": 24,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "context",
                            "type": "SuggestionContext",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "{}",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "searchBySyllables",
                    "args": [
                        {
                            "name": "syllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<AlternativeWord[]>",
                    "typeParameters": [],
                    "line": 61,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "syllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService, type AlternativeWord } from './rita.service';\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\nexport interface SuggestionContext {\n  pos?: string;\n  lineIndex?: number;\n  isLineEnd?: boolean;\n  previousWord?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetrySuggestionsService {\n  private readonly rita = inject(RitaService);\n\n  async getWordAlternativesEnhanced(\n    word: string,\n    targetSyllables: number,\n    context: SuggestionContext = {}\n  ): Promise<WordSuggestionData> {\n    const currentSyllables = this.rita.analyzeLine(word).syllables;\n\n    // Búsqueda simple y efectiva - CORREGIR parámetros\n    const [exactMatches, rhymes, phonetic] = await Promise.all([\n      this.searchBySyllables(targetSyllables), // ❌ Eliminar context.pos\n      context.isLineEnd\n        ? this.rita.findRhymes(word, targetSyllables).then((r) => r.perfectRhymes)\n        : Promise.resolve([]),\n      this.rita.suggestAlternatives(word, targetSyllables, 6),\n    ]);\n\n    const allAlternatives = [\n      ...exactMatches,\n      ...rhymes.map((w) => ({\n        word: w, // ✅ w es string, no AlternativeWord\n        syllables: targetSyllables,\n        reason: 'rhyme-match' as const,\n        pos: this.rita.analyzeGrammar(w).pos,\n      })),\n      ...phonetic,\n    ];\n\n    const unique = this.deduplicateAndRank(allAlternatives, word, context);\n\n    return {\n      original: word,\n      currentSyllables,\n      targetSyllables,\n      alternatives: unique.slice(0, 10),\n    };\n  }\n\n  private async searchBySyllables(syllables: number): Promise<AlternativeWord[]> {\n    // ❌ Eliminar pos parameter\n    try {\n      // Búsqueda simple por primera letra y sílabas\n      const results = await this.rita.suggestAlternatives('a', syllables, 8);\n\n      // CORREGIR: results ya son AlternativeWord[], no strings\n      return results.map((altWord) => ({\n        // ✅ altWord es AlternativeWord\n        ...altWord,\n        reason: 'exact-match' as const,\n      }));\n    } catch (error) {\n      console.warn('Search by syllables failed:', error);\n      return [];\n    }\n  }\n\n  private deduplicateAndRank(\n    alternatives: AlternativeWord[],\n    originalWord: string,\n    context: SuggestionContext\n  ): AlternativeWord[] {\n    const seen = new Set<string>();\n    const unique = alternatives.filter((alt) => {\n      const key = alt.word.toLowerCase();\n      if (seen.has(key) || key === originalWord.toLowerCase()) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n\n    return unique.sort((a, b) => {\n      if (a.reason === 'exact-match' && b.reason !== 'exact-match') return -1;\n      if (b.reason === 'exact-match' && a.reason !== 'exact-match') return 1;\n\n      if (context.isLineEnd) {\n        if (a.reason === 'rhyme-match' && b.reason !== 'rhyme-match') return -1;\n        if (b.reason === 'rhyme-match' && a.reason !== 'rhyme-match') return 1;\n      }\n\n      if (context.pos) {\n        const aMatchesPOS = a.pos === context.pos;\n        const bMatchesPOS = b.pos === context.pos;\n        if (aMatchesPOS && !bMatchesPOS) return -1;\n        if (bMatchesPOS && !aMatchesPOS) return 1;\n      }\n\n      return 0;\n    });\n  }\n\n  async getWordAlternatives(word: string, targetSyllables: number): Promise<WordSuggestionData> {\n    return this.getWordAlternativesEnhanced(word, targetSyllables);\n  }\n\n  generateLineSuggestions(line: string, targetSyllables: number): string[] {\n    return this.rita.generateSuggestions(line, targetSyllables);\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "RhymeAnalysisService",
            "id": "injectable-RhymeAnalysisService-41d23a934805c1e0266376535441a4f68f9177e738b5b3e6b11525f00a5d9a79108b602cc51de2ccb1b0f714769ed493952a29943cf3d4829715050ceb17ced6",
            "file": "src/app/services/poetry/rhyme-analysis.service.ts",
            "properties": [
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "analyzeRhymeScheme",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 10,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectCrossLineAlliterations",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "AlliterationMatch[]",
                    "typeParameters": [],
                    "line": 14,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectRhymePattern",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "literal type",
                    "typeParameters": [],
                    "line": 58,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService, type AlliterationMatch } from './rita.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RhymeAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  analyzeRhymeScheme(lines: string[]): string {\n    return this.rita.analyzeRhymeScheme(lines);\n  }\n\n  detectCrossLineAlliterations(lines: string[]): AlliterationMatch[] {\n    const allWords: { word: string; lineIndex: number; wordIndex: number }[] = [];\n\n    lines.forEach((line, lineIndex) => {\n      const words = line.split(/\\s+/).filter((w) => /[a-zA-Z]/.test(w));\n      words.forEach((word, wordIndex) => {\n        allWords.push({ word, lineIndex, wordIndex });\n      });\n    });\n\n    const crossLineAlliterations: AlliterationMatch[] = [];\n    const processed = new Set<number>();\n\n    for (let i = 0; i < allWords.length - 1; i++) {\n      if (processed.has(i)) continue;\n\n      const matchingWords: string[] = [allWords[i].word];\n      const positions: number[] = [i];\n\n      for (let j = i + 1; j < allWords.length && j < i + 10; j++) {\n        try {\n          if (this.rita.isRhyme(allWords[i].word, allWords[j].word)) {\n            matchingWords.push(allWords[j].word);\n            positions.push(j);\n            processed.add(j);\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      if (matchingWords.length > 2) {\n        crossLineAlliterations.push({\n          words: matchingWords,\n          positions,\n          sound: matchingWords[0][0],\n        });\n        processed.add(i);\n      }\n    }\n\n    return crossLineAlliterations;\n  }\n\n  detectRhymePattern(lines: string[]): { scheme: string; consistency: number } {\n    const scheme = this.analyzeRhymeScheme(lines);\n    const uniqueRhymes = new Set(scheme.split(''));\n    const consistency = uniqueRhymes.size / scheme.length;\n\n    return { scheme, consistency };\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "RitaService",
            "id": "injectable-RitaService-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "properties": [
                {
                    "name": "cache",
                    "defaultValue": "new Map<string, SyllableAnalysis>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 73,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "utils",
                    "defaultValue": "inject(UtilsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 74,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "analyzeGrammar",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "GrammaticalAnalysis",
                    "typeParameters": [],
                    "line": 397,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "analyzeLine",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "SyllableAnalysis",
                    "typeParameters": [],
                    "line": 76,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "analyzeRhymeScheme",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 329,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "analyzeWords",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "WordAnalysis[]",
                    "typeParameters": [],
                    "line": 126,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "clearCache",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 466,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "detectAlliterations",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "AlliterationMatch[]",
                    "typeParameters": [],
                    "line": 238,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectTypos",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<literal type[]>",
                    "typeParameters": [],
                    "line": 427,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "findRhymes",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<RhymeMatch>",
                    "typeParameters": [],
                    "line": 274,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateSuggestions",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 356,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getLastWord",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 461,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isRhyme",
                    "args": [
                        {
                            "name": "word1",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "word2",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 321,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "word1",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "word2",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "suggestAlternatives",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "maxResults",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "10"
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<AlternativeWord[]>",
                    "typeParameters": [],
                    "line": 146,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "maxResults",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "10",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "StateService",
            "id": "injectable-StateService-2e75f793629fe1f134898f8cd74c219b287af02b59dfccb819e2b15e510c6a60ca3bbe47742bfbaa5833325ff4252635e5394fca8a1da7d2354e360dd84e78a9",
            "file": "src/app/services/core/state.service.ts",
            "properties": [
                {
                    "name": "currentForm",
                    "defaultValue": "computed(() => POETRY_FORMS[this.selectedForm()])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 32,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "currentPattern",
                    "defaultValue": "computed(() => this.currentForm()?.pattern || [])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 33,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "expectedLines",
                    "defaultValue": "computed(() => this.currentForm()?.lines || 3)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 34,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "hasResults",
                    "defaultValue": "computed(() => this.state().hasResults)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 30,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "isAnalyzing",
                    "defaultValue": "computed(() => this.state().isAnalyzing)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 29,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "isUpdatingFromInternal",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 24,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "lastLoadedForm",
                    "defaultValue": "null",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 25,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "lines",
                    "defaultValue": "computed(() =>\n    this.poemText()\n      .split('\\n')\n      .slice(0, this.expectedLines())\n      .filter((line) => line.trim().length > 0)\n  )",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 36,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "poemText",
                    "defaultValue": "computed(() => this.state().poemText)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 28,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "selectedForm",
                    "defaultValue": "computed(() => this.state().selectedForm)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 27,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "shouldLoadExample",
                    "defaultValue": "computed(() => this.state().shouldLoadExample)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 31,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "state",
                    "defaultValue": "signal<AppState>({\n    selectedForm: 'haiku',\n    poemText: '',\n    isAnalyzing: false,\n    hasResults: false,\n    shouldLoadExample: false,\n  })",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "clear",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 102,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "consumeLoadExample",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 122,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "loadExample",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 88,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "setHasResults",
                    "args": [
                        {
                            "name": "hasResults",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 84,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "hasResults",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setIsAnalyzing",
                    "args": [
                        {
                            "name": "analyzing",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 80,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "analyzing",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setPoemText",
                    "args": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 68,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setSelectedForm",
                    "args": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 43,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "updatePoemLines",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 117,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, signal, computed } from '@angular/core';\nimport { POETRY_FORMS, POETRY_EXAMPLES } from '../../data/poetry-forms.data';\n\nexport interface AppState {\n  selectedForm: string;\n  poemText: string;\n  isAnalyzing: boolean;\n  hasResults: boolean;\n  shouldLoadExample: boolean;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class StateService {\n  private readonly state = signal<AppState>({\n    selectedForm: 'haiku',\n    poemText: '',\n    isAnalyzing: false,\n    hasResults: false,\n    shouldLoadExample: false,\n  });\n\n  private isUpdatingFromInternal = false;\n  private lastLoadedForm: string | null = null;\n\n  readonly selectedForm = computed(() => this.state().selectedForm);\n  readonly poemText = computed(() => this.state().poemText);\n  readonly isAnalyzing = computed(() => this.state().isAnalyzing);\n  readonly hasResults = computed(() => this.state().hasResults);\n  readonly shouldLoadExample = computed(() => this.state().shouldLoadExample);\n  readonly currentForm = computed(() => POETRY_FORMS[this.selectedForm()]);\n  readonly currentPattern = computed(() => this.currentForm()?.pattern || []);\n  readonly expectedLines = computed(() => this.currentForm()?.lines || 3);\n\n  readonly lines = computed(() =>\n    this.poemText()\n      .split('\\n')\n      .slice(0, this.expectedLines())\n      .filter((line) => line.trim().length > 0)\n  );\n\n  setSelectedForm(formId: string): void {\n    if (this.isUpdatingFromInternal || this.state().selectedForm === formId) {\n      return;\n    }\n\n    this.isUpdatingFromInternal = true;\n\n    const currentText = this.state().poemText.trim();\n    const hasContent = currentText.length > 0;\n\n    const shouldLoadNewExample = !hasContent || this.lastLoadedForm !== formId;\n\n    this.state.update((state) => ({\n      ...state,\n      selectedForm: formId,\n      shouldLoadExample: shouldLoadNewExample,\n    }));\n\n    this.lastLoadedForm = null;\n\n    setTimeout(() => {\n      this.isUpdatingFromInternal = false;\n    }, 10);\n  }\n\n  setPoemText(text: string): void {\n    this.isUpdatingFromInternal = true;\n    this.state.update((state) => ({\n      ...state,\n      poemText: text,\n      shouldLoadExample: false,\n    }));\n    setTimeout(() => {\n      this.isUpdatingFromInternal = false;\n    }, 0);\n  }\n\n  setIsAnalyzing(analyzing: boolean): void {\n    this.state.update((state) => ({ ...state, isAnalyzing: analyzing }));\n  }\n\n  setHasResults(hasResults: boolean): void {\n    this.state.update((state) => ({ ...state, hasResults }));\n  }\n\n  loadExample(): void {\n    const formId = this.selectedForm();\n    const example = POETRY_EXAMPLES[formId];\n    if (example) {\n      this.setPoemText(example.join('\\n'));\n      this.state.update((state) => ({\n        ...state,\n        shouldLoadExample: false,\n      }));\n\n      this.lastLoadedForm = formId;\n    }\n  }\n\n  clear(): void {\n    this.isUpdatingFromInternal = true;\n    this.state.update((state) => ({\n      ...state,\n      poemText: '',\n      hasResults: false,\n      shouldLoadExample: false,\n    }));\n\n    this.lastLoadedForm = null;\n    setTimeout(() => {\n      this.isUpdatingFromInternal = false;\n    }, 0);\n  }\n\n  updatePoemLines(lines: string[]): void {\n    const text = lines.join('\\n');\n    this.setPoemText(text);\n  }\n\n  consumeLoadExample(): void {\n    this.state.update((state) => ({\n      ...state,\n      shouldLoadExample: false,\n    }));\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "ThemeService",
            "id": "injectable-ThemeService-eb0a14693c99d5a747e1b15c8801151fe40229ec9c63b60b26b5aaae24252d941375e426f3836e3816b01f27e79a6fead9ac2666a47f86b491549df40bb3a721",
            "file": "src/app/services/core/theme.service.ts",
            "properties": [
                {
                    "name": "currentTheme",
                    "defaultValue": "signal<Theme>(this.getInitialTheme())",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 11,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "THEME_KEY",
                    "defaultValue": "'app-theme'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 9,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "applyTheme",
                    "args": [
                        {
                            "name": "theme",
                            "type": "Theme",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 32,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "theme",
                            "type": "Theme",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getInitialTheme",
                    "args": [],
                    "optional": false,
                    "returnType": "Theme",
                    "typeParameters": [],
                    "line": 19,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "setTheme",
                    "args": [
                        {
                            "name": "theme",
                            "type": "Theme",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 41,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "theme",
                            "type": "Theme",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "toggleTheme",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 37,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, signal, effect } from '@angular/core';\n\nexport type Theme = 'light' | 'dark';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class ThemeService {\n  private readonly THEME_KEY = 'app-theme';\n\n  readonly currentTheme = signal<Theme>(this.getInitialTheme());\n\n  constructor() {\n    effect(() => {\n      this.applyTheme(this.currentTheme());\n    });\n  }\n\n  private getInitialTheme(): Theme {\n    const stored = localStorage.getItem(this.THEME_KEY) as Theme | null;\n    if (stored === 'light' || stored === 'dark') {\n      return stored;\n    }\n\n    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {\n      return 'dark';\n    }\n\n    return 'light';\n  }\n\n  private applyTheme(theme: Theme): void {\n    document.documentElement.setAttribute('data-theme', theme);\n    localStorage.setItem(this.THEME_KEY, theme);\n  }\n\n  toggleTheme(): void {\n    this.currentTheme.update((current) => (current === 'light' ? 'dark' : 'light'));\n  }\n\n  setTheme(theme: Theme): void {\n    this.currentTheme.set(theme);\n  }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 11
            },
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "ToastService",
            "id": "injectable-ToastService-205f8fc4fe55ff61e7a3cf41dd3a9d73f11125462cf7913be0245820b502a81c21aa52c8693e3125c6a9cacd729836a9ad71c7771ba8cb8c9178a57c63c1e422",
            "file": "src/app/services/core/toast.service.ts",
            "properties": [
                {
                    "name": "toasts",
                    "defaultValue": "signal<Toast[]>([])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 14,
                    "modifierKind": [
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "error",
                    "args": [
                        {
                            "name": "title",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 35,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "title",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "info",
                    "args": [
                        {
                            "name": "title",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 39,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "title",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "remove",
                    "args": [
                        {
                            "name": "id",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 27,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "show",
                    "args": [
                        {
                            "name": "toast",
                            "type": "Omit<Toast | id>",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 16,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "toast",
                            "type": "Omit<Toast | id>",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "success",
                    "args": [
                        {
                            "name": "title",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 31,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "title",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "warning",
                    "args": [
                        {
                            "name": "title",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 43,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "title",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, signal } from '@angular/core';\n\nexport interface Toast {\n  id: string;\n  title: string;\n  message?: string;\n  type: 'info' | 'success' | 'warning' | 'error';\n  duration?: number;\n}\n\n@Injectable({ providedIn: 'root' })\nexport class ToastService {\n  readonly toasts = signal<Toast[]>([]);\n\n  show(toast: Omit<Toast, 'id'>): void {\n    const id = crypto.randomUUID();\n    const duration = toast.duration ?? 3000;\n\n    this.toasts.update((toasts) => [...toasts, { ...toast, id }]);\n\n    if (duration > 0) {\n      setTimeout(() => this.remove(id), duration);\n    }\n  }\n\n  remove(id: string): void {\n    this.toasts.update((toasts) => toasts.filter((t) => t.id !== id));\n  }\n\n  success(title: string, message?: string, duration?: number): void {\n    this.show({ title, message, type: 'success', duration });\n  }\n\n  error(title: string, message?: string, duration?: number): void {\n    this.show({ title, message, type: 'error', duration });\n  }\n\n  info(title: string, message?: string, duration?: number): void {\n    this.show({ title, message, type: 'info', duration });\n  }\n\n  warning(title: string, message?: string, duration?: number): void {\n    this.show({ title, message, type: 'warning', duration });\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "UtilsService",
            "id": "injectable-UtilsService-681d428fc9fe44e56308b4d6ad7183dc70ebae14a79607632f27185b4ab1fc6734639772c01886b67f3b1cfac558e1f29153235dffac59872bc233a3f91ee762",
            "file": "src/app/services/core/utils.service.ts",
            "properties": [
                {
                    "name": "posLabels",
                    "defaultValue": "{\n    // Nouns\n    nn: 'noun',\n    nns: 'noun (plural)',\n    nnp: 'proper noun',\n    nnps: 'proper noun (plural)',\n\n    // Verbs\n    vb: 'verb',\n    vbd: 'verb (past)',\n    vbg: 'verb (gerund)',\n    vbn: 'verb (past participle)',\n    vbp: 'verb (present)',\n    vbz: 'verb (3rd person)',\n\n    // Adjectives\n    jj: 'adjective',\n    jjr: 'adjective (comparative)',\n    jjs: 'adjective (superlative)',\n\n    // Adverbs\n    rb: 'adverb',\n    rbr: 'adverb (comparative)',\n    rbs: 'adverb (superlative)',\n\n    // Determiners\n    dt: 'determiner',\n    wdt: 'wh-determiner',\n    pdt: 'predeterminer',\n\n    // Prepositions\n    in: 'preposition',\n\n    // Conjunctions\n    cc: 'conjunction',\n\n    // Pronouns\n    prp: 'pronoun',\n    prp$: 'possessive pronoun',\n    wp: 'wh-pronoun',\n    wp$: 'possessive wh-pronoun',\n\n    // Interjections\n    uh: 'interjection',\n\n    // Particles\n    rp: 'particle',\n\n    // Other\n    cd: 'cardinal number',\n    ex: 'existential there',\n    fw: 'foreign word',\n    ls: 'list marker',\n    md: 'modal',\n    pos: 'possessive ending',\n    sym: 'symbol',\n    to: 'to',\n    punc: 'punctuation',\n  }",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Record<string | string>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "getAllPosLabels",
                    "args": [],
                    "optional": false,
                    "returnType": "Record<string, string>",
                    "typeParameters": [],
                    "line": 71,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getPosLabel",
                    "args": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 67,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class UtilsService {\n  private readonly posLabels: Record<string, string> = {\n    // Nouns\n    nn: 'noun',\n    nns: 'noun (plural)',\n    nnp: 'proper noun',\n    nnps: 'proper noun (plural)',\n\n    // Verbs\n    vb: 'verb',\n    vbd: 'verb (past)',\n    vbg: 'verb (gerund)',\n    vbn: 'verb (past participle)',\n    vbp: 'verb (present)',\n    vbz: 'verb (3rd person)',\n\n    // Adjectives\n    jj: 'adjective',\n    jjr: 'adjective (comparative)',\n    jjs: 'adjective (superlative)',\n\n    // Adverbs\n    rb: 'adverb',\n    rbr: 'adverb (comparative)',\n    rbs: 'adverb (superlative)',\n\n    // Determiners\n    dt: 'determiner',\n    wdt: 'wh-determiner',\n    pdt: 'predeterminer',\n\n    // Prepositions\n    in: 'preposition',\n\n    // Conjunctions\n    cc: 'conjunction',\n\n    // Pronouns\n    prp: 'pronoun',\n    prp$: 'possessive pronoun',\n    wp: 'wh-pronoun',\n    wp$: 'possessive wh-pronoun',\n\n    // Interjections\n    uh: 'interjection',\n\n    // Particles\n    rp: 'particle',\n\n    // Other\n    cd: 'cardinal number',\n    ex: 'existential there',\n    fw: 'foreign word',\n    ls: 'list marker',\n    md: 'modal',\n    pos: 'possessive ending',\n    sym: 'symbol',\n    to: 'to',\n    punc: 'punctuation',\n  };\n\n  getPosLabel(pos: string): string {\n    return this.posLabels[pos.toLowerCase()] || pos;\n  }\n\n  getAllPosLabels(): Record<string, string> {\n    return { ...this.posLabels };\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        }
    ],
    "guards": [],
    "interceptors": [],
    "classes": [
        {
            "name": "AdvancedInteractions",
            "id": "class-AdvancedInteractions-2839d189b36b72c75c5b8f4407e1cdc0c49c47121f4e7bbfcfa2af50531a46860b7a3da1d1c655f95f5023340977da49d042cf2a6fcdf98e54824c6b76446e6b",
            "file": "src/e2e/advanced-interactions.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import { Page, expect, test } from '@playwright/test';\nimport { SELECTORS, TestHelpers, TEST_POEMS } from './selectors';\n\nexport class AdvancedInteractions {\n  /**\n   * Flujo completo de creación y análisis de poema\n   */\n  static async completePoemWorkflow(\n    page: Page,\n    formType: string,\n    poemLines: string[]\n  ): Promise<void> {\n    console.log(`Starting complete workflow for ${formType}`);\n\n    await TestHelpers.selectPoetryForm(page, formType);\n    await page.waitForTimeout(1000);\n\n    try {\n      await TestHelpers.clearEditor(page);\n    } catch {\n      console.log('Clear failed, continuing...');\n    }\n\n    await TestHelpers.fillPoemLines(page, poemLines);\n\n    const poemText = await TestHelpers.getPoemText(page);\n    if (!poemText.trim()) {\n      throw new Error('No poem content to analyze');\n    }\n\n    console.log(`Poem content: ${poemText}`);\n\n    const analyzeButton = page.locator(SELECTORS.BUTTONS.ANALYZE);\n    await analyzeButton.first().waitFor({ state: 'visible', timeout: 5000 });\n\n    const isEnabled = await analyzeButton.first().isEnabled();\n    if (!isEnabled) {\n      console.log('Analyze button disabled, checking why...');\n\n      for (let i = 0; i < poemLines.length; i++) {\n        const lineInput = page.locator(SELECTORS.EDITOR.LINE_INPUT(i));\n        const content = await lineInput.inputValue();\n        console.log(`Line ${i}: \"${content}\"`);\n      }\n\n      const firstLine = page.locator(SELECTORS.EDITOR.LINE_INPUT(0));\n      await firstLine.click();\n      await page.waitForTimeout(500);\n\n      const isEnabledAfterClick = await analyzeButton.first().isEnabled();\n      if (!isEnabledAfterClick) {\n        throw new Error('Analyze button is disabled despite having content');\n      }\n    }\n\n    await TestHelpers.waitForAnalysis(page, 25000);\n\n    await page.waitForTimeout(4000);\n\n    console.log('Complete workflow finished successfully');\n  }\n\n  /**\n   * Prueba todas las formas poéticas disponibles\n   */\n  static async testAllPoetryForms(page: Page): Promise<void> {\n    const forms = [\n      SELECTORS.FORM_OPTIONS.HAIKU,\n      SELECTORS.FORM_OPTIONS.TANKA,\n      SELECTORS.FORM_OPTIONS.CINQUAIN,\n      SELECTORS.FORM_OPTIONS.LIMERICK,\n      SELECTORS.FORM_OPTIONS.REDONDILLA,\n      SELECTORS.FORM_OPTIONS.LANTERNE,\n      SELECTORS.FORM_OPTIONS.DIAMANTE,\n      SELECTORS.FORM_OPTIONS.FIBONACCI,\n    ];\n\n    for (const form of forms) {\n      await test.step(`Testing ${form} form`, async () => {\n        console.log(`Testing form: ${form}`);\n\n        await TestHelpers.selectPoetryForm(page, form);\n        await page.waitForTimeout(1000);\n\n        const formSelector = page.locator(SELECTORS.FORM_SELECTOR);\n        await expect(formSelector).toHaveValue(form);\n\n        if ([SELECTORS.FORM_OPTIONS.HAIKU, SELECTORS.FORM_OPTIONS.TANKA].includes(form)) {\n          await TestHelpers.loadExample(page);\n\n          const firstLine = page.locator(SELECTORS.EDITOR.LINE_INPUT(0));\n          const lineContent = await firstLine.inputValue();\n          expect(lineContent.trim().length).toBeGreaterThan(0);\n        }\n\n        console.log(`Form ${form} tested successfully`);\n      });\n    }\n  }\n\n  /**\n   * Verifica características avanzadas del análisis\n   */\n  static async testAdvancedAnalysisFeatures(page: Page): Promise<void> {\n    console.log('Testing advanced analysis features...');\n\n    const resultsContainer = page.locator(SELECTORS.RESULTS.CONTAINER);\n    await expect(resultsContainer).toBeVisible({ timeout: 10000 });\n\n    const analysisTabs = ['structure', 'rhythm', 'quality', 'stats'];\n\n    for (const tab of analysisTabs) {\n      try {\n        await test.step(`Testing ${tab} analysis tab`, async () => {\n          const tabButton = page.locator(`.metro-pivot-item:has-text(\"${tab}\")`);\n\n          if (await tabButton.isVisible({ timeout: 3000 })) {\n            await tabButton.click();\n            await page.waitForTimeout(1000);\n\n            switch (tab) {\n              case 'structure':\n                await expect(page.locator('app-poem-results')).toBeVisible();\n                break;\n              case 'rhythm':\n                await this.verifyRhythmAnalysis(page);\n                break;\n              case 'quality':\n                await this.verifyQualityAnalysis(page);\n                break;\n              case 'stats':\n                await expect(page.locator('app-quick-stats-panel')).toBeVisible();\n                break;\n            }\n\n            console.log(`Tab ${tab} verified successfully`);\n          } else {\n            console.log(`Tab ${tab} not available, skipping...`);\n          }\n        });\n      } catch (error) {\n        console.log(`Tab ${tab} test failed:`, error instanceof Error ? error.message : error);\n      }\n    }\n\n    await this.verifyWordDetails(page);\n\n    console.log('All advanced analysis features tested');\n  }\n\n  /**\n   * Verifica el análisis de ritmo y métrica\n   */\n  private static async verifyRhythmAnalysis(page: Page): Promise<void> {\n    const meterSection = page.locator(SELECTORS.RESULTS.METER_SECTION);\n\n    if (await meterSection.isVisible({ timeout: 5000 })) {\n      const meterContent = page.locator(`${SELECTORS.RESULTS.METER_SECTION} .meter-pattern`);\n      if (await meterContent.isVisible({ timeout: 3000 })) {\n        const patternText = await meterContent.textContent();\n        expect(patternText?.length).toBeGreaterThan(0);\n        console.log(`Meter pattern found: ${patternText}`);\n      }\n    } else {\n      console.log('Meter analysis section not visible, may be empty analysis');\n    }\n  }\n\n  /**\n   * Verifica el análisis de calidad\n   */\n  private static async verifyQualityAnalysis(page: Page): Promise<void> {\n    const qualitySection = page.locator(SELECTORS.RESULTS.QUALITY_SECTION);\n\n    if (await qualitySection.isVisible({ timeout: 5000 })) {\n      const scoreElement = page.locator(`${SELECTORS.RESULTS.QUALITY_SECTION} .score-number`);\n      if (await scoreElement.isVisible({ timeout: 3000 })) {\n        const scoreText = await scoreElement.textContent();\n        expect(scoreText?.length).toBeGreaterThan(0);\n        console.log(`Quality score: ${scoreText}`);\n      }\n    } else {\n      console.log('Quality analysis section not visible');\n    }\n  }\n\n  /**\n   * Verifica detalles de palabras con manejo de múltiples elementos\n   */\n  private static async verifyWordDetails(page: Page): Promise<void> {\n    const wordDetails = page.locator(SELECTORS.RESULTS.WORD_DETAILS);\n\n    if (await wordDetails.first().isVisible({ timeout: 5000 })) {\n      const wordDetailsCount = await wordDetails.count();\n      console.log(`Found ${wordDetailsCount} word details sections`);\n\n      const firstWordDetail = wordDetails.first();\n\n      try {\n        const isExpanded = await firstWordDetail.evaluate((el) => el.hasAttribute('open'));\n        if (!isExpanded) {\n          await firstWordDetail.click({ timeout: 3000 });\n          await page.waitForTimeout(1000);\n        }\n\n        await expect(firstWordDetail).toBeVisible({ timeout: 3000 });\n\n        const detailContent = firstWordDetail.locator('.word-detail-item');\n        if (await detailContent.first().isVisible({ timeout: 2000 })) {\n          console.log('Word details content is visible and accessible');\n        }\n      } catch (error) {\n        console.log(\n          'Could not interact with word details:',\n          error instanceof Error ? error.message : error\n        );\n      }\n    } else {\n      console.log('No word details sections found');\n    }\n  }\n\n  /**\n   * Prueba el sistema de sugerencias de palabras\n   */\n  static async testWordSuggestions(page: Page): Promise<void> {\n    console.log('Testing word suggestions system...');\n\n    await TestHelpers.selectPoetryForm(page, SELECTORS.FORM_OPTIONS.HAIKU);\n    await TestHelpers.clearEditor(page);\n\n    const testPoem = [\n      'A tremendously big silent pond in forest',\n      'A small green amphibian creature jumps',\n      'Enormous splash sound happens right now',\n    ];\n\n    await TestHelpers.fillPoemLines(page, testPoem);\n    await TestHelpers.waitForAnalysis(page);\n\n    await page.waitForTimeout(5000);\n\n    const clickableWords = page.locator('.word-token.word-clickable');\n    const wordCount = await clickableWords.count();\n\n    console.log(`Found ${wordCount} clickable words`);\n\n    if (wordCount > 0) {\n      for (let i = 0; i < Math.min(wordCount, 3); i++) {\n        try {\n          const word = clickableWords.nth(i);\n          await word.click();\n          await page.waitForTimeout(2000);\n\n          const suggestionsPanel = page.locator('app-word-suggestions');\n          if (await suggestionsPanel.isVisible({ timeout: 3000 })) {\n            console.log('Word suggestions panel appeared!');\n\n            const alternatives = suggestionsPanel.locator('.alternative-item');\n            const altCount = await alternatives.count();\n\n            if (altCount > 0) {\n              console.log(`Found ${altCount} word alternatives`);\n\n              const useButton = alternatives.first().locator('button:has-text(\"use\")');\n              if (await useButton.isEnabled()) {\n                await useButton.click();\n                await page.waitForTimeout(3000);\n\n                try {\n                  await TestHelpers.waitForToast(page, 'success', 3000);\n                  console.log('Word replacement successful');\n                  return;\n                } catch {\n                  console.log('No success toast after word replacement');\n                }\n              }\n            } else {\n              console.log('No word alternatives found in suggestions panel');\n            }\n          }\n        } catch (error) {\n          console.log(`Failed with word ${i}:`, error instanceof Error ? error.message : error);\n        }\n      }\n    } else {\n      console.log('No clickable words found for suggestions test');\n\n      const allWords = page.locator('.word-token');\n      const totalWords = await allWords.count();\n      console.log(`Total words in analysis: ${totalWords}`);\n\n      if (totalWords > 0) {\n        await allWords.first().click();\n        await page.waitForTimeout(2000);\n\n        const suggestionsPanel = page.locator('app-word-suggestions');\n        if (await suggestionsPanel.isVisible({ timeout: 2000 })) {\n          console.log('Fallback: suggestions panel appeared');\n        }\n      }\n    }\n  }\n\n  /**\n   * Prueba el análisis de ritmo y métrica\n   */\n  static async testRhythmAndMeter(page: Page): Promise<void> {\n    console.log('Testing rhythm and meter analysis...');\n\n    await TestHelpers.clearEditor(page);\n    await TestHelpers.selectPoetryForm(page, SELECTORS.FORM_OPTIONS.HAIKU);\n    await TestHelpers.loadExample(page);\n\n    await page.waitForTimeout(2000);\n\n    const firstLine = page.locator(SELECTORS.EDITOR.LINE_INPUT(0));\n    const lineContent = await firstLine.inputValue();\n\n    if (!lineContent.trim()) {\n      console.log('No content loaded, retrying example...');\n      await TestHelpers.loadExample(page);\n      await page.waitForTimeout(2000);\n    }\n\n    await TestHelpers.waitForAnalysis(page, 20000);\n\n    await page.waitForTimeout(4000);\n\n    try {\n      await TestHelpers.switchAnalysisTab(page, 'rhythm');\n      console.log('Successfully switched to rhythm tab');\n    } catch {\n      console.log('Could not switch to rhythm tab, checking current view...');\n    }\n\n    await page\n      .waitForSelector(SELECTORS.RESULTS.METER_SECTION, { timeout: 10000 })\n      .catch(async () => {\n        console.log('Meter analysis section not found, checking for any rhythm content...');\n\n        const rhythmContent = page.locator(\n          '[class*=\"meter\"], [class*=\"rhythm\"], [class*=\"stress\"]'\n        );\n        if (await rhythmContent.first().isVisible({ timeout: 3000 })) {\n          console.log('Found alternative rhythm content');\n          return;\n        }\n        throw new Error('No rhythm or meter analysis content found');\n      });\n\n    console.log('Rhythm and meter analysis tested successfully');\n  }\n\n  /**\n   * Prueba el sistema de evaluación de calidad\n   */\n  static async testQualityAssessment(page: Page): Promise<void> {\n    console.log('Testing quality assessment system...');\n\n    await TestHelpers.clearEditor(page);\n    await TestHelpers.selectPoetryForm(page, SELECTORS.FORM_OPTIONS.TANKA);\n    await TestHelpers.loadExample(page);\n\n    await page.waitForTimeout(2000);\n\n    await TestHelpers.waitForAnalysis(page);\n    await page.waitForTimeout(3000);\n\n    try {\n      await TestHelpers.switchAnalysisTab(page, 'quality');\n      console.log('Successfully switched to quality tab');\n    } catch {\n      console.log('Could not switch to quality tab, checking current view...');\n    }\n\n    const qualitySection = page.locator(SELECTORS.RESULTS.QUALITY_SECTION);\n    await expect(qualitySection).toBeVisible({ timeout: 8000 });\n\n    const qualityIndicators = [\n      '.score-number',\n      '.grade-badge',\n      '.metrics-breakdown',\n      '.feedback-section',\n    ];\n\n    for (const indicator of qualityIndicators) {\n      const element = qualitySection.locator(indicator);\n      if (await element.isVisible({ timeout: 3000 })) {\n        console.log(`Quality indicator found: ${indicator}`);\n      } else {\n        console.log(`Quality indicator not found: ${indicator}`);\n      }\n    }\n\n    console.log('Quality assessment system tested successfully');\n  }\n\n  /**\n   * Prueba la funcionalidad de copia con resumen\n   */\n  static async testCopyFunctionality(page: Page): Promise<void> {\n    console.log('Testing copy functionality...');\n\n    await TestHelpers.selectPoetryForm(page, SELECTORS.FORM_OPTIONS.HAIKU);\n    await TestHelpers.clearEditor(page);\n    await TestHelpers.fillPoemLines(page, TEST_POEMS.HAIKU);\n\n    const copyButton = page.locator(SELECTORS.BUTTONS.COPY);\n    await expect(copyButton.first()).toBeEnabled({ timeout: 5000 });\n\n    await page.context().grantPermissions(['clipboard-read', 'clipboard-write']);\n\n    page.on('dialog', (dialog) => dialog.accept());\n\n    await copyButton.first().click();\n\n    try {\n      await TestHelpers.waitForToast(page, 'success', 5000);\n      console.log('Copy success notification received');\n    } catch {\n      console.log('No copy notification, but operation may have completed');\n\n      const poemText = await TestHelpers.getPoemText(page);\n      expect(poemText.trim().length).toBeGreaterThan(0);\n      console.log('Poem preserved after copy operation');\n    }\n\n    console.log('Copy functionality tested successfully');\n  }\n\n  /**\n   * Ejecuta una prueba de rendimiento básica del análisis\n   */\n  static async performanceTest(page: Page, formType: string, poemLines: string[]): Promise<number> {\n    console.log(`Starting performance test for ${formType}`);\n\n    const startTime = Date.now();\n\n    await this.completePoemWorkflow(page, formType, poemLines);\n\n    const endTime = Date.now();\n    const duration = endTime - startTime;\n\n    console.log(`Performance test completed in ${duration}ms`);\n\n    return duration;\n  }\n}\n",
            "inputsClass": [],
            "outputsClass": [],
            "properties": [],
            "methods": [
                {
                    "name": "completePoemWorkflow",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "formType",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "poemLines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 8,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nFlujo completo de creación y análisis de poema\n",
                    "description": "<p>Flujo completo de creación y análisis de poema</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "formType",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "poemLines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "performanceTest",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "formType",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "poemLines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<number>",
                    "typeParameters": [],
                    "line": 435,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nEjecuta una prueba de rendimiento básica del análisis\n",
                    "description": "<p>Ejecuta una prueba de rendimiento básica del análisis</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "formType",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "poemLines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "testAdvancedAnalysisFeatures",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 104,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nVerifica características avanzadas del análisis\n",
                    "description": "<p>Verifica características avanzadas del análisis</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "testAllPoetryForms",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 66,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nPrueba todas las formas poéticas disponibles\n",
                    "description": "<p>Prueba todas las formas poéticas disponibles</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "testCopyFunctionality",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 402,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nPrueba la funcionalidad de copia con resumen\n",
                    "description": "<p>Prueba la funcionalidad de copia con resumen</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "testQualityAssessment",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 358,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nPrueba el sistema de evaluación de calidad\n",
                    "description": "<p>Prueba el sistema de evaluación de calidad</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "testRhythmAndMeter",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 308,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nPrueba el análisis de ritmo y métrica\n",
                    "description": "<p>Prueba el análisis de ritmo y métrica</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "testWordSuggestions",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 226,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nPrueba el sistema de sugerencias de palabras\n",
                    "description": "<p>Prueba el sistema de sugerencias de palabras</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "verifyQualityAnalysis",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 172,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nVerifica el análisis de calidad\n",
                    "description": "<p>Verifica el análisis de calidad</p>\n",
                    "modifierKind": [
                        123,
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "verifyRhythmAnalysis",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 154,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nVerifica el análisis de ritmo y métrica\n",
                    "description": "<p>Verifica el análisis de ritmo y métrica</p>\n",
                    "modifierKind": [
                        123,
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "verifyWordDetails",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 190,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nVerifica detalles de palabras con manejo de múltiples elementos\n",
                    "description": "<p>Verifica detalles de palabras con manejo de múltiples elementos</p>\n",
                    "modifierKind": [
                        123,
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "BrowserManager",
            "id": "class-BrowserManager-6d1cd51da213d700331621d78703e71ec2493e97d5e3cd2a48305a04996ee567463d3331b1c5e7f4b24fdadf50f63245f0c5ac21d2bfdba23ad756114c6ce665",
            "file": "src/lib/capture/browser-utils.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import { chromium, Browser, BrowserContext, Page, LaunchOptions } from 'playwright';\nimport { BROWSER_CONFIG, SHARED_CONFIG, BrowserConfig } from '../../../playwright.config';\nimport { SELECTORS, TestHelpers } from '../../e2e/selectors';\n\nexport interface BrowserLaunchOptions {\n  headless?: boolean;\n  viewport?: { width: number; height: number };\n  recordVideo?: boolean;\n  videoSize?: { width: number; height: number };\n  browserType?: 'brave' | 'chrome' | 'firefox';\n  timeout?: number;\n}\n\nexport class BrowserManager {\n  /**\n   * Lanza el navegador con la configuración especificada\n   */\n  static async launchBrowser(\n    options: BrowserLaunchOptions = {}\n  ): Promise<{ browser: Browser; context: BrowserContext; page: Page }> {\n    const {\n      headless = false,\n      viewport = { width: 1200, height: 800 },\n      recordVideo = false,\n      videoSize = { width: 1200, height: 800 },\n      browserType = 'brave',\n      timeout = 30000,\n    } = options;\n\n    const browserConfig: BrowserConfig = BROWSER_CONFIG[browserType];\n\n    const launchOptions: LaunchOptions = {\n      headless,\n      timeout,\n    };\n\n    if (browserConfig.channel) {\n      launchOptions.channel = browserConfig.channel;\n    }\n\n    if (browserConfig.launchOptions.executablePath) {\n      launchOptions.executablePath = browserConfig.launchOptions.executablePath;\n    }\n\n    launchOptions.args = [...browserConfig.launchOptions.args];\n\n    console.log(`🚀 Launching ${browserType} browser...`);\n    const browser = await chromium.launch(launchOptions);\n\n    const contextOptions = {\n      viewport,\n      baseURL: SHARED_CONFIG.baseURL,\n      ignoreHTTPSErrors: true,\n      trace: SHARED_CONFIG.trace,\n      screenshot: SHARED_CONFIG.screenshot,\n      ...(recordVideo && {\n        recordVideo: {\n          dir: 'angular-captures/videos',\n          size: videoSize,\n        },\n      }),\n    };\n\n    const context = await browser.newContext(contextOptions);\n    context.setDefaultTimeout(timeout);\n    context.setDefaultNavigationTimeout(timeout);\n\n    const page = await context.newPage();\n    page.setDefaultTimeout(timeout);\n    page.setDefaultNavigationTimeout(timeout);\n\n    return { browser, context, page };\n  }\n\n  /**\n   * Navega de forma segura a la URL especificada\n   */\n  static async safeNavigate(page: Page, url: string, timeout = 30000): Promise<boolean> {\n    try {\n      console.log(`🌐 Navigating to: ${url}`);\n      await page.goto(url, {\n        waitUntil: 'networkidle',\n        timeout,\n      });\n\n      await page\n        .waitForSelector(SELECTORS.EDITOR.CONTAINER, { timeout: 10000 })\n        .catch(() => page.waitForSelector('app-root', { timeout: 5000 }));\n\n      console.log('✅ Application loaded successfully');\n      return true;\n    } catch (error) {\n      console.error(`❌ Failed to navigate to ${url}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Espera a que la aplicación esté completamente cargada y lista\n   */\n  static async waitForAppReady(page: Page, timeout = 15000): Promise<boolean> {\n    try {\n      await page.waitForSelector(SELECTORS.EDITOR.CONTAINER, { timeout });\n      await page.waitForSelector(SELECTORS.FORM_SELECTOR, { timeout: 10000 });\n      await page.waitForSelector('.editor-actions', { timeout: 5000 });\n\n      console.log('✅ Poetry editor application ready');\n      return true;\n    } catch (error) {\n      console.error('❌ Application not ready within timeout:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Limpia recursos del navegador\n   */\n  static async cleanup(browser?: Browser, context?: BrowserContext): Promise<void> {\n    try {\n      if (context) {\n        await context.close();\n        console.log('✅ Browser context closed');\n      }\n      if (browser) {\n        await browser.close();\n        console.log('✅ Browser closed');\n      }\n    } catch (error) {\n      console.warn('⚠️ Error during browser cleanup:', error);\n    }\n  }\n\n  /**\n   * ⚡ REFACTORIZADO: Realiza acciones de demostración del editor usando TestHelpers\n   * Esto muestra las capacidades de la aplicación en videos/screenshots\n   */\n  static async performEditorActions(page: Page): Promise<void> {\n    console.log('🔄 Performing poetry editor actions using TestHelpers...');\n\n    try {\n      const forms = [\n        SELECTORS.FORM_OPTIONS.TANKA,\n        SELECTORS.FORM_OPTIONS.LIMERICK,\n        SELECTORS.FORM_OPTIONS.HAIKU,\n      ];\n\n      for (const form of forms) {\n        await TestHelpers.selectPoetryForm(page, form);\n        await this.wait(1200);\n        console.log(`✅ Form changed to: ${form}`);\n      }\n\n      const testLines = [\n        'Ancient pond so still',\n        'A frog jumps into water',\n        'Splash breaks silence',\n      ];\n\n      const firstLine = page.locator(SELECTORS.EDITOR.LINE_INPUT(0));\n      if (await firstLine.isVisible({ timeout: 2000 })) {\n        await TestHelpers.fillPoemLines(page, testLines);\n        await this.wait(1500);\n        console.log('✅ Sample poem written');\n\n        await firstLine.fill('');\n        await this.wait(500);\n      }\n\n      await TestHelpers.loadExample(page);\n      console.log('✅ Example loaded');\n\n      const analyzeButton = page.locator(SELECTORS.BUTTONS.ANALYZE).first();\n      if ((await analyzeButton.isVisible({ timeout: 2000 })) && (await analyzeButton.isEnabled())) {\n        await analyzeButton.click();\n        await this.wait(4000);\n        console.log('✅ Analysis triggered');\n      }\n\n      const clearButton = page.locator(SELECTORS.BUTTONS.CLEAR).first();\n      if ((await clearButton.isVisible({ timeout: 2000 })) && (await clearButton.isEnabled())) {\n        await clearButton.click();\n\n        try {\n          await page.waitForSelector('button:has-text(\"OK\"), button:has-text(\"Confirm\")', {\n            timeout: 1000,\n          });\n          await page.click('button:has-text(\"OK\"), button:has-text(\"Confirm\")');\n        } catch {\n          // Nothing\n        }\n\n        await this.wait(1000);\n        console.log('✅ Editor cleared');\n      }\n\n      await page.evaluate(() => window.scrollTo({ top: 300, behavior: 'smooth' }));\n      await this.wait(800);\n      await page.evaluate(() => window.scrollTo({ top: 600, behavior: 'smooth' }));\n      await this.wait(800);\n      await page.evaluate(() => window.scrollTo({ top: 0, behavior: 'smooth' }));\n      await this.wait(800);\n\n      console.log('✅ All editor actions completed successfully');\n    } catch (error) {\n      console.log(\n        '⚠️ Some actions failed, but capture continues:',\n        error instanceof Error ? error.message : error\n      );\n    }\n  }\n\n  /**\n   * Espera un número específico de milisegundos\n   */\n  static async wait(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Toma un screenshot de la página actual\n   */\n  static async takeScreenshot(page: Page, name: string, path: string): Promise<boolean> {\n    try {\n      await page.screenshot({\n        path,\n        fullPage: true,\n      });\n      console.log(`✅ Screenshot saved: ${name} -> ${path}`);\n      return true;\n    } catch (error) {\n      console.error(`❌ Failed to take screenshot ${name}:`, error);\n      return false;\n    }\n  }\n}\n",
            "inputsClass": [],
            "outputsClass": [],
            "properties": [],
            "methods": [
                {
                    "name": "cleanup",
                    "args": [
                        {
                            "name": "browser",
                            "type": "Browser",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        },
                        {
                            "name": "context",
                            "type": "BrowserContext",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 118,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nLimpia recursos del navegador\n",
                    "description": "<p>Limpia recursos del navegador</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "browser",
                            "type": "Browser",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "context",
                            "type": "BrowserContext",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "launchBrowser",
                    "args": [
                        {
                            "name": "options",
                            "type": "BrowserLaunchOptions",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "{}"
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<literal type>",
                    "typeParameters": [],
                    "line": 18,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nLanza el navegador con la configuración especificada\n",
                    "description": "<p>Lanza el navegador con la configuración especificada</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "options",
                            "type": "BrowserLaunchOptions",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "{}",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "performEditorActions",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 137,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\n⚡ REFACTORIZADO: Realiza acciones de demostración del editor usando TestHelpers\nEsto muestra las capacidades de la aplicación en videos/screenshots\n",
                    "description": "<p>⚡ REFACTORIZADO: Realiza acciones de demostración del editor usando TestHelpers\nEsto muestra las capacidades de la aplicación en videos/screenshots</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "safeNavigate",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "url",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "timeout",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "30000"
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<boolean>",
                    "typeParameters": [],
                    "line": 78,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nNavega de forma segura a la URL especificada\n",
                    "description": "<p>Navega de forma segura a la URL especificada</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "url",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "timeout",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "30000",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "takeScreenshot",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "name",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "path",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<boolean>",
                    "typeParameters": [],
                    "line": 222,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nToma un screenshot de la página actual\n",
                    "description": "<p>Toma un screenshot de la página actual</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "name",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "path",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "wait",
                    "args": [
                        {
                            "name": "ms",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 215,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nEspera un número específico de milisegundos\n",
                    "description": "<p>Espera un número específico de milisegundos</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "ms",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "waitForAppReady",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "timeout",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "15000"
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<boolean>",
                    "typeParameters": [],
                    "line": 101,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nEspera a que la aplicación esté completamente cargada y lista\n",
                    "description": "<p>Espera a que la aplicación esté completamente cargada y lista</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "timeout",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "15000",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "ScreenshotCapture",
            "id": "class-ScreenshotCapture-04e6fde45fa39098bfe44a724002245a76b692f340f1d8bbc1c474f346fe5d2df0c8154e888ace1f7772308e6ddcd96c950a5292bbeedadac08d48b03ebb2903",
            "file": "src/lib/capture/screenshot-capture.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import { existsSync, mkdirSync, writeFileSync, statSync } from 'fs';\nimport { join } from 'path';\nimport type { CaptureOptions, CaptureResult } from './types';\nimport { BrowserManager } from './browser-utils';\nimport { Browser, BrowserContext, Page } from 'playwright';\nimport { SHARED_CONFIG } from '../../../playwright.config';\nimport { SELECTORS, TestHelpers } from '../../e2e/selectors';\n\ninterface ScreenshotCaptureOptions extends CaptureOptions {\n  multiple?: boolean;\n  browserType?: 'brave' | 'chrome' | 'firefox';\n  screenshotType?: 'png' | 'jpeg';\n  quality?: number;\n  fullPage?: boolean;\n  captureInteractions?: boolean;\n}\n\nexport class ScreenshotCapture {\n  private options: Required<ScreenshotCaptureOptions>;\n\n  constructor(options: ScreenshotCaptureOptions = {}) {\n    this.options = {\n      url: options.url || SHARED_CONFIG.baseURL,\n      outputDir: options.outputDir || 'angular-captures/screenshots',\n      viewport: options.viewport || { width: 1200, height: 800 },\n      delay: options.delay || 2000,\n      format: options.format || 'mp4',\n      multiple: options.multiple || false,\n      browserType: options.browserType || 'brave',\n      mode: options.mode || 'detailed',\n      duration: options.duration || 0,\n      screenshotType: options.screenshotType || 'png',\n      quality: options.quality || 80,\n      fullPage: options.fullPage ?? true,\n      captureInteractions: options.captureInteractions ?? true,\n    };\n  }\n\n  async capture(): Promise<CaptureResult> {\n    const startTime = Date.now();\n    const outputDir = this.options.outputDir;\n\n    if (!existsSync(outputDir)) {\n      mkdirSync(outputDir, { recursive: true });\n    }\n\n    console.log('📸 Starting screenshot capture...');\n    console.log(`🌐 URL: ${this.options.url}`);\n    console.log(`🌐 Browser: ${this.options.browserType}`);\n    console.log(`🖼️ Type: ${this.options.screenshotType.toUpperCase()}`);\n    console.log(`📁 Output: ${outputDir}`);\n\n    let browser: Browser | undefined;\n    let context: BrowserContext | undefined;\n    let page: Page | undefined;\n\n    try {\n      const browserSetup = await BrowserManager.launchBrowser({\n        headless: false,\n        viewport: this.options.viewport,\n        recordVideo: false,\n        browserType: this.options.browserType,\n      });\n\n      browser = browserSetup.browser;\n      context = browserSetup.context;\n      page = browserSetup.page;\n\n      const navigationSuccess = await BrowserManager.safeNavigate(page, this.options.url);\n      if (!navigationSuccess) {\n        throw new Error('Failed to navigate to application');\n      }\n\n      await BrowserManager.waitForAppReady(page);\n      await BrowserManager.wait(this.options.delay);\n\n      const screenshotResults: { name: string; path: string }[] = [];\n\n      if (this.options.multiple) {\n        await this.captureMultipleSections(page, outputDir, screenshotResults);\n      } else {\n        await this.captureFullPage(page, outputDir, screenshotResults);\n      }\n\n      if (this.options.captureInteractions) {\n        await this.captureInteractionStates(page, outputDir, screenshotResults);\n      }\n\n      await this.generateReport(screenshotResults, outputDir);\n      await BrowserManager.cleanup(browser, context);\n\n      const duration = Date.now() - startTime;\n\n      console.log('✅ Screenshot capture completed');\n      console.log(`📊 Total screenshots: ${screenshotResults.length}`);\n      console.log(`⏱️ Duration: ${duration}ms`);\n\n      return {\n        success: true,\n        outputPath: outputDir,\n        duration,\n        timestamp: new Date().toISOString(),\n        url: this.options.url,\n        mode: this.options.mode,\n        sections: screenshotResults,\n      };\n    } catch (error) {\n      await BrowserManager.cleanup(browser, context);\n      console.error('❌ Error during screenshot capture:', error);\n\n      return {\n        success: false,\n        outputPath: '',\n        duration: Date.now() - startTime,\n        timestamp: new Date().toISOString(),\n        url: this.options.url,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  private async captureMultipleSections(\n    page: Page,\n    outputDir: string,\n    results: { name: string; path: string }[]\n  ): Promise<void> {\n    const sections = [\n      { name: 'fullpage', selector: 'body', fullPage: true },\n      { name: 'header', selector: 'app-header', fullPage: false },\n      { name: 'editor', selector: SELECTORS.EDITOR.CONTAINER, fullPage: false },\n      { name: 'results', selector: SELECTORS.RESULTS.CONTAINER, fullPage: false },\n      { name: 'analysis-tabs', selector: '.metro-pivot', fullPage: false },\n      { name: 'analysis-tabs-alt', selector: '[role=\"tablist\"]', fullPage: false },\n      { name: 'quick-nav', selector: '.quick-nav-buttons', fullPage: false },\n      { name: 'footer', selector: 'app-footer', fullPage: false },\n    ];\n\n    for (const section of sections) {\n      try {\n        const timestamp = Date.now();\n        const screenshotPath = join(\n          outputDir,\n          `${section.name}-${timestamp}.${this.options.screenshotType}`\n        );\n\n        if (section.fullPage) {\n          await page.screenshot({\n            path: screenshotPath,\n            fullPage: true,\n            type: this.options.screenshotType as 'png' | 'jpeg',\n            ...(this.options.screenshotType === 'jpeg' && { quality: this.options.quality }),\n          });\n        } else {\n          const element = page.locator(section.selector);\n          if (await element.isVisible({ timeout: 2000 })) {\n            await element.screenshot({\n              path: screenshotPath,\n              type: this.options.screenshotType as 'png' | 'jpeg',\n              ...(this.options.screenshotType === 'jpeg' && { quality: this.options.quality }),\n            });\n          } else {\n            console.log(`⚠️ Element not visible: ${section.selector}`);\n            continue;\n          }\n        }\n\n        results.push({\n          name: section.name,\n          path: screenshotPath,\n        });\n        console.log(`✅ ${section.name} captured: ${screenshotPath}`);\n\n        await BrowserManager.wait(500);\n      } catch (error) {\n        console.log(\n          `⚠️ Could not capture ${section.name}:`,\n          error instanceof Error ? error.message : 'Unknown error'\n        );\n      }\n    }\n  }\n\n  /**\n   * ⚡ REFACTORIZADO: Usa TestHelpers y SELECTORS\n   */\n  private async captureInteractionStates(\n    page: Page,\n    outputDir: string,\n    results: { name: string; path: string }[]\n  ): Promise<void> {\n    console.log('🔄 Capturing interaction states...');\n\n    try {\n      const formSelect = page.locator(SELECTORS.FORM_SELECTOR);\n\n      if (await formSelect.isVisible({ timeout: 2000 })) {\n        const forms = [\n          SELECTORS.FORM_OPTIONS.TANKA,\n          SELECTORS.FORM_OPTIONS.LIMERICK,\n          SELECTORS.FORM_OPTIONS.CINQUAIN,\n        ];\n\n        for (const form of forms) {\n          await TestHelpers.selectPoetryForm(page, form);\n          await BrowserManager.wait(1500);\n\n          const screenshotPath = join(\n            outputDir,\n            `form-${form}-${Date.now()}.${this.options.screenshotType}`\n          );\n\n          await page.screenshot({\n            path: screenshotPath,\n            fullPage: this.options.fullPage,\n            type: this.options.screenshotType as 'png' | 'jpeg',\n            ...(this.options.screenshotType === 'jpeg' && { quality: this.options.quality }),\n          });\n\n          results.push({ name: `form-${form}`, path: screenshotPath });\n          console.log(`✅ Form ${form} captured`);\n        }\n\n        await TestHelpers.selectPoetryForm(page, SELECTORS.FORM_OPTIONS.HAIKU);\n        await BrowserManager.wait(1000);\n      }\n\n      await TestHelpers.loadExample(page);\n      await BrowserManager.wait(3000);\n\n      const examplePath = join(\n        outputDir,\n        `with-example-${Date.now()}.${this.options.screenshotType}`\n      );\n\n      await page.screenshot({\n        path: examplePath,\n        fullPage: this.options.fullPage,\n        type: this.options.screenshotType as 'png' | 'jpeg',\n        ...(this.options.screenshotType === 'jpeg' && { quality: this.options.quality }),\n      });\n\n      results.push({ name: 'with-example', path: examplePath });\n      console.log('✅ Example loaded state captured');\n\n      const analyzeButton = page.locator(SELECTORS.BUTTONS.ANALYZE).first();\n      if ((await analyzeButton.isVisible({ timeout: 2000 })) && (await analyzeButton.isEnabled())) {\n        await analyzeButton.click();\n        console.log('🔍 Analysis started, waiting for results...');\n        await BrowserManager.wait(6000);\n\n        const resultsVisible = await page\n          .locator(SELECTORS.RESULTS.CONTAINER)\n          .isVisible({ timeout: 3000 })\n          .catch(() => false);\n\n        if (resultsVisible) {\n          console.log('✅ Results are visible');\n\n          const resultsPath = join(\n            outputDir,\n            `with-results-${Date.now()}.${this.options.screenshotType}`\n          );\n\n          await page.screenshot({\n            path: resultsPath,\n            fullPage: this.options.fullPage,\n            type: this.options.screenshotType as 'png' | 'jpeg',\n            ...(this.options.screenshotType === 'jpeg' && { quality: this.options.quality }),\n          });\n\n          results.push({ name: 'with-results', path: resultsPath });\n          console.log('✅ Results captured');\n\n          const analysisTabs = ['structure', 'rhythm', 'quality', 'stats'];\n          for (const tab of analysisTabs) {\n            try {\n              const tabButton = page.locator(`.metro-pivot-item:has-text(\"${tab}\")`);\n              if (await tabButton.isVisible({ timeout: 2000 })) {\n                await tabButton.click();\n                await BrowserManager.wait(1500);\n\n                const tabPath = join(\n                  outputDir,\n                  `tab-${tab}-${Date.now()}.${this.options.screenshotType}`\n                );\n\n                await page.screenshot({\n                  path: tabPath,\n                  fullPage: this.options.fullPage,\n                  type: this.options.screenshotType as 'png' | 'jpeg',\n                  ...(this.options.screenshotType === 'jpeg' && { quality: this.options.quality }),\n                });\n\n                results.push({ name: `tab-${tab}`, path: tabPath });\n                console.log(`✅ Tab ${tab} captured`);\n              }\n            } catch (error) {\n              console.log(`⚠️ Could not capture tab ${tab}`, error);\n            }\n          }\n        } else {\n          console.log('⚠️ Results not visible after analysis');\n        }\n      }\n    } catch (error) {\n      console.log(\n        '⚠️ Some interaction captures failed:',\n        error instanceof Error ? error.message : error\n      );\n    }\n  }\n\n  private async captureFullPage(\n    page: Page,\n    outputDir: string,\n    results: { name: string; path: string }[]\n  ): Promise<void> {\n    const timestamp = Date.now();\n    const fullPagePath = join(outputDir, `fullpage-${timestamp}.${this.options.screenshotType}`);\n\n    await page.screenshot({\n      path: fullPagePath,\n      fullPage: this.options.fullPage,\n      type: this.options.screenshotType as 'png' | 'jpeg',\n      ...(this.options.screenshotType === 'jpeg' && { quality: this.options.quality }),\n    });\n\n    results.push({\n      name: 'fullpage',\n      path: fullPagePath,\n    });\n  }\n\n  private async generateReport(\n    screenshots: { name: string; path: string }[],\n    outputDir: string\n  ): Promise<void> {\n    const report = {\n      generatedAt: new Date().toISOString(),\n      totalScreenshots: screenshots.length,\n      viewport: this.options.viewport,\n      settings: {\n        screenshotType: this.options.screenshotType,\n        quality: this.options.quality,\n        fullPage: this.options.fullPage,\n        multiple: this.options.multiple,\n        browserType: this.options.browserType,\n      },\n      screenshots: screenshots.map((s) => ({\n        name: s.name,\n        path: s.path,\n        filename: s.path.split('/').pop(),\n        size: this.getFileSize(s.path),\n      })),\n    };\n\n    const reportPath = join(outputDir, 'screenshots-report.json');\n    writeFileSync(reportPath, JSON.stringify(report, null, 2));\n    console.log(`📊 Report generated: ${reportPath}`);\n  }\n\n  private getFileSize(filePath: string): string {\n    try {\n      const stats = statSync(filePath);\n      const sizeInKB = Math.round(stats.size / 1024);\n      return `${sizeInKB} KB`;\n    } catch {\n      return 'Unknown';\n    }\n  }\n\n  static async quickScreenshot(\n    url: string = SHARED_CONFIG.baseURL,\n    options: Partial<ScreenshotCaptureOptions> = {}\n  ): Promise<CaptureResult> {\n    const capture = new ScreenshotCapture({\n      url,\n      ...options,\n      browserType: 'brave',\n    });\n    return await capture.capture();\n  }\n\n  static async captureApplicationOverview(): Promise<CaptureResult> {\n    return await this.quickScreenshot(SHARED_CONFIG.baseURL, {\n      multiple: true,\n      captureInteractions: true,\n      mode: 'overview',\n    });\n  }\n}\n\nexport async function captureScreenshots(\n  options?: ScreenshotCaptureOptions\n): Promise<CaptureResult> {\n  const capture = new ScreenshotCapture(options);\n  return await capture.capture();\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "options",
                        "type": "ScreenshotCaptureOptions",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "defaultValue": "{}"
                    }
                ],
                "line": 19,
                "jsdoctags": [
                    {
                        "name": "options",
                        "type": "ScreenshotCaptureOptions",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "defaultValue": "{}",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "options",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Required<ScreenshotCaptureOptions>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 19,
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "methods": [
                {
                    "name": "capture",
                    "args": [],
                    "optional": false,
                    "returnType": "Promise<CaptureResult>",
                    "typeParameters": [],
                    "line": 39,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ]
                },
                {
                    "name": "captureApplicationOverview",
                    "args": [],
                    "optional": false,
                    "returnType": "Promise<CaptureResult>",
                    "typeParameters": [],
                    "line": 384,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        126,
                        134
                    ]
                },
                {
                    "name": "captureFullPage",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "results",
                            "type": "literal type[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 313,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "results",
                            "type": "literal type[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "captureInteractionStates",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "results",
                            "type": "literal type[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 186,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\n⚡ REFACTORIZADO: Usa TestHelpers y SELECTORS\n",
                    "description": "<p>⚡ REFACTORIZADO: Usa TestHelpers y SELECTORS</p>\n",
                    "modifierKind": [
                        123,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "results",
                            "type": "literal type[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "captureMultipleSections",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "results",
                            "type": "literal type[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 122,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "results",
                            "type": "literal type[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateReport",
                    "args": [
                        {
                            "name": "screenshots",
                            "type": "literal type[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 334,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "screenshots",
                            "type": "literal type[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getFileSize",
                    "args": [
                        {
                            "name": "filePath",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 362,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "filePath",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "quickScreenshot",
                    "args": [
                        {
                            "name": "url",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "SHARED_CONFIG.baseURL"
                        },
                        {
                            "name": "options",
                            "type": "Partial<ScreenshotCaptureOptions>",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "{}"
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<CaptureResult>",
                    "typeParameters": [],
                    "line": 372,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "url",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "SHARED_CONFIG.baseURL",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "options",
                            "type": "Partial<ScreenshotCaptureOptions>",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "{}",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "TestHelpers",
            "id": "class-TestHelpers-91c9e952bae8346a302035032414c4d650ba08784e4ba06e4dbdb34d2890894b48f1f020791cc4a30c72e589ed9ba71c1e8108f5b8b7e3862928468d70fa8640",
            "file": "src/e2e/selectors.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import { Page, expect } from '@playwright/test';\n\nexport const SELECTORS = {\n  FORM_SELECTOR: '#poetry-form-selector',\n  FORM_OPTIONS: {\n    HAIKU: 'haiku',\n    TANKA: 'tanka',\n    CINQUAIN: 'cinquain',\n    LIMERICK: 'limerick',\n    REDONDILLA: 'redondilla',\n    LANTERNE: 'lanterne',\n    DIAMANTE: 'diamante',\n    FIBONACCI: 'fibonacci',\n  },\n\n  BUTTONS: {\n    ANALYZE: '.editor-actions button:has-text(\"analyze\")',\n    CLEAR: '.editor-actions button:has-text(\"clear\")',\n    LOAD_EXAMPLE: '.editor-actions button:has-text(\"example\")',\n    COPY: '.editor-actions button:has-text(\"copy\")',\n\n    APP_BAR: {\n      ANALYZE: '.metro-command-button:has-text(\"analyze\")',\n      CLEAR: '.metro-command-button:has-text(\"clear\")',\n      EXAMPLE: '.metro-command-button:has-text(\"example\")',\n      COPY: '.metro-command-button:has-text(\"copy\")',\n    },\n  },\n\n  EDITOR: {\n    CONTAINER: 'app-poem-editor',\n    LINE_INPUT: (index: number) => `#poem-editor-line-${index}`,\n    SYLLABLE_COUNTER: (index: number) => `.line-row:nth-child(${index + 1}) .syllable-count`,\n    MULTILINE_INPUT: 'app-multiline-input',\n  },\n\n  RESULTS: {\n    CONTAINER: 'app-poem-results',\n    QUALITY_SECTION: 'app-poem-quality',\n    METER_SECTION: 'app-meter-analysis-section',\n    WORD_DETAILS: '.word-details',\n    SUGGESTIONS: 'app-word-suggestions',\n    ANALYSIS_TABS: '.metro-pivot-item',\n  },\n\n  NAVIGATION: {\n    QUICK_NAV: '.nav-pill',\n    PANORAMA_SECTIONS: '[data-section]',\n  },\n\n  STATE: {\n    LOADING: '[class*=\"loading\"], [class*=\"progress\"]',\n    TOAST: {\n      SUCCESS: '.metro-toast-success',\n      ERROR: '.metro-toast-error',\n      INFO: '.metro-toast-info',\n      WARNING: '.metro-toast-warning',\n    },\n  },\n};\n\nexport const TEST_POEMS = {\n  HAIKU: ['An old silent pond', 'A frog jumps into the pond', 'Splash! Silence again'],\n  HAIKU_SPANISH: ['Un estanque silencioso', 'Una rana salta al agua', '¡Chap! Silencio otra vez'],\n  TANKA: [\n    'The falling flower',\n    'I saw drift back to the branch',\n    'Was a butterfly',\n    'Dancing in the gentle breeze',\n    \"Nature's art in motion\",\n  ],\n  CINQUAIN: [\n    'Moon',\n    'Silent light',\n    'Casting silver shadows',\n    'Illuminating the dark night',\n    'Peace',\n  ],\n};\n\nexport class TestHelpers {\n  /**\n   * Selecciona una forma poética en el dropdown\n   */\n  static async selectPoetryForm(page: Page, formValue: string): Promise<void> {\n    const formSelector = page.locator(SELECTORS.FORM_SELECTOR);\n\n    await formSelector.waitFor({ state: 'visible', timeout: 5000 });\n\n    const currentValue = await formSelector.inputValue();\n    if (currentValue === formValue) {\n      console.log(`Form already set to ${formValue}`);\n      return;\n    }\n\n    await formSelector.selectOption(formValue);\n\n    await page.waitForTimeout(1000);\n\n    await expect(formSelector).toHaveValue(formValue, { timeout: 3000 });\n  }\n\n  /**\n   * Carga un ejemplo en el editor\n   */\n  static async loadExample(page: Page): Promise<void> {\n    const exampleButton = page.locator(SELECTORS.BUTTONS.LOAD_EXAMPLE);\n    await exampleButton.first().click();\n\n    await page.waitForTimeout(1500);\n\n    const firstLine = page.locator(SELECTORS.EDITOR.LINE_INPUT(0));\n    const lineContent = await firstLine.inputValue();\n\n    if (!lineContent.trim()) {\n      console.log('No content loaded, retrying...');\n      await page.waitForTimeout(1000);\n      await exampleButton.first().click();\n      await page.waitForTimeout(1500);\n    }\n  }\n\n  /**\n   * Limpia el editor\n   */\n  static async clearEditor(page: Page): Promise<void> {\n    const clearButton = page.locator(SELECTORS.BUTTONS.CLEAR);\n    await clearButton.first().click();\n\n    try {\n      await page.waitForSelector(\n        'button:has-text(\"OK\"), button:has-text(\"Confirm\"), button:has-text(\"Yes\")',\n        {\n          timeout: 2000,\n        }\n      );\n      await page.click('button:has-text(\"OK\"), button:has-text(\"Confirm\"), button:has-text(\"Yes\")');\n      await page.waitForTimeout(500);\n    } catch {\n      //Nothing\n    }\n\n    await page.waitForTimeout(500);\n\n    const firstLine = page.locator(SELECTORS.EDITOR.LINE_INPUT(0));\n    const lineContent = await firstLine.inputValue();\n\n    if (lineContent.trim()) {\n      console.log('Editor not cleared, retrying...');\n      await clearButton.first().click();\n      await page.waitForTimeout(1000);\n    }\n  }\n\n  /**\n   * Llena las líneas del poema en el editor\n   */\n  static async fillPoemLines(page: Page, lines: string[]): Promise<void> {\n    for (let i = 0; i < lines.length; i++) {\n      const lineInput = page.locator(SELECTORS.EDITOR.LINE_INPUT(i));\n\n      await lineInput.waitFor({ state: 'visible', timeout: 3000 });\n\n      await lineInput.clear();\n      await lineInput.fill(lines[i]);\n\n      await page.waitForTimeout(300);\n    }\n\n    await page.waitForTimeout(1000);\n  }\n\n  /**\n   * Ejecuta el análisis y espera los resultados\n   */\n  static async waitForAnalysis(page: Page, timeout = 20000): Promise<void> {\n    const analyzeButton = page.locator(SELECTORS.BUTTONS.ANALYZE);\n\n    await analyzeButton.first().waitFor({ state: 'visible', timeout: 5000 });\n    await expect(analyzeButton.first()).toBeEnabled({ timeout: 5000 });\n\n    await analyzeButton.first().click();\n\n    console.log('Analysis started, waiting for results...');\n\n    try {\n      await page.waitForSelector(SELECTORS.STATE.LOADING, {\n        state: 'visible',\n        timeout: 5000,\n      });\n      console.log('Loading indicator found, waiting for it to disappear...');\n\n      await page.waitForSelector(SELECTORS.STATE.LOADING, {\n        state: 'detached',\n        timeout: 15000,\n      });\n      console.log('Loading indicator disappeared');\n    } catch {\n      console.log('No loading indicators found, continuing...');\n    }\n\n    try {\n      await page.waitForSelector(SELECTORS.RESULTS.CONTAINER, { timeout });\n      console.log('Main results container found');\n    } catch (error) {\n      console.log('Main results container not found, trying alternative strategies...', error);\n\n      const resultComponents = [\n        'app-poem-results',\n        'app-meter-analysis-section',\n        'app-poem-quality',\n        'app-quick-stats-panel',\n        'app-word-suggestions',\n      ];\n\n      let foundComponent = false;\n      for (const component of resultComponents) {\n        if (await page.locator(component).isVisible({ timeout: 3000 })) {\n          console.log(`Found result component: ${component}`);\n          foundComponent = true;\n          break;\n        }\n      }\n\n      if (!foundComponent) {\n        await page.waitForTimeout(5000);\n\n        if (await analyzeButton.first().isEnabled()) {\n          console.log('Analyze button re-enabled, analysis might be complete');\n        } else {\n          throw new Error('No analysis results found with any strategy');\n        }\n      }\n    }\n  }\n\n  /**\n   * Navega a una sección específica usando los botones de navegación rápida\n   */\n  static async navigateToSection(page: Page, section: 'editor' | 'results'): Promise<void> {\n    const navButton = page.locator(`.nav-pill:has-text(\"${section}\")`);\n    await navButton.click();\n\n    await page.waitForTimeout(1000);\n\n    const sectionElement = page.locator(`[data-section=\"${section}\"]`);\n    await expect(sectionElement).toBeVisible({ timeout: 3000 });\n  }\n\n  /**\n   * Cambia a una pestaña específica en los resultados de análisis\n   */\n  static async switchAnalysisTab(page: Page, tabName: string): Promise<void> {\n    const tabButton = page.locator(`.metro-pivot-item:has-text(\"${tabName}\")`);\n    await tabButton.click();\n\n    await page.waitForTimeout(500);\n\n    await expect(tabButton).toHaveClass(/metro-pivot-active/, { timeout: 3000 });\n  }\n\n  /**\n   * Espera a que un toast aparezca y verifica su contenido\n   */\n  static async waitForToast(\n    page: Page,\n    type: 'success' | 'error' | 'info' | 'warning',\n    timeout = 5000\n  ): Promise<void> {\n    const toastSelector =\n      SELECTORS.STATE.TOAST[type.toUpperCase() as keyof typeof SELECTORS.STATE.TOAST];\n    const toast = page.locator(toastSelector);\n\n    await expect(toast.first()).toBeVisible({ timeout });\n\n    await page.waitForTimeout(1000);\n  }\n\n  /**\n   * Verifica que el contador de sílabas muestre el valor esperado\n   */\n  static async verifySyllableCount(\n    page: Page,\n    lineIndex: number,\n    expectedPattern: RegExp | string\n  ): Promise<void> {\n    const syllableCounter = page.locator(SELECTORS.EDITOR.SYLLABLE_COUNTER(lineIndex));\n\n    await syllableCounter.waitFor({ state: 'visible', timeout: 3000 });\n\n    await page.waitForFunction(\n      (args: { selector: string; pattern: string }) => {\n        const counter = document.querySelector(args.selector);\n        return counter && new RegExp(args.pattern).test(counter.textContent || '');\n      },\n      {\n        selector: `.line-row:nth-child(${lineIndex + 1}) .syllable-count`,\n        pattern: expectedPattern instanceof RegExp ? expectedPattern.source : expectedPattern,\n      },\n      { timeout: 5000 }\n    );\n\n    const counterText = await syllableCounter.textContent();\n\n    if (expectedPattern instanceof RegExp) {\n      expect(counterText).toMatch(expectedPattern);\n    } else {\n      expect(counterText).toContain(expectedPattern);\n    }\n  }\n\n  /**\n   * Obtiene el texto completo del poema del editor\n   */\n  static async getPoemText(page: Page): Promise<string> {\n    const lines: string[] = [];\n\n    for (let i = 0; i < 10; i++) {\n      const lineInput = page.locator(SELECTORS.EDITOR.LINE_INPUT(i));\n\n      if (await lineInput.isVisible()) {\n        const lineText = await lineInput.inputValue();\n        if (lineText.trim()) {\n          lines.push(lineText);\n        }\n      } else {\n        break;\n      }\n    }\n\n    return lines.join('\\n');\n  }\n}\n",
            "inputsClass": [],
            "outputsClass": [],
            "properties": [],
            "methods": [
                {
                    "name": "clearEditor",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 126,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nLimpia el editor\n",
                    "description": "<p>Limpia el editor</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "fillPoemLines",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 158,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nLlena las líneas del poema en el editor\n",
                    "description": "<p>Llena las líneas del poema en el editor</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getPoemText",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<string>",
                    "typeParameters": [],
                    "line": 315,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nObtiene el texto completo del poema del editor\n",
                    "description": "<p>Obtiene el texto completo del poema del editor</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "loadExample",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 106,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nCarga un ejemplo en el editor\n",
                    "description": "<p>Carga un ejemplo en el editor</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "navigateToSection",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "section",
                            "type": "\"editor\" | \"results\"",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 240,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nNavega a una sección específica usando los botones de navegación rápida\n",
                    "description": "<p>Navega a una sección específica usando los botones de navegación rápida</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "section",
                            "type": "\"editor\" | \"results\"",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "selectPoetryForm",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "formValue",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 85,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nSelecciona una forma poética en el dropdown\n",
                    "description": "<p>Selecciona una forma poética en el dropdown</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "formValue",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "switchAnalysisTab",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "tabName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 253,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nCambia a una pestaña específica en los resultados de análisis\n",
                    "description": "<p>Cambia a una pestaña específica en los resultados de análisis</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "tabName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "verifySyllableCount",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "lineIndex",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "expectedPattern",
                            "type": "RegExp | string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 282,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nVerifica que el contador de sílabas muestre el valor esperado\n",
                    "description": "<p>Verifica que el contador de sílabas muestre el valor esperado</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "lineIndex",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "expectedPattern",
                            "type": "RegExp | string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "waitForAnalysis",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "timeout",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "20000"
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 176,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nEjecuta el análisis y espera los resultados\n",
                    "description": "<p>Ejecuta el análisis y espera los resultados</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "timeout",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "20000",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "waitForToast",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "type",
                            "type": "\"success\" | \"error\" | \"info\" | \"warning\"",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "timeout",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "5000"
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 265,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nEspera a que un toast aparezca y verifica su contenido\n",
                    "description": "<p>Espera a que un toast aparezca y verifica su contenido</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "type",
                            "type": "\"success\" | \"error\" | \"info\" | \"warning\"",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "timeout",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "5000",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "VideoCapture",
            "id": "class-VideoCapture-840e69b8d5b79da86dc82c94b284308b890860126fa6920b495552184c5b9822d10d261a7a4ab58cf8a5d5ed3e5d5ee1df578c225bbdd06dad111e99c36b5366",
            "file": "src/lib/capture/video-capture.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import { existsSync, mkdirSync } from 'fs';\nimport { join } from 'path';\nimport type { CaptureOptions, CaptureResult } from './types';\nimport { BrowserManager } from './browser-utils';\nimport { Browser, BrowserContext, Page } from 'playwright';\nimport { SHARED_CONFIG } from '../../../playwright.config';\nimport { SELECTORS, TestHelpers } from '../../e2e/selectors';\n\ninterface VideoCaptureOptions extends Omit<CaptureOptions, 'multiple'> {\n  duration?: number;\n  browserType?: 'brave' | 'chrome' | 'firefox';\n  showInteractions?: boolean;\n  includeAdvancedDemo?: boolean;\n}\n\nexport class VideoCapture {\n  private options: Required<Omit<VideoCaptureOptions, 'multiple'>>;\n\n  constructor(options: VideoCaptureOptions = {}) {\n    this.options = {\n      url: options.url || SHARED_CONFIG.baseURL,\n      outputDir: options.outputDir || 'angular-captures/videos',\n      viewport: options.viewport || { width: 1200, height: 800 },\n      delay: options.delay || 3000,\n      format: options.format || 'mp4',\n      duration: options.duration || 15000,\n      browserType: options.browserType || 'brave',\n      mode: options.mode || 'full',\n      showInteractions: options.showInteractions ?? true,\n      includeAdvancedDemo: options.includeAdvancedDemo ?? false,\n    };\n  }\n\n  async capture(): Promise<CaptureResult> {\n    const startTime = Date.now();\n    const outputDir = this.options.outputDir;\n\n    if (!existsSync(outputDir)) {\n      mkdirSync(outputDir, { recursive: true });\n    }\n\n    console.log('🎬 Starting video capture...');\n    console.log(`🌐 URL: ${this.options.url}`);\n    console.log(`⏱️ Duration: ${this.options.duration}ms`);\n    console.log(`🌐 Browser: ${this.options.browserType}`);\n    console.log(`🖥️ Viewport: ${this.options.viewport.width}x${this.options.viewport.height}`);\n    console.log(`🎯 Interactions: ${this.options.showInteractions ? 'Enabled' : 'Disabled'}`);\n\n    let browser: Browser | undefined;\n    let context: BrowserContext | undefined;\n    let page: Page | undefined;\n\n    try {\n      const browserSetup = await BrowserManager.launchBrowser({\n        headless: false,\n        viewport: this.options.viewport,\n        recordVideo: true,\n        videoSize: this.options.viewport,\n        browserType: this.options.browserType,\n        timeout: this.options.duration + 10000,\n      });\n\n      browser = browserSetup.browser;\n      context = browserSetup.context;\n      page = browserSetup.page;\n\n      const navigationSuccess = await BrowserManager.safeNavigate(page, this.options.url);\n      if (!navigationSuccess) {\n        throw new Error('Failed to navigate to application');\n      }\n\n      await BrowserManager.waitForAppReady(page);\n      await BrowserManager.wait(this.options.delay);\n\n      if (this.options.showInteractions) {\n        if (this.options.includeAdvancedDemo) {\n          await this.performAdvancedDemo(page);\n        } else {\n          await BrowserManager.performEditorActions(page);\n        }\n      }\n\n      const elapsedTime = Date.now() - startTime;\n      const remainingTime = this.options.duration - elapsedTime;\n\n      if (remainingTime > 0) {\n        console.log(`⏳ Recording for ${Math.round(remainingTime / 1000)}s more...`);\n        await BrowserManager.wait(remainingTime);\n      }\n\n      await BrowserManager.cleanup(browser, context);\n\n      const duration = Date.now() - startTime;\n      const outputPath = await this.findLatestVideoFile(outputDir);\n\n      if (outputPath) {\n        console.log('✅ Video recorded successfully');\n        console.log(`📊 Capture duration: ${duration}ms`);\n        console.log(`💾 Output: ${outputPath}`);\n      } else {\n        console.log('⚠️ Video file not found, but capture completed');\n      }\n\n      return {\n        success: true,\n        outputPath,\n        duration,\n        timestamp: new Date().toISOString(),\n        url: this.options.url,\n        mode: this.options.mode,\n      };\n    } catch (error) {\n      await BrowserManager.cleanup(browser, context);\n      console.error('❌ Error during video capture:', error);\n\n      return {\n        success: false,\n        outputPath: '',\n        duration: Date.now() - startTime,\n        timestamp: new Date().toISOString(),\n        url: this.options.url,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  /**\n   * ⚡ NUEVO: Demo avanzada que muestra más características\n   */\n  private async performAdvancedDemo(page: Page): Promise<void> {\n    console.log('🎯 Performing advanced demo with full workflow...');\n\n    try {\n      const forms = [\n        { id: SELECTORS.FORM_OPTIONS.HAIKU, wait: 1500 },\n        { id: SELECTORS.FORM_OPTIONS.TANKA, wait: 1500 },\n        { id: SELECTORS.FORM_OPTIONS.LIMERICK, wait: 1500 },\n      ];\n\n      for (const form of forms) {\n        await TestHelpers.selectPoetryForm(page, form.id);\n        await BrowserManager.wait(form.wait);\n        console.log(`✅ Demo: Form ${form.id}`);\n      }\n\n      await TestHelpers.selectPoetryForm(page, SELECTORS.FORM_OPTIONS.HAIKU);\n      await BrowserManager.wait(1000);\n\n      const demoPoem = [\n        'Silent morning light',\n        'Cherry blossoms gently fall',\n        'Spring awakens slow',\n      ];\n\n      await TestHelpers.fillPoemLines(page, demoPoem);\n      await BrowserManager.wait(2000);\n      console.log('✅ Demo: Custom poem written');\n\n      const analyzeButton = page.locator(SELECTORS.BUTTONS.ANALYZE).first();\n      if ((await analyzeButton.isVisible()) && (await analyzeButton.isEnabled())) {\n        await analyzeButton.click();\n        console.log('🔍 Demo: Analysis started');\n\n        await BrowserManager.wait(6000);\n\n        const resultsVisible = await page\n          .locator(SELECTORS.RESULTS.CONTAINER)\n          .isVisible({ timeout: 3000 })\n          .catch(() => false);\n\n        if (resultsVisible) {\n          console.log('✅ Demo: Results displayed');\n\n          await page.evaluate(() => {\n            const results = document.querySelector('app-poem-results');\n            if (results) {\n              results.scrollTo({ top: 200, behavior: 'smooth' });\n            }\n          });\n          await BrowserManager.wait(1500);\n\n          await page.evaluate(() => {\n            const results = document.querySelector('app-poem-results');\n            if (results) {\n              results.scrollTo({ top: 0, behavior: 'smooth' });\n            }\n          });\n          await BrowserManager.wait(1000);\n\n          const tabs = ['structure', 'rhythm', 'quality'];\n          for (const tab of tabs) {\n            try {\n              const tabButton = page.locator(`.metro-pivot-item:has-text(\"${tab}\")`);\n              if (await tabButton.isVisible({ timeout: 2000 })) {\n                await tabButton.click();\n                await BrowserManager.wait(2000);\n                console.log(`✅ Demo: Switched to ${tab} tab`);\n              }\n            } catch {\n              console.log(`⚠️ Demo: Tab ${tab} not available`);\n            }\n          }\n        }\n      }\n\n      const copyButton = page.locator(SELECTORS.BUTTONS.COPY).first();\n      if ((await copyButton.isVisible()) && (await copyButton.isEnabled())) {\n        await copyButton.click();\n        await BrowserManager.wait(1500);\n        console.log('✅ Demo: Copy function');\n      }\n\n      await TestHelpers.loadExample(page);\n      await BrowserManager.wait(2000);\n      console.log('✅ Demo: Official example loaded');\n\n      await page.evaluate(() => window.scrollTo({ top: 400, behavior: 'smooth' }));\n      await BrowserManager.wait(1000);\n      await page.evaluate(() => window.scrollTo({ top: 0, behavior: 'smooth' }));\n      await BrowserManager.wait(1000);\n\n      console.log('✅ Advanced demo completed successfully');\n    } catch (error) {\n      console.log(\n        '⚠️ Some advanced demo actions failed:',\n        error instanceof Error ? error.message : error\n      );\n    }\n  }\n\n  /**\n   * Busca el archivo de video más reciente en el directorio de salida\n   */\n  private async findLatestVideoFile(outputDir: string): Promise<string> {\n    try {\n      const fs = await import('fs/promises');\n\n      if (!existsSync(outputDir)) {\n        console.log('⚠️ Output directory does not exist');\n        return '';\n      }\n\n      const files = await fs.readdir(outputDir);\n\n      const videoFiles = files\n        .filter((f) => f.endsWith('.webm') || f.endsWith('.mp4') || f.endsWith('.mkv'))\n        .map((f) => ({\n          name: f,\n          path: join(outputDir, f),\n          time: fs.stat(join(outputDir, f)).then((stat) => stat.mtime),\n        }));\n\n      if (videoFiles.length === 0) {\n        console.log('⚠️ No video files found in directory');\n        return '';\n      }\n\n      const filesWithStats = await Promise.all(\n        videoFiles.map(async (file) => ({\n          ...file,\n          time: await file.time,\n        }))\n      );\n\n      filesWithStats.sort((a, b) => b.time.getTime() - a.time.getTime());\n\n      const latestFile = filesWithStats[0]?.path || '';\n\n      if (latestFile) {\n        console.log(`📹 Latest video file: ${latestFile}`);\n      }\n\n      return latestFile;\n    } catch (error) {\n      console.warn('⚠️ Error finding video file:', error);\n      return '';\n    }\n  }\n\n  /**\n   * Captura rápida de video con configuración predeterminada\n   */\n  static async quickCapture(\n    url: string = SHARED_CONFIG.baseURL,\n    duration = 15000\n  ): Promise<CaptureResult> {\n    const capture = new VideoCapture({\n      url,\n      duration,\n      browserType: 'brave',\n      showInteractions: true,\n    });\n    return await capture.capture();\n  }\n\n  /**\n   * Captura de demo básica (15 segundos con interacciones estándar)\n   */\n  static async captureDemo(): Promise<CaptureResult> {\n    return await this.quickCapture(SHARED_CONFIG.baseURL, 20000);\n  }\n\n  /**\n   * Captura de demo completa (30 segundos con workflow completo)\n   */\n  static async captureFullDemo(): Promise<CaptureResult> {\n    const capture = new VideoCapture({\n      url: SHARED_CONFIG.baseURL,\n      duration: 30000,\n      browserType: 'brave',\n      showInteractions: true,\n      includeAdvancedDemo: true,\n    });\n    return await capture.capture();\n  }\n}\n\nexport async function captureVideo(options?: VideoCaptureOptions): Promise<CaptureResult> {\n  const capture = new VideoCapture(options);\n  return await capture.capture();\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "options",
                        "type": "VideoCaptureOptions",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "defaultValue": "{}"
                    }
                ],
                "line": 17,
                "jsdoctags": [
                    {
                        "name": "options",
                        "type": "VideoCaptureOptions",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "defaultValue": "{}",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "options",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Required<Omit<VideoCaptureOptions, multiple>>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17,
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "methods": [
                {
                    "name": "capture",
                    "args": [],
                    "optional": false,
                    "returnType": "Promise<CaptureResult>",
                    "typeParameters": [],
                    "line": 34,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ]
                },
                {
                    "name": "captureDemo",
                    "args": [],
                    "optional": false,
                    "returnType": "Promise<CaptureResult>",
                    "typeParameters": [],
                    "line": 299,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nCaptura de demo básica (15 segundos con interacciones estándar)\n",
                    "description": "<p>Captura de demo básica (15 segundos con interacciones estándar)</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ]
                },
                {
                    "name": "captureFullDemo",
                    "args": [],
                    "optional": false,
                    "returnType": "Promise<CaptureResult>",
                    "typeParameters": [],
                    "line": 306,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nCaptura de demo completa (30 segundos con workflow completo)\n",
                    "description": "<p>Captura de demo completa (30 segundos con workflow completo)</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ]
                },
                {
                    "name": "findLatestVideoFile",
                    "args": [
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<string>",
                    "typeParameters": [],
                    "line": 234,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nBusca el archivo de video más reciente en el directorio de salida\n",
                    "description": "<p>Busca el archivo de video más reciente en el directorio de salida</p>\n",
                    "modifierKind": [
                        123,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "performAdvancedDemo",
                    "args": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 130,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\n⚡ NUEVO: Demo avanzada que muestra más características\n",
                    "description": "<p>⚡ NUEVO: Demo avanzada que muestra más características</p>\n",
                    "modifierKind": [
                        123,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "Page",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "quickCapture",
                    "args": [
                        {
                            "name": "url",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "SHARED_CONFIG.baseURL"
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "15000"
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<CaptureResult>",
                    "typeParameters": [],
                    "line": 283,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nCaptura rápida de video con configuración predeterminada\n",
                    "description": "<p>Captura rápida de video con configuración predeterminada</p>\n",
                    "modifierKind": [
                        126,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "url",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "SHARED_CONFIG.baseURL",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "15000",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        }
    ],
    "directives": [],
    "components": [
        {
            "name": "AccordionComponent",
            "id": "component-AccordionComponent-445bbb3611363790961e8dd46d8670559cb580dfa625ff8e5753fdfd74d4a0dd0733a38ffb833669a2075dc10f754f5d434e8a5cbd9f810ff3d873dcad6e5bf0",
            "file": "src/app/components/ui/accordion/accordion.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-accordion",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./accordion.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "expanded",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 10,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 11,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "title",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 9,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "toggle",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 13,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-accordion',\n  standalone: true,\n  templateUrl: './accordion.component.html',\n})\nexport class AccordionComponent {\n  @Input() title = '';\n  @Input() expanded = false;\n  @Input() icon?: string;\n\n  toggle(): void {\n    this.expanded = !this.expanded;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<div class=\"metro-accordion\">\n  <button\n    type=\"button\"\n    class=\"metro-accordion-header\"\n    (click)=\"toggle()\"\n    [attr.aria-expanded]=\"expanded\"\n  >\n    <div class=\"accordion-title-section\">\n      @if (icon) {\n        <span [class]=\"icon + ' accordion-icon'\"></span>\n      }\n      <span class=\"accordion-title\">{{ title }}</span>\n    </div>\n    \n    @if (expanded) {\n      <span class=\"icon-[iconoir--nav-arrow-up] accordion-chevron\"></span>\n    } @else {\n      <span class=\"icon-[iconoir--nav-arrow-down] accordion-chevron\"></span>\n    }\n  </button>\n  \n  @if (expanded) {\n    <div class=\"metro-accordion-content\">\n      <ng-content />\n    </div>\n  }\n</div>"
        },
        {
            "name": "AnalysisPanelComponent",
            "id": "component-AnalysisPanelComponent-2b245ee2f221fd7660980b99bb7705281f89720740969f8b6fd377319e7ad0ee82c03f5c08db2e9dc1956112fb67663e8a4208df091cf46939a3b11e7b5197c9",
            "file": "src/app/components/ui/analysis-panel/analysis-panel.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-analysis-panel",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./analysis-panel.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "compact",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 21,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "metrics",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 20,
                    "type": "AnalysisMetric[]",
                    "decorators": []
                },
                {
                    "name": "title",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 19,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "getMetricVariant",
                    "args": [
                        {
                            "name": "metric",
                            "type": "AnalysisMetric",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 23,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "metric",
                            "type": "AnalysisMetric",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getProgressWidth",
                    "args": [
                        {
                            "name": "metric",
                            "type": "AnalysisMetric",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 27,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "metric",
                            "type": "AnalysisMetric",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CardComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CardComponent } from '../card/card.component';\n\nexport interface AnalysisMetric {\n  label: string;\n  value: number | string;\n  maxValue?: number;\n  variant?: 'default' | 'success' | 'warning' | 'error';\n  icon?: string;\n}\n\n@Component({\n  selector: 'app-analysis-panel',\n  standalone: true,\n  imports: [CardComponent],\n  templateUrl: './analysis-panel.component.html',\n})\nexport class AnalysisPanelComponent {\n  @Input() title = '';\n  @Input() metrics: AnalysisMetric[] = [];\n  @Input() compact = false;\n\n  getMetricVariant(metric: AnalysisMetric): string {\n    return `metric-${metric.variant || 'default'}`;\n  }\n\n  getProgressWidth(metric: AnalysisMetric): string {\n    if (metric.maxValue && typeof metric.value === 'number') {\n      const percentage = (metric.value / metric.maxValue) * 100;\n      return `${Math.min(percentage, 100)}%`;\n    }\n    return '0%';\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card [padding]=\"compact ? 'small' : 'medium'\">\n  <div class=\"analysis-panel\">\n    <h3 class=\"panel-title\">{{ title }}</h3>\n    \n    <div class=\"metrics-grid\">\n      @for (metric of metrics; track metric.label) {\n        <div class=\"metric-item\">\n          <div class=\"metric-header\">\n            @if (metric.icon) {\n              <span [class]=\"metric.icon + ' metric-icon'\"></span>\n            }\n            <span class=\"metric-label\">{{ metric.label }}</span>\n            <span class=\"metric-value\">{{ metric.value }}</span>\n          </div>\n          \n          @if (metric.maxValue && typeof metric.value === 'number') {\n            <div class=\"metric-progress\">\n              <div \n                class=\"metric-progress-bar\"\n                [class]=\"getMetricVariant(metric)\"\n                [style.width]=\"getProgressWidth(metric)\"\n              ></div>\n            </div>\n          }\n        </div>\n      }\n    </div>\n  </div>\n</app-card>"
        },
        {
            "name": "App",
            "id": "component-App-20af9a21b33d0f482f24984a71a25adb75f37272056bf0109d26364070250341c83a150af55555c98b471690af1ee56c2ec7394918ae0036551341060cfe3fe9",
            "file": "src/app/app.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-root",
            "styleUrls": [],
            "styles": [],
            "template": "<app-toast-container />\n<app-poetry-page />\n",
            "templateUrl": [],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "PoetryPageComponent",
                    "type": "component"
                },
                {
                    "name": "ToastContainerComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component } from '@angular/core';\nimport { PoetryPageComponent } from './components/layout/poetry-page/poetry-page.component';\nimport { ToastContainerComponent } from './components/metro/toast-container/toast-container.component';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [PoetryPageComponent, ToastContainerComponent],\n  template: `\n    <app-toast-container />\n    <app-poetry-page />\n  `,\n})\nexport class App {}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": []
        },
        {
            "name": "AppBarComponent",
            "id": "component-AppBarComponent-e2b9c1c22b3661e41ffb4d97c5f3f2661396ff2f7a1d5f44a0fb7f0d1c26a8dffab14706f2858074a38dc4a9387a9f50a316802752f408c20e23b8e8daa58fe2",
            "file": "src/app/components/metro/appbar/appbar.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-appbar",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./appbar.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "actions",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 19,
                    "type": "AppBarAction[]",
                    "decorators": []
                },
                {
                    "name": "hidden",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 20,
                    "type": "boolean",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "actionClick",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 21,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "onActionClick",
                    "args": [
                        {
                            "name": "actionId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "disabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 23,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "actionId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "disabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nexport interface AppBarAction {\n  id: string;\n  icon: string;\n  label: string;\n  disabled?: boolean;\n}\n\n@Component({\n  selector: 'app-appbar',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './appbar.component.html',\n})\nexport class AppBarComponent {\n  @Input() actions: AppBarAction[] = [];\n  @Input() hidden = false;\n  @Output() actionClick = new EventEmitter<string>();\n\n  onActionClick(actionId: string, disabled?: boolean): void {\n    if (!disabled) {\n      this.actionClick.emit(actionId);\n    }\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<!-- appbar.component.html -->\n<div \n  class=\"metro-appbar\"\n  [class.appbar-hidden]=\"hidden\"\n>\n  <div class=\"appbar-start\">\n    <ng-content select=\"[slot='start']\" />\n  </div>\n\n  <div class=\"appbar-center\">\n    @for (action of actions; track action.id) {\n      <button\n        type=\"button\"\n        class=\"metro-command-button\"\n        [disabled]=\"action.disabled\"\n        (click)=\"onActionClick(action.id, action.disabled)\"\n      >\n        <span [class]=\"action.icon + ' command-icon'\"></span>\n        <span class=\"command-label\">{{ action.label }}</span>\n      </button>\n    }\n  </div>\n\n  <div class=\"appbar-end\">\n    <ng-content select=\"[slot='end']\" />\n  </div>\n</div>"
        },
        {
            "name": "BadgeComponent",
            "id": "component-BadgeComponent-f2f34ee1e09d2a39b10636d8b030818597c54c5c0d1370aa3a3f018e4c561f2bae574245bedc1f7752007b5a38cb4a15815ce0cd399de85b75db1defffc2a5fc",
            "file": "src/app/components/ui/badge/badge.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-badge",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./badge.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 11,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "size",
                    "defaultValue": "'medium'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 10,
                    "type": "\"small\" | \"medium\"",
                    "decorators": []
                },
                {
                    "name": "variant",
                    "defaultValue": "'default'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 9,
                    "type": "\"default\" | \"info\" | \"success\" | \"warning\" | \"error\"",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-badge',\n  standalone: true,\n  templateUrl: './badge.component.html',\n})\nexport class BadgeComponent {\n  @Input() variant: 'default' | 'info' | 'success' | 'warning' | 'error' = 'default';\n  @Input() size: 'small' | 'medium' = 'medium';\n  @Input() icon?: string;\n\n  get badgeClasses(): string {\n    return `badge-${this.variant} badge-${this.size}`;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "accessors": {
                "badgeClasses": {
                    "name": "badgeClasses",
                    "getSignature": {
                        "name": "badgeClasses",
                        "type": "string",
                        "returnType": "string",
                        "line": 13
                    }
                }
            },
            "templateData": "<span [class]=\"badgeClasses\">\n  @if (icon) {\n    <span [class]=\"icon\"></span>\n  }\n  <ng-content />\n</span>"
        },
        {
            "name": "ButtonComponent",
            "id": "component-ButtonComponent-1038697c02f5d2e6b3d474c47190ad32dada1bff889730491450094713a066cbef2b7929a59f5cca48c6bfd43a917cfef4bc2a36ce5fbf78ee21df4e4ad225e8",
            "file": "src/app/components/ui/button/button.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-button",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./button.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "disabled",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 13,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 12,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "label",
                    "defaultValue": "'Button'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 11,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "size",
                    "defaultValue": "'medium'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 10,
                    "type": "\"small\" | \"medium\" | \"large\"",
                    "decorators": []
                },
                {
                    "name": "variant",
                    "defaultValue": "'primary'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 9,
                    "type": "\"primary\" | \"secondary\" | \"outline\"",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "clicked",
                    "defaultValue": "new EventEmitter<Event>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 14,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'app-button',\n  standalone: true,\n  templateUrl: './button.component.html',\n})\nexport class ButtonComponent {\n  @Input() variant: 'primary' | 'secondary' | 'outline' = 'primary';\n  @Input() size: 'small' | 'medium' | 'large' = 'medium';\n  @Input() label = 'Button';\n  @Input() icon?: string;\n  @Input() disabled = false;\n  @Output() clicked = new EventEmitter<Event>();\n\n  get buttonClasses(): string {\n    const sizeClasses = {\n      small: 'btn-small',\n      medium: 'btn-medium',\n      large: 'btn-large',\n    };\n\n    const variantClasses = {\n      primary: 'btn-primary',\n      secondary: 'btn-secondary',\n      outline: 'btn-outline',\n    };\n\n    return `btn-base ${sizeClasses[this.size]} ${variantClasses[this.variant]}`;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "accessors": {
                "buttonClasses": {
                    "name": "buttonClasses",
                    "getSignature": {
                        "name": "buttonClasses",
                        "type": "string",
                        "returnType": "string",
                        "line": 16
                    }
                }
            },
            "templateData": "<button\n  type=\"button\"\n  (click)=\"!disabled && clicked.emit($event)\"\n  [class]=\"buttonClasses\"\n  [disabled]=\"disabled\"\n>\n  @if (icon) {\n    <span [class]=\"icon\"></span>\n  }\n  {{ label }}\n</button>\n"
        },
        {
            "name": "CardComponent",
            "id": "component-CardComponent-27824ee1b72b2fa55dedcdc921e8fbb3d83c9866b34f3a4887eb045a87e9a633c5ed5fe1867da44c85f54ed02cba5ff890694de7c9ff6bf05ea6789502cce200",
            "file": "src/app/components/ui/card/card.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-card",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./card.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "clickable",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 11,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "padding",
                    "defaultValue": "'medium'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 10,
                    "type": "\"none\" | \"small\" | \"medium\" | \"large\"",
                    "decorators": []
                },
                {
                    "name": "variant",
                    "defaultValue": "'default'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 9,
                    "type": "\"default\" | \"elevated\"",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-card',\n  standalone: true,\n  templateUrl: './card.component.html',\n})\nexport class CardComponent {\n  @Input() variant: 'default' | 'elevated' = 'default';\n  @Input() padding: 'none' | 'small' | 'medium' | 'large' = 'medium';\n  @Input() clickable = false;\n\n  get cardClasses(): string {\n    const classes = [`card-${this.variant}`, `card-padding-${this.padding}`];\n\n    if (this.clickable) {\n      classes.push('clickable');\n    }\n\n    return classes.join(' ');\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "accessors": {
                "cardClasses": {
                    "name": "cardClasses",
                    "getSignature": {
                        "name": "cardClasses",
                        "type": "string",
                        "returnType": "string",
                        "line": 13
                    }
                }
            },
            "templateData": "<div \n  [class]=\"cardClasses\"\n  [class.clickable]=\"clickable\"\n>\n  <ng-content />\n</div>"
        },
        {
            "name": "FooterComponent",
            "id": "component-FooterComponent-dc904eb9c0678816656fae0614782af9663c3fe8dab871a7522e3bf9ea5dc38ca0e0c74934b46765be5a81ee1fc31a41093d7af807c7e22caeb09fcd7a7900e1",
            "file": "src/app/components/layout/footer/footer.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-footer",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./footer.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "currentYear",
                    "defaultValue": "new Date().getFullYear()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 9
                }
            ],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-footer',\n  standalone: true,\n  templateUrl: './footer.component.html',\n})\nexport class FooterComponent {\n  currentYear = new Date().getFullYear();\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<footer class=\"metro-footer\">\n  <div class=\"footer-content\">\n    <div class=\"footer-brand\">\n      <span class=\"icon-[iconoir--flower] footer-icon\"></span>\n      <span class=\"footer-title\">harawihark</span>\n    </div>\n    \n    <div class=\"footer-info\">\n      <p class=\"footer-description\">\n        Advanced syllable-meter checker with suggestions\n      </p>\n      <div class=\"footer-links\">\n        <a \n          href=\"https://github.com/benitoanagua/HarawiHark\" \n          target=\"_blank\" \n          rel=\"noopener noreferrer\"\n          class=\"footer-link\"\n          aria-label=\"GitHub Repository\"\n        >\n          <span class=\"icon-[iconoir--github]\"></span>\n          GitHub\n        </a>\n        <span class=\"footer-copyright\">\n          &copy; {{ currentYear }} harawihark\n        </span>\n      </div>\n    </div>\n  </div>\n</footer>"
        },
        {
            "name": "HeaderComponent",
            "id": "component-HeaderComponent-cff8ef446590fc15f57e7a98451d3ae0f567d22cc1415f58bdd1015fc714b95e72af582b2108b0a59db1c872786423c64837d64c7a74361142934872533c093d",
            "file": "src/app/components/layout/header/header.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-header",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./header.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "ThemeToggleComponent",
                    "type": "component"
                },
                {
                    "name": "RouterModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component } from '@angular/core';\nimport { ThemeToggleComponent } from '../../theme-toggle/theme-toggle.component';\nimport { RouterModule } from '@angular/router';\n\n@Component({\n  selector: 'app-header',\n  standalone: true,\n  imports: [ThemeToggleComponent, RouterModule],\n  templateUrl: './header.component.html',\n})\nexport class HeaderComponent {}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<header class=\"metro-header\">\n  <div class=\"header-content\">\n    <div class=\"logo-section\">\n      <a \n        routerLink=\"/\" \n        class=\"logo-wrapper\"\n        aria-label=\"Go to homepage\"\n      >\n        <span class=\"icon-[iconoir--flower] text-2xl text-primary\"></span>\n        <h1 class=\"logo-title\">harawihark</h1>\n      </a>\n    </div>\n\n    <div class=\"nav-section\">\n      <a \n        href=\"https://github.com/benitoanagua/HarawiHark\" \n        target=\"_blank\" \n        rel=\"noopener noreferrer\"\n        class=\"github-link\"\n        aria-label=\"GitHub Repository\"\n      >\n        <span class=\"icon-[iconoir--github] text-xl\"></span>\n      </a>\n      \n      <app-theme-toggle />\n    </div>\n  </div>\n</header>"
        },
        {
            "name": "InputComponent",
            "id": "component-InputComponent-fb4a73b3a4f3ed8acf809fe1e6c9ab3eda66abaea03f162608c6190e9b0db00073d6af15352c56ef85ae5388677d03000560fdd867353d464d185efef933d70f",
            "file": "src/app/components/ui/input/input.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [
                {
                    "name": ")"
                }
            ],
            "selector": "app-input",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./input.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "disabled",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 21,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "error",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 20,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "id",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 23,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "label",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 18,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "placeholder",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 19,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "rows",
                    "defaultValue": "6",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 22,
                    "type": "number",
                    "decorators": []
                },
                {
                    "name": "type",
                    "defaultValue": "'text'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 17,
                    "type": "\"text\" | \"textarea\"",
                    "decorators": []
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 26,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "inputBlur",
                    "defaultValue": "new EventEmitter<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 37,
                    "type": "EventEmitter"
                },
                {
                    "name": "inputChange",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 36,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "_value",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 34
                },
                {
                    "name": "onChange",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 39,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "onTouched",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 42,
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "onBlur",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 69,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onInput",
                    "args": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 62,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnChange",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "string",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ]
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 50,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "string",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnTouched",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": []
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 54,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setDisabledState",
                    "args": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 58,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "writeValue",
                    "args": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 46,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter, forwardRef } from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\n\n@Component({\n  selector: 'app-input',\n  standalone: true,\n  templateUrl: './input.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => InputComponent),\n      multi: true,\n    },\n  ],\n})\nexport class InputComponent implements ControlValueAccessor {\n  @Input() type: 'text' | 'textarea' = 'text';\n  @Input() label = '';\n  @Input() placeholder = '';\n  @Input() error = '';\n  @Input() disabled = false;\n  @Input() rows = 6;\n  @Input() id = '';\n\n  @Input()\n  get value(): string {\n    return this._value;\n  }\n  set value(val: string) {\n    this._value = val || '';\n    this.onChange(this._value);\n  }\n\n  _value = '';\n\n  @Output() inputChange = new EventEmitter<string>();\n  @Output() inputBlur = new EventEmitter<void>();\n\n  private onChange: (value: string) => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private onTouched: () => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n\n  writeValue(value: string): void {\n    this._value = value || '';\n  }\n\n  registerOnChange(fn: (value: string) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  onInput(event: Event): void {\n    const target = event.target as HTMLInputElement | HTMLTextAreaElement;\n    this._value = target.value;\n    this.onChange(this._value);\n    this.inputChange.emit(this._value);\n  }\n\n  onBlur(): void {\n    this.onTouched();\n    this.inputBlur.emit();\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "implements": [
                "ControlValueAccessor"
            ],
            "accessors": {
                "value": {
                    "name": "value",
                    "setSignature": {
                        "name": "value",
                        "type": "void",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "args": [
                            {
                                "name": "val",
                                "type": "string",
                                "deprecated": false,
                                "deprecationMessage": ""
                            }
                        ],
                        "returnType": "void",
                        "line": 29,
                        "jsdoctags": [
                            {
                                "name": "val",
                                "type": "string",
                                "deprecated": false,
                                "deprecationMessage": "",
                                "tagName": {
                                    "text": "param"
                                }
                            }
                        ]
                    },
                    "getSignature": {
                        "name": "value",
                        "type": "string",
                        "returnType": "string",
                        "line": 26
                    }
                }
            },
            "templateData": "<div class=\"input-wrapper\">\n  @if (label) {\n    <label class=\"input-label\" [for]=\"id\">{{ label }}</label>\n  }\n\n  @if (type === 'textarea') {\n    <textarea\n      class=\"input-base input-textarea\"\n      [class.input-error]=\"error\"\n      [placeholder]=\"placeholder\"\n      [disabled]=\"disabled\"\n      [rows]=\"rows\"\n      [value]=\"_value\"\n      [id]=\"id\"\n      (input)=\"onInput($event)\"\n      (blur)=\"onBlur()\"\n    ></textarea>\n  } @else {\n    <input\n      class=\"input-base input-text\"\n      [class.input-error]=\"error\"\n      [type]=\"type\"\n      [placeholder]=\"placeholder\"\n      [disabled]=\"disabled\"\n      [value]=\"_value\"\n      [id]=\"id\"\n      (input)=\"onInput($event)\"\n      (blur)=\"onBlur()\"\n    />\n  }\n\n  @if (error) {\n    <span class=\"input-error-text\">{{ error }}</span>\n  }\n</div>\n"
        },
        {
            "name": "ListItemComponent",
            "id": "component-ListItemComponent-1c23a442acb047d09d16f71fb7de3427948d9630af4cc822c26320514a920f01b1bc4ac023ee03c30824105764e06390699bdc0e2851dd56adb6f0907880c73a",
            "file": "src/app/components/metro/list-item/list-item.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-list-item",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./list-item.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "badge",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 15,
                    "type": "string | number",
                    "decorators": []
                },
                {
                    "name": "disabled",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 18,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 14,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "meta",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 16,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "showChevron",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 17,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "subtitle",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 13,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "title",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 12,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "itemClick",
                    "defaultValue": "new EventEmitter<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 19,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "onClick",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 21,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-list-item',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './list-item.component.html',\n})\nexport class ListItemComponent {\n  @Input() title = '';\n  @Input() subtitle?: string;\n  @Input() icon?: string;\n  @Input() badge?: string | number;\n  @Input() meta?: string;\n  @Input() showChevron = true;\n  @Input() disabled = false;\n  @Output() itemClick = new EventEmitter<void>();\n\n  onClick(): void {\n    if (!this.disabled) {\n      this.itemClick.emit();\n    }\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<!-- list-item.component.html -->\n<button\n  type=\"button\"\n  class=\"metro-list-item\"\n  [disabled]=\"disabled\"\n  (click)=\"onClick()\"\n>\n  @if (icon) {\n    <div class=\"metro-list-item-leading\">\n      <span [class]=\"icon + ' metro-list-item-icon'\"></span>\n    </div>\n  }\n\n  <div class=\"metro-list-item-content\">\n    <span class=\"metro-list-item-title\">{{ title }}</span>\n    @if (subtitle) {\n      <span class=\"metro-list-item-subtitle\">{{ subtitle }}</span>\n    }\n  </div>\n\n  <div class=\"metro-list-item-trailing\">\n    @if (badge) {\n      <span class=\"metro-list-item-badge\">{{ badge }}</span>\n    }\n    @if (meta) {\n      <span class=\"metro-list-item-meta\">{{ meta }}</span>\n    }\n    @if (showChevron) {\n      <span class=\"icon-[iconoir--nav-arrow-right] metro-list-item-chevron\"></span>\n    }\n  </div>\n</button>"
        },
        {
            "name": "MeterAnalysisSectionComponent",
            "id": "component-MeterAnalysisSectionComponent-dc1f7dd0d9e7e996426d8d2ae0bdb01f8bfdde8a3f4ad5c8b4bf01bfba886804fba4b8f649b88b838faf4ca4d0625b632b8c108b886c4b5c92a66e6104f5bbd6",
            "file": "src/app/components/poetry/meter-analysis-section/meter-analysis-section.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-meter-analysis-section",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./meter-analysis-section.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "required": true,
                    "name": "result",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "optional": false,
                    "line": 13,
                    "type": "EnhancedPoetryResult",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                },
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "BadgeComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CardComponent, BadgeComponent } from '../../ui';\nimport { EnhancedPoetryResult } from '../../../services/';\n\n@Component({\n  selector: 'app-meter-analysis-section',\n  standalone: true,\n  imports: [CommonModule, CardComponent, BadgeComponent],\n  templateUrl: './meter-analysis-section.component.html',\n})\nexport class MeterAnalysisSectionComponent {\n  @Input({ required: true }) result!: EnhancedPoetryResult;\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card padding=\"large\">\n  <div class=\"meter-analysis-container\">\n    <h3 class=\"section-title\">rhythm & meter analysis</h3>\n    \n    @if (result.meterAnalysis; as meter) {\n      <div class=\"meter-info\">\n        <div class=\"meter-header\">\n          <app-badge \n            [variant]=\"meter.consistency > 70 ? 'success' : meter.consistency > 40 ? 'warning' : 'error'\"\n            size=\"medium\"\n            icon=\"icon-[iconoir--music-note]\"\n          >\n            {{ meter.type }} meter\n          </app-badge>\n          <span class=\"consistency-score\">\n            {{ meter.consistency.toFixed(0) }}% consistent\n          </span>\n        </div>\n        \n        <p class=\"meter-pattern\">{{ meter.pattern }}</p>\n        <p class=\"meter-description\">{{ meter.description }}</p>\n        \n        @if (meter.examples.length > 0) {\n          <div class=\"meter-examples\">\n            <h4>examples of {{ meter.type }} meter:</h4>\n            <ul class=\"examples-list\">\n              @for (example of meter.examples; track $index) {\n                <li class=\"example-item\">{{ example }}</li>\n              }\n            </ul>\n          </div>\n        }\n      </div>\n    } @else {\n      <div class=\"no-meter-analysis\">\n        <span class=\"icon-[iconoir--music-note-solid] no-meter-icon\"></span>\n        <p class=\"no-meter-text\">No consistent meter pattern detected</p>\n      </div>\n    }\n  </div>\n</app-card>"
        },
        {
            "name": "MultilineInputComponent",
            "id": "component-MultilineInputComponent-b2b38f3e364650d03899dc34d883b21b1b9e33d42f4c735755881c0d6c700eff664be1af9ccd2e4d65301e2e55a31e7a9b581178af334913b9c04dab44b87fd3",
            "file": "src/app/components/ui/multiline-input/multiline-input.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [
                {
                    "name": ")"
                }
            ],
            "selector": "app-multiline-input",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./multiline-input.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "disabled",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 49,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "error",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 48,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "expectedPattern",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 54,
                    "type": "number[]",
                    "decorators": []
                },
                {
                    "name": "fontSizeClass",
                    "defaultValue": "'text-base'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 55,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "id",
                    "defaultValue": "'multiline-input'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 51,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "label",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 46,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "placeholder",
                    "defaultValue": "'Write your poem line by line...'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 47,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "rows",
                    "defaultValue": "12",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 50,
                    "type": "number",
                    "decorators": []
                },
                {
                    "name": "showLineNumbers",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 52,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "showLineValidation",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 53,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 70,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "inputBlur",
                    "defaultValue": "new EventEmitter<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 79,
                    "type": "EventEmitter"
                },
                {
                    "name": "lineFocus",
                    "defaultValue": "new EventEmitter<{ index: number; text: string }>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 80,
                    "type": "EventEmitter"
                },
                {
                    "name": "lineValidationChange",
                    "defaultValue": "new EventEmitter<LineData[]>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 81,
                    "type": "EventEmitter"
                },
                {
                    "name": "valueChange",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 78,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "focusedLineIndex",
                    "defaultValue": "signal<number | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 61,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "isInternalUpdate",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 89,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "lines",
                    "defaultValue": "signal<LineData[]>([])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 60,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "onChange",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 83,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "onTouched",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 86,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "poemText",
                    "defaultValue": "computed(() =>\n    this.lines()\n      .map((l) => l.text)\n      .join('\\n')\n  )",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 63,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 57,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "stateService",
                    "defaultValue": "inject(StateService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 58,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "clear",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 321,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "emitChanges",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 290,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "focus",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 327,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "focusLine",
                    "args": [
                        {
                            "name": "index",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 226,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "index",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getSyllableCountClass",
                    "args": [
                        {
                            "name": "line",
                            "type": "LineData",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 310,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "LineData",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getSyllableSegments",
                    "args": [
                        {
                            "name": "line",
                            "type": "LineData",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "SyllableSegment[]",
                    "typeParameters": [],
                    "line": 295,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "LineData",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "handleKeyboardNavigation",
                    "args": [
                        {
                            "name": "event",
                            "type": "KeyboardEvent",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 193,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "decorators": [
                        {
                            "name": "HostListener",
                            "stringifiedArguments": "'keydown', ['$event']"
                        }
                    ],
                    "modifierKind": [
                        171
                    ],
                    "jsdoctags": [
                        {
                            "name": "event",
                            "type": "KeyboardEvent",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "handleLineInput",
                    "args": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "index",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 336,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "index",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "initializeLines",
                    "args": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 117,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "insertTextAtCursor",
                    "args": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 234,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onLineBlur",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 186,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onLineFocus",
                    "args": [
                        {
                            "name": "index",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 181,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "index",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onLineInput",
                    "args": [
                        {
                            "name": "index",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 160,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "index",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnChange",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "string",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ]
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 148,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "string",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnTouched",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": []
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 152,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setDisabledState",
                    "args": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 156,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setText",
                    "args": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 331,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "updateLineSyllables",
                    "args": [
                        {
                            "name": "line",
                            "type": "LineData",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 264,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "LineData",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "updateLineValidation",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 278,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "writeValue",
                    "args": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 142,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [
                {
                    "name": "keydown",
                    "args": [
                        {
                            "name": "event",
                            "type": "KeyboardEvent",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "argsDecorator": [
                        "$event"
                    ],
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 193
                }
            ],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {\n  Component,\n  Input,\n  Output,\n  EventEmitter,\n  forwardRef,\n  HostListener,\n  signal,\n  computed,\n  inject,\n  effect,\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\nimport { RitaService, StateService } from '../../../services/';\n\nexport interface LineData {\n  text: string;\n  number: number;\n  focused: boolean;\n  syllables: number;\n  expectedSyllables: number;\n  isCorrect: boolean;\n  isOver: boolean;\n}\n\nexport interface SyllableSegment {\n  index: number;\n  filled: boolean;\n}\n\n@Component({\n  selector: 'app-multiline-input',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './multiline-input.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => MultilineInputComponent),\n      multi: true,\n    },\n  ],\n})\nexport class MultilineInputComponent implements ControlValueAccessor {\n  @Input() label = '';\n  @Input() placeholder = 'Write your poem line by line...';\n  @Input() error = '';\n  @Input() disabled = false;\n  @Input() rows = 12;\n  @Input() id = 'multiline-input';\n  @Input() showLineNumbers = true;\n  @Input() showLineValidation = false;\n  @Input() expectedPattern: number[] = [];\n  @Input() fontSizeClass = 'text-base';\n\n  private readonly rita = inject(RitaService);\n  private readonly stateService = inject(StateService);\n\n  readonly lines = signal<LineData[]>([]);\n  readonly focusedLineIndex = signal<number | null>(null);\n\n  readonly poemText = computed(() =>\n    this.lines()\n      .map((l) => l.text)\n      .join('\\n')\n  );\n\n  @Input()\n  get value(): string {\n    return this.poemText();\n  }\n  set value(val: string) {\n    this.initializeLines(val || '');\n    this.onChange(this.poemText());\n  }\n\n  @Output() valueChange = new EventEmitter<string>();\n  @Output() inputBlur = new EventEmitter<void>();\n  @Output() lineFocus = new EventEmitter<{ index: number; text: string }>();\n  @Output() lineValidationChange = new EventEmitter<LineData[]>();\n\n  private onChange: (value: string) => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private onTouched: () => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private isInternalUpdate = false;\n\n  constructor() {\n    this.initializeLines('');\n\n    effect(() => {\n      const pattern = this.stateService.currentPattern();\n      const newRows = this.stateService.expectedLines();\n      const sharedText = this.stateService.poemText();\n      const shouldLoadExample = this.stateService.shouldLoadExample();\n\n      if (pattern.length > 0) {\n        this.expectedPattern = pattern;\n        this.rows = newRows;\n\n        if (shouldLoadExample) {\n          this.stateService.loadExample();\n          this.stateService.consumeLoadExample();\n          return;\n        }\n\n        if (!this.isInternalUpdate && sharedText !== this.poemText()) {\n          this.initializeLines(sharedText);\n        }\n      }\n    });\n  }\n\n  private initializeLines(text: string): void {\n    const linesArray = text.split('\\n');\n    const total = this.rows;\n    const result: LineData[] = [];\n\n    for (let i = 0; i < total; i++) {\n      const expectedSyllables = this.expectedPattern[i] || 0;\n      const lineText = linesArray[i] || '';\n      const syllables = lineText ? this.rita.analyzeLine(lineText).syllables : 0;\n\n      result.push({\n        text: lineText,\n        number: i + 1,\n        focused: false,\n        syllables,\n        expectedSyllables,\n        isCorrect: syllables === expectedSyllables && syllables > 0,\n        isOver: syllables > expectedSyllables,\n      });\n    }\n\n    this.lines.set(result);\n    this.updateLineValidation();\n  }\n\n  writeValue(value: string): void {\n    if (!this.isInternalUpdate) {\n      this.initializeLines(value || '');\n    }\n  }\n\n  registerOnChange(fn: (value: string) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  onLineInput(index: number, text: string): void {\n    this.isInternalUpdate = true;\n\n    const updated = [...this.lines()];\n    updated[index].text = text;\n\n    if (this.showLineValidation) {\n      this.updateLineSyllables(updated[index]);\n    }\n\n    this.lines.set(updated);\n    this.emitChanges();\n    this.updateLineValidation();\n\n    this.stateService.updatePoemLines(updated.map((line) => line.text));\n\n    setTimeout(() => {\n      this.isInternalUpdate = false;\n    }, 0);\n  }\n\n  onLineFocus(index: number): void {\n    this.focusedLineIndex.set(index);\n    this.lineFocus.emit({ index, text: this.lines()[index].text });\n  }\n\n  onLineBlur(): void {\n    this.focusedLineIndex.set(null);\n    this.onTouched();\n    this.inputBlur.emit();\n  }\n\n  @HostListener('keydown', ['$event'])\n  handleKeyboardNavigation(event: KeyboardEvent): void {\n    const current = this.focusedLineIndex();\n    if (current === null) return;\n\n    const lines = this.lines();\n\n    switch (event.key) {\n      case 'ArrowUp':\n        event.preventDefault();\n        if (current > 0) this.focusLine(current - 1);\n        break;\n\n      case 'ArrowDown':\n        event.preventDefault();\n        if (current < lines.length - 1) this.focusLine(current + 1);\n        break;\n\n      case 'Enter':\n        if (!event.shiftKey) {\n          event.preventDefault();\n          if (current < lines.length - 1) {\n            this.focusLine(current + 1);\n          }\n        }\n        break;\n\n      case 'Tab':\n        event.preventDefault();\n        this.insertTextAtCursor('  ');\n        break;\n    }\n  }\n\n  private focusLine(index: number): void {\n    const input = document.getElementById(`${this.id}-line-${index}`) as HTMLInputElement;\n    if (!input) return;\n\n    input.focus();\n    this.focusedLineIndex.set(index);\n  }\n\n  private insertTextAtCursor(text: string): void {\n    const current = this.focusedLineIndex();\n    if (current === null) return;\n\n    const input = document.getElementById(`${this.id}-line-${current}`) as HTMLInputElement;\n    if (!input) return;\n\n    const start = input.selectionStart || 0;\n    const end = input.selectionEnd || 0;\n    const currentText = this.lines()[current].text;\n\n    const newText = currentText.substring(0, start) + text + currentText.substring(end);\n\n    const updated = [...this.lines()];\n    updated[current].text = newText;\n\n    if (this.showLineValidation) {\n      this.updateLineSyllables(updated[current]);\n    }\n\n    this.lines.set(updated);\n    this.emitChanges();\n    this.updateLineValidation();\n\n    setTimeout(() => {\n      input.focus();\n      input.setSelectionRange(start + text.length, start + text.length);\n    });\n  }\n\n  private updateLineSyllables(line: LineData): void {\n    if (!line.text.trim()) {\n      line.syllables = 0;\n      line.isCorrect = false;\n      line.isOver = false;\n      return;\n    }\n\n    const analysis = this.rita.analyzeLine(line.text);\n    line.syllables = analysis.syllables;\n    line.isCorrect = line.syllables === line.expectedSyllables;\n    line.isOver = line.syllables > line.expectedSyllables;\n  }\n\n  private updateLineValidation(): void {\n    if (this.showLineValidation) {\n      const lines = this.lines();\n      lines.forEach((line) => {\n        if (line.text.trim()) {\n          this.updateLineSyllables(line);\n        }\n      });\n      this.lineValidationChange.emit(lines);\n    }\n  }\n\n  private emitChanges(): void {\n    this.onChange(this.poemText());\n    this.valueChange.emit(this.poemText());\n  }\n\n  getSyllableSegments(line: LineData): SyllableSegment[] {\n    const segments: SyllableSegment[] = [];\n    const expected = line.expectedSyllables;\n    const current = line.syllables;\n\n    for (let i = 0; i < expected; i++) {\n      segments.push({\n        index: i,\n        filled: i < current,\n      });\n    }\n\n    return segments;\n  }\n\n  getSyllableCountClass(line: LineData): string {\n    if (line.syllables === 0) return 'syllable-count-empty';\n    if (line.syllables === line.expectedSyllables) return 'syllable-count-perfect';\n    if (line.syllables > line.expectedSyllables) return 'syllable-count-over';\n\n    const progress = (line.syllables / line.expectedSyllables) * 100;\n    if (progress >= 75) return 'syllable-count-close';\n    if (progress >= 50) return 'syllable-count-medium';\n    return 'syllable-count-low';\n  }\n\n  clear(): void {\n    this.initializeLines('');\n    this.emitChanges();\n    this.focusLine(0);\n  }\n\n  focus(): void {\n    this.focusLine(0);\n  }\n\n  setText(text: string): void {\n    this.initializeLines(text);\n    this.emitChanges();\n  }\n\n  handleLineInput(event: Event, index: number): void {\n    const target = event.target as HTMLInputElement;\n    this.onLineInput(index, target.value);\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 89
            },
            "extends": [],
            "implements": [
                "ControlValueAccessor"
            ],
            "accessors": {
                "value": {
                    "name": "value",
                    "setSignature": {
                        "name": "value",
                        "type": "void",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "args": [
                            {
                                "name": "val",
                                "type": "string",
                                "deprecated": false,
                                "deprecationMessage": ""
                            }
                        ],
                        "returnType": "void",
                        "line": 73,
                        "jsdoctags": [
                            {
                                "name": "val",
                                "type": "string",
                                "deprecated": false,
                                "deprecationMessage": "",
                                "tagName": {
                                    "text": "param"
                                }
                            }
                        ]
                    },
                    "getSignature": {
                        "name": "value",
                        "type": "string",
                        "returnType": "string",
                        "line": 70
                    }
                }
            },
            "templateData": "<div class=\"multiline-input-wrapper\">\n  <div class=\"notebook-editor\" [class.disabled]=\"disabled\" [class]=\"fontSizeClass\">\n    <div #linesContainer class=\"lines-container\">\n      @for (line of lines(); track line.number; let index = $index) {\n        <div class=\"line-row\" \n             [class.focused]=\"focusedLineIndex() === index\">\n          \n          <div class=\"syllable-count\" \n               [class]=\"getSyllableCountClass(line)\">\n            {{ line.syllables }}/{{ line.expectedSyllables }}\n          </div>\n\n          <div class=\"line-input-container\">\n            <input\n              [id]=\"id + '-line-' + index\"\n              type=\"text\"\n              class=\"line-input\"\n              [placeholder]=\"index === 0 ? placeholder : 'Continue writing...'\"\n              [value]=\"line.text\"\n              [disabled]=\"disabled\"\n              (input)=\"handleLineInput($event, index)\"\n              (focus)=\"onLineFocus(index)\"\n              (blur)=\"onLineBlur()\"\n              autocomplete=\"off\"\n              spellcheck=\"false\"\n              [class]=\"fontSizeClass\"\n            />\n          </div>\n        </div>\n      }\n    </div>\n  </div>\n\n  @if (error) {\n    <span class=\"input-error-text\">{{ error }}</span>\n  }\n</div>"
        },
        {
            "name": "PanoramaComponent",
            "id": "component-PanoramaComponent-a1689931c14e935a7481b4adaa02a5edff65eca0a7ab2e641c04ffe1bb373885104f71cba98d07777c9ede7cd4f309dc9f9c452586819008afacf75b1d4ef5ee",
            "file": "src/app/components/metro/panorama/panorama.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-panorama",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./panorama.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-panorama',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './panorama.component.html',\n})\nexport class PanoramaComponent {}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<div class=\"panorama-container\">\n  <ng-content />\n</div>"
        },
        {
            "name": "PivotComponent",
            "id": "component-PivotComponent-abfe3bd76968416e3e585932504a29deab143cbe42168579def4858ffb8ad907f8caec6ed31cf18d91b80838fe19c44217aa33eeb57eab9e0dc27c36be543685",
            "file": "src/app/components/metro/pivot/pivot.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-pivot",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./pivot.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "items",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 18,
                    "type": "PivotItem[]",
                    "decorators": []
                },
                {
                    "name": "selectedId",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 19,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "selectedChange",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 20,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "select",
                    "args": [
                        {
                            "name": "id",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 22,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nexport interface PivotItem {\n  id: string;\n  label: string;\n  disabled?: boolean;\n}\n\n@Component({\n  selector: 'app-pivot',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './pivot.component.html',\n})\nexport class PivotComponent {\n  @Input() items: PivotItem[] = [];\n  @Input() selectedId = '';\n  @Output() selectedChange = new EventEmitter<string>();\n\n  select(id: string): void {\n    if (this.selectedId !== id) {\n      this.selectedId = id;\n      this.selectedChange.emit(id);\n    }\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<!-- pivot.component.html -->\n<nav class=\"metro-pivot\" role=\"tablist\">\n  @for (item of items; track item.id) {\n    <button\n      type=\"button\"\n      role=\"tab\"\n      [class.metro-pivot-active]=\"selectedId === item.id\"\n      [disabled]=\"item.disabled\"\n      [attr.aria-selected]=\"selectedId === item.id\"\n      (click)=\"select(item.id)\"\n      class=\"metro-pivot-item\"\n    >\n      {{ item.label }}\n    </button>\n  }\n</nav>"
        },
        {
            "name": "PoemEditorComponent",
            "id": "component-PoemEditorComponent-5db927cf5151e254cfe55d1a840456ab03165b4857e51ab7a74903dddfa44fefd95c9e3ad5eeec29daefa843517a3ba1aaded5cd94bcac2e39cdace0054ddcce",
            "file": "src/app/components/poetry/poem-editor/poem-editor.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-poem-editor",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./poem-editor.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "analyzer",
                    "defaultValue": "inject(PoetryAnalyzerService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 14,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "currentForm",
                    "defaultValue": "this.stateService.currentForm",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 23,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "currentPattern",
                    "defaultValue": "this.stateService.currentPattern",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 24,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "expectedLines",
                    "defaultValue": "this.stateService.expectedLines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 25,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "expectedSyllables",
                    "defaultValue": "computed(() => {\n    const form = this.currentForm();\n    return form ? form.pattern.reduce((sum: number, n: number) => sum + n, 0) : 0;\n  })",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 36,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "formOptions",
                    "defaultValue": "POETRY_FORM_OPTIONS",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 19,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "lineCount",
                    "defaultValue": "computed(() => this.lines().length)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 28,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "lines",
                    "defaultValue": "this.stateService.lines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 26,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "Math",
                    "defaultValue": "Math",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "poemText",
                    "defaultValue": "this.stateService.poemText",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "selectedForm",
                    "defaultValue": "this.stateService.selectedForm",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 21,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "stateService",
                    "defaultValue": "inject(StateService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "syllableProgress",
                    "defaultValue": "computed(() => {\n    const total = this.totalSyllables();\n    const expected = this.expectedSyllables();\n    return expected > 0 ? (total / expected) * 100 : 0;\n  })",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 41,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "toastService",
                    "defaultValue": "inject(ToastService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "totalSyllables",
                    "defaultValue": "computed(() => {\n    return this.lines().reduce((total, line) => {\n      return total + this.analyzer['rita'].analyzeLine(line).syllables;\n    }, 0);\n  })",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 30,
                    "modifierKind": [
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "analyze",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 89,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "clear",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 74,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "confirmClear",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 138,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "getCurrentPlaceholder",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 133,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getResponsiveFontClass",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 129,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "isReadyForAnalysis",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 125,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "loadExample",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 69,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onCopyPoem",
                    "args": [],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 105,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ]
                },
                {
                    "name": "onFormChange",
                    "args": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 59,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onTextChange",
                    "args": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 63,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                },
                {
                    "name": "SelectComponent",
                    "type": "component"
                },
                {
                    "name": "ButtonComponent",
                    "type": "component"
                },
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "MultilineInputComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, computed, inject, effect } from '@angular/core';\nimport { SelectComponent, ButtonComponent, CardComponent, MultilineInputComponent } from '../../ui';\nimport { POETRY_FORM_OPTIONS } from '../../../data/poetry-forms.data';\nimport { PoetryAnalyzerService, ToastService, StateService } from '../../../services';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-poem-editor',\n  standalone: true,\n  imports: [CommonModule, SelectComponent, ButtonComponent, CardComponent, MultilineInputComponent],\n  templateUrl: './poem-editor.component.html',\n})\nexport class PoemEditorComponent {\n  private readonly analyzer = inject(PoetryAnalyzerService);\n  private readonly toastService = inject(ToastService);\n  private readonly stateService = inject(StateService);\n\n  readonly Math = Math;\n  readonly formOptions = POETRY_FORM_OPTIONS;\n\n  readonly selectedForm = this.stateService.selectedForm;\n  readonly poemText = this.stateService.poemText;\n  readonly currentForm = this.stateService.currentForm;\n  readonly currentPattern = this.stateService.currentPattern;\n  readonly expectedLines = this.stateService.expectedLines;\n  readonly lines = this.stateService.lines;\n\n  readonly lineCount = computed(() => this.lines().length);\n\n  readonly totalSyllables = computed(() => {\n    return this.lines().reduce((total, line) => {\n      return total + this.analyzer['rita'].analyzeLine(line).syllables;\n    }, 0);\n  });\n\n  readonly expectedSyllables = computed(() => {\n    const form = this.currentForm();\n    return form ? form.pattern.reduce((sum: number, n: number) => sum + n, 0) : 0;\n  });\n\n  readonly syllableProgress = computed(() => {\n    const total = this.totalSyllables();\n    const expected = this.expectedSyllables();\n    return expected > 0 ? (total / expected) * 100 : 0;\n  });\n\n  constructor() {\n    effect(() => {\n      const formId = this.selectedForm();\n      this.analyzer.selectedForm.set(formId);\n    });\n\n    effect(() => {\n      const text = this.poemText();\n      this.analyzer.poemText.set(text);\n    });\n  }\n\n  onFormChange(formId: string): void {\n    this.stateService.setSelectedForm(formId);\n  }\n\n  onTextChange(text: string): void {\n    const lines = text.split('\\n');\n    const trimmedText = lines.slice(0, this.expectedLines()).join('\\n');\n    this.stateService.setPoemText(trimmedText);\n  }\n\n  loadExample(): void {\n    this.stateService.loadExample();\n    this.toastService.success('Example Loaded', `Loaded ${this.selectedForm()} example`);\n  }\n\n  clear(): void {\n    const hasContent = this.poemText().length > 0 || this.analyzer.result() !== null;\n\n    if (hasContent) {\n      if (this.confirmClear()) {\n        this.stateService.clear();\n        this.analyzer.clear();\n\n        this.toastService.info('Editor Cleared', 'All content has been removed');\n      }\n    } else {\n      this.toastService.info('Already Empty', 'Nothing to clear');\n    }\n  }\n\n  analyze(): void {\n    const lines = this.lines();\n    if (lines.length === 0) {\n      this.toastService.warning('Empty Poem', 'Write something first');\n      return;\n    }\n\n    this.toastService.info('Analyzing Poem', 'Processing your poetry...');\n    this.stateService.setIsAnalyzing(true);\n\n    this.analyzer.analyze(this.selectedForm(), lines).finally(() => {\n      this.stateService.setIsAnalyzing(false);\n      this.stateService.setHasResults(true);\n    });\n  }\n\n  async onCopyPoem(): Promise<void> {\n    const text = this.poemText().trim();\n\n    if (!text) {\n      this.toastService.warning('Empty Poem', 'Nothing to copy');\n      return;\n    }\n\n    try {\n      await navigator.clipboard.writeText(text);\n      const lineCount = this.lines().length;\n      const syllableCount = this.totalSyllables();\n\n      this.toastService.success('Poem Copied!', `${lineCount} lines, ${syllableCount} syllables`);\n    } catch (err) {\n      console.error('Failed to copy poem: ', err);\n      this.toastService.error('Copy Failed', 'Could not copy to clipboard');\n    }\n  }\n\n  isReadyForAnalysis(): boolean {\n    return this.lineCount() > 0;\n  }\n\n  getResponsiveFontClass(): string {\n    return 'responsive-font';\n  }\n\n  getCurrentPlaceholder(): string {\n    const form = this.currentForm();\n    return form ? `Write your ${form.name} here...` : 'Write your poem here...';\n  }\n\n  private confirmClear(): boolean {\n    if (typeof window === 'undefined') return false;\n    return window.confirm('Clear all content? This cannot be undone.');\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 45
            },
            "extends": [],
            "templateData": "<app-card padding=\"large\" class=\"editor-card\">\n  <div class=\"editor-container\">\n    \n    <header class=\"editor-header\">\n      <h1 class=\"editor-title\">poetry editor</h1>\n      <div class=\"form-selector\">\n        <app-select\n          [id]=\"'poetry-form-selector'\"\n          [options]=\"formOptions\"\n          [value]=\"selectedForm()\"\n          (selectChange)=\"onFormChange($event)\"\n        />\n      </div>\n    </header>\n\n    <div class=\"stats-panel-minimal\">\n      <div class=\"stat-minimal\">\n        <span class=\"stat-minimal-value\">{{ lineCount() }}</span>\n        <span class=\"stat-minimal-label\">lines</span>\n      </div>\n      <div class=\"stat-minimal\">\n        <span class=\"stat-minimal-value\">{{ totalSyllables() }}</span>\n        <span class=\"stat-minimal-label\">syllables</span>\n      </div>\n      <div class=\"stat-minimal\">\n        <span class=\"stat-minimal-value\">{{ Math.min(syllableProgress(), 100).toFixed(0) }}%</span>\n        <span class=\"stat-minimal-label\">complete</span>\n      </div>\n    </div>\n\n    <section class=\"editor-section\">\n      <app-multiline-input\n        id=\"poem-editor\"\n        [placeholder]=\"getCurrentPlaceholder()\"\n        [rows]=\"expectedLines()\"\n        [value]=\"poemText()\"\n        [showLineNumbers]=\"true\"\n        [showLineValidation]=\"true\"\n        [expectedPattern]=\"currentPattern()\"\n        (valueChange)=\"onTextChange($event)\"\n        [class]=\"getResponsiveFontClass()\"\n      />\n    </section>\n\n    <footer class=\"editor-actions\">\n      <app-button\n        variant=\"primary\"\n        size=\"medium\"\n        label=\"analyze\"\n        icon=\"icon-[iconoir--search]\"\n        [disabled]=\"!isReadyForAnalysis()\"\n        (clicked)=\"analyze()\"\n      />\n\n      <app-button\n        variant=\"outline\"\n        size=\"medium\"\n        label=\"example\"\n        icon=\"icon-[iconoir--page]\"\n        (clicked)=\"loadExample()\"\n      />\n\n      <app-button\n        variant=\"outline\"\n        size=\"medium\"\n        label=\"clear\"\n        icon=\"icon-[iconoir--cancel]\"\n        (clicked)=\"clear()\"\n      />\n\n      <app-button\n        variant=\"outline\"\n        size=\"medium\"\n        label=\"copy\"\n        icon=\"icon-[iconoir--copy]\"\n        (clicked)=\"onCopyPoem()\"\n      />\n    </footer>\n\n  </div>\n</app-card>"
        },
        {
            "name": "PoemQualityComponent",
            "id": "component-PoemQualityComponent-d88b6ba961f1e640d5d5647b16b3a5b650c6365443fc7affbb3d933c3582eaf91889dad47d7243f5584bacbeda11a8373f83a8f0e786146346fa35ee919ff73b",
            "file": "src/app/components/poetry/poem-quality/poem-quality.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-poem-quality",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./poem-quality.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "required": true,
                    "name": "metrics",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "optional": false,
                    "line": 13,
                    "type": "QualityMetrics",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "getGradeVariant",
                    "args": [
                        {
                            "name": "grade",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "\"success\" | \"info\" | \"warning\" | \"error\"",
                    "typeParameters": [],
                    "line": 29,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "grade",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getMetricColor",
                    "args": [
                        {
                            "name": "value",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 22,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getMetricEntries",
                    "args": [],
                    "optional": false,
                    "returnType": "literal type[]",
                    "typeParameters": [],
                    "line": 15,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                },
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "BadgeComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { QualityMetrics } from '../../../services';\nimport { CardComponent, BadgeComponent } from '../../ui';\n\n@Component({\n  selector: 'app-poem-quality',\n  standalone: true,\n  imports: [CommonModule, CardComponent, BadgeComponent],\n  templateUrl: './poem-quality.component.html',\n})\nexport class PoemQualityComponent {\n  @Input({ required: true }) metrics!: QualityMetrics;\n\n  getMetricEntries(): { name: string; value: number }[] {\n    return Object.entries(this.metrics.breakdown).map(([key, value]) => ({\n      name: key.replace(/([A-Z])/g, ' $1').toLowerCase(),\n      value,\n    }));\n  }\n\n  getMetricColor(value: number): string {\n    if (value >= 80) return 'metric-excellent';\n    if (value >= 70) return 'metric-good';\n    if (value >= 60) return 'metric-fair';\n    return 'metric-poor';\n  }\n\n  getGradeVariant(grade: string): 'success' | 'info' | 'warning' | 'error' {\n    switch (grade) {\n      case 'A+':\n      case 'A':\n        return 'success';\n      case 'B+':\n      case 'B':\n        return 'info';\n      case 'C+':\n      case 'C':\n        return 'warning';\n      default:\n        return 'error';\n    }\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card padding=\"large\" *ngIf=\"metrics\">\n  <div class=\"quality-container\">\n    <!-- Header con puntuación -->\n    <div class=\"quality-header\">\n      <div class=\"score-section\">\n        <h3 class=\"quality-title\">quality assessment</h3>\n        <div class=\"score-display\">\n          <span class=\"score-number\">{{ metrics.score.toFixed(1) }}</span>\n          <span class=\"score-max\">/100</span>\n          <app-badge [variant]=\"getGradeVariant(metrics.grade)\" size=\"medium\" class=\"grade-badge\">\n            {{ metrics.grade }}\n          </app-badge>\n        </div>\n      </div>\n    </div>\n\n    <!-- Breakdown de métricas -->\n    <div class=\"metrics-breakdown\">\n      <h4 class=\"breakdown-title\">detailed breakdown</h4>\n      <div class=\"metrics-grid\">\n        <div class=\"metric-item\" *ngFor=\"let metric of getMetricEntries()\">\n          <div class=\"metric-header\">\n            <span class=\"metric-name\">{{ metric.name }}</span>\n            <span class=\"metric-score\">{{ metric.value.toFixed(1) }}%</span>\n          </div>\n          <div class=\"metric-bar\">\n            <div\n              class=\"metric-fill\"\n              [style.width.%]=\"metric.value\"\n              [class]=\"getMetricColor(metric.value)\"\n            ></div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Fortalezas y mejoras -->\n    <div class=\"feedback-section\">\n      <div class=\"strengths\">\n        <h4 class=\"feedback-title\">\n          <span class=\"icon-[iconoir--check] feedback-icon\"></span>\n          strengths\n        </h4>\n        <ul class=\"feedback-list\">\n          <li *ngFor=\"let strength of metrics.strengths\">{{ strength }}</li>\n        </ul>\n      </div>\n\n      <div class=\"improvements\">\n        <h4 class=\"feedback-title\">\n          <span class=\"icon-[iconoir--light-bulb] feedback-icon\"></span>\n          suggestions\n        </h4>\n        <ul class=\"feedback-list\">\n          <li *ngFor=\"let improvement of metrics.improvements\">{{ improvement }}</li>\n        </ul>\n      </div>\n    </div>\n  </div>\n</app-card>\n"
        },
        {
            "name": "PoemResultsComponent",
            "id": "component-PoemResultsComponent-8743665d798047c6c05742ef0850bb4dfca8f0ca0ec7c139a8c5b388e0debcd42fbb8592751ff6c764915e257cad6f6349ba92cb94e01add473422274a3a06b8",
            "file": "src/app/components/poetry/poem-results/poem-results.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-poem-results",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./poem-results.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "required": true,
                    "name": "result",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "optional": false,
                    "line": 14,
                    "type": "EnhancedPoetryResult",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "wordSelected",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 15,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "utils",
                    "defaultValue": "inject(UtilsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 12,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "getPosLabel",
                    "args": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 21,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onWordClick",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 17,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "BadgeComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter, inject } from '@angular/core';\nimport { CardComponent, BadgeComponent } from '../../ui';\nimport { EnhancedPoetryResult, UtilsService } from '../../../services';\n\n@Component({\n  selector: 'app-poem-results',\n  standalone: true,\n  imports: [CardComponent, BadgeComponent],\n  templateUrl: './poem-results.component.html',\n})\nexport class PoemResultsComponent {\n  private readonly utils = inject(UtilsService);\n\n  @Input({ required: true }) result!: EnhancedPoetryResult;\n  @Output() wordSelected = new EventEmitter<string>();\n\n  onWordClick(word: string): void {\n    this.wordSelected.emit(word);\n  }\n\n  getPosLabel(pos: string): string {\n    return this.utils.getPosLabel(pos);\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card padding=\"large\">\n  <div class=\"results-container\">\n    <!-- Status Header -->\n    <div class=\"status-header mb-metro-md\">\n      <app-badge\n        [variant]=\"result.ok ? 'success' : 'warning'\"\n        size=\"medium\"\n        [icon]=\"result.ok ? 'icon-[iconoir--check]' : 'icon-[iconoir--warning-triangle]'\"\n      >\n        {{ result.ok ? 'Perfect match' : 'Pattern mismatch' }}\n      </app-badge>\n      <p class=\"status-summary mt-metro-xs text-sm opacity-80\">{{ result.summary }}</p>\n    </div>\n\n    <!-- Detected Patterns Section -->\n    @if (result.detectedPatterns && result.detectedPatterns.length > 0) {\n    <div class=\"patterns-section\">\n      <h3 class=\"section-title\">detected patterns</h3>\n      <div class=\"patterns-list\">\n        @for (pattern of result.detectedPatterns; track $index) {\n        <div class=\"pattern-item\">\n          <span class=\"icon-[iconoir--sparks] pattern-icon\"></span>\n          <span class=\"pattern-text\">{{ pattern }}</span>\n        </div>\n        }\n      </div>\n    </div>\n    }\n\n    <!-- Alliteration Section -->\n    @if (result.overallAlliterations && result.overallAlliterations.length > 0) {\n    <div class=\"alliteration-section\">\n      <h3 class=\"section-title\">alliterations detected</h3>\n      <div class=\"alliteration-list\">\n        @for (alliteration of result.overallAlliterations; track $index) {\n        <div class=\"alliteration-item\">\n          <app-badge variant=\"info\" size=\"small\" icon=\"icon-[iconoir--sound-high]\">\n            {{ alliteration.sound }}\n          </app-badge>\n          <span class=\"alliteration-words\">\n            {{ alliteration.words.join(' • ') }}\n          </span>\n        </div>\n        }\n      </div>\n    </div>\n    }\n\n    <!-- Line Analysis -->\n    <div class=\"line-analysis-section\">\n      <h3 class=\"section-title\">line-by-line analysis</h3>\n\n      <div class=\"lines-container\">\n        @for (line of result.lines; track $index) {\n        <div class=\"line-card\">\n          <!-- Line Header -->\n          <div class=\"line-header\">\n            <span class=\"line-number\"> line {{ $index + 1 }} </span>\n            <app-badge\n              [variant]=\"line.match ? 'success' : 'error'\"\n              size=\"small\"\n              [icon]=\"line.match ? 'icon-[iconoir--check]' : 'icon-[iconoir--cancel]'\"\n            >\n              {{ line.count }}/{{ line.expected }} syllables\n            </app-badge>\n          </div>\n\n          <!-- Line Text with Clickable Words -->\n          <p class=\"line-text\">\n            @for (word of line.words; track $index) {\n            <span\n              class=\"word-token\"\n              [class.word-clickable]=\"!line.match\"\n              [attr.role]=\"!line.match ? 'button' : null\"\n              [attr.tabindex]=\"!line.match ? 0 : null\"\n              (click)=\"!line.match && onWordClick(word.word)\"\n              (keyup.enter)=\"!line.match && onWordClick(word.word)\"\n              (keyup.space)=\"!line.match && onWordClick(word.word)\"\n              [title]=\"getPosLabel(word.pos) + ' • ' + word.syllables + ' syllable(s)'\"\n            >\n              {{ word.word }}\n            </span>\n            }\n          </p>\n\n          <!-- Alliterations in Line -->\n          @if (line.alliterations && line.alliterations.length > 0) {\n          <div class=\"line-alliterations\">\n            @for (alliteration of line.alliterations; track $index) {\n            <app-badge variant=\"info\" size=\"small\" icon=\"icon-[iconoir--sound-high]\">\n              alliteration: {{ alliteration.words.join(', ') }}\n            </app-badge>\n            }\n          </div>\n          }\n\n          <!-- Syllable Breakdown -->\n          @if (line.syllables && line.syllables.length > 0) {\n          <div class=\"syllable-breakdown\">\n            <span class=\"breakdown-label\">syllables:</span>\n            <div class=\"syllable-chips\">\n              @for (syllable of line.syllables; track $index) {\n              <span class=\"syllable-chip\">{{ syllable }}</span>\n              }\n            </div>\n          </div>\n          }\n\n          <!-- Stress Pattern -->\n          @if (line.stresses) {\n          <div class=\"stress-pattern\">\n            <span class=\"breakdown-label\">stress:</span>\n            <span class=\"stress-value\">{{ line.stresses }}</span>\n          </div>\n          }\n\n          <!-- Word Details -->\n          <details class=\"word-details\">\n            <summary class=\"word-details-summary\">view word analysis</summary>\n            <div class=\"word-details-content\">\n              @for (word of line.words; track $index) {\n              <div class=\"word-detail-item\">\n                <span class=\"word-detail-word\">{{ word.word }}</span>\n                <div class=\"word-detail-meta\">\n                  <span class=\"word-detail-syllables\">\n                    {{ word.syllables }} syllable{{ word.syllables !== 1 ? 's' : '' }}\n                  </span>\n                  <span class=\"word-detail-pos\">{{ getPosLabel(word.pos) }}</span>\n                  @if (word.phones) {\n                  <span class=\"word-detail-phones\">{{ word.phones }}</span>\n                  }\n                </div>\n              </div>\n              }\n            </div>\n          </details>\n        </div>\n        }\n      </div>\n    </div>\n\n    <!-- Rhyme Scheme -->\n    @if (result.rhymeScheme) {\n    <div class=\"rhyme-section\">\n      <h4 class=\"section-title\">rhyme scheme</h4>\n      <div class=\"rhyme-scheme\">\n        <span class=\"rhyme-value\">{{ result.rhymeScheme }}</span>\n      </div>\n    </div>\n    }\n\n    <!-- Suggestions -->\n    @if (result.suggestions && result.suggestions.length > 0) {\n    <div class=\"suggestions-section\">\n      <h4 class=\"section-title\">suggestions for improvement</h4>\n      <ul class=\"suggestions-list\">\n        @for (suggestion of result.suggestions; track $index) {\n        <li class=\"suggestion-item\">\n          <span class=\"icon-[iconoir--light-bulb] suggestion-icon\"></span>\n          <span>{{ suggestion }}</span>\n        </li>\n        }\n      </ul>\n    </div>\n    }\n  </div>\n</app-card>"
        },
        {
            "name": "PoetryPageComponent",
            "id": "component-PoetryPageComponent-b73bd3f1261197f242b37c8aea07d22687cadf36668510cdabbb5dd41ec7867e5c7a942fc019b3b21b84c84a2b2a2596627dfd6d7c85f9aa0ac808df45986364",
            "file": "src/app/components/layout/poetry-page/poetry-page.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-poetry-page",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./poetry-page.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "analysisTabs",
                    "defaultValue": "signal<PivotItem[]>([\n    { id: 'structure', label: 'structure' },\n    { id: 'rhythm', label: 'rhythm' },\n    { id: 'quality', label: 'quality' },\n    { id: 'stats', label: 'stats' },\n  ])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 58,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "analyzer",
                    "defaultValue": "inject(PoetryAnalyzerService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 48,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "appBarActions",
                    "defaultValue": "computed<AppBarAction[]>(() => [\n    {\n      id: 'analyze',\n      icon: 'icon-[iconoir--search]',\n      label: 'analyze',\n      disabled: this.stateService.lines().length === 0 || this.stateService.isAnalyzing(),\n    },\n    {\n      id: 'example',\n      icon: 'icon-[iconoir--page]',\n      label: 'example',\n      disabled: this.stateService.isAnalyzing(),\n    },\n    {\n      id: 'clear',\n      icon: 'icon-[iconoir--cancel]',\n      label: 'clear',\n      disabled: this.stateService.poemText().length === 0 || this.stateService.isAnalyzing(),\n    },\n    {\n      id: 'copy',\n      icon: 'icon-[iconoir--copy]',\n      label: 'copy',\n      disabled: this.stateService.poemText().length === 0 || this.stateService.isAnalyzing(),\n    },\n  ])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 66,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "currentSection",
                    "defaultValue": "signal<'editor' | 'results'>('editor')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 55,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "currentStage",
                    "defaultValue": "signal<'syllables' | 'rhythm' | 'patterns' | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 53,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "hasResults",
                    "defaultValue": "computed(() => this.analyzer.result() !== null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 93,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "isAnalyzing",
                    "defaultValue": "computed(() => this.loadingState() !== 'idle')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 94,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "loadingState",
                    "defaultValue": "signal<'idle' | 'analyzing' | 'loading-example' | 'assessing'>('idle')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 52,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "recentlyAnalyzed",
                    "defaultValue": "signal(false)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 56,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "selectedAnalysisTab",
                    "defaultValue": "signal('structure')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 64,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "stateService",
                    "defaultValue": "inject(StateService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 50,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "toastService",
                    "defaultValue": "inject(ToastService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 49,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "analyzeWithStages",
                    "args": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 145,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "confirmClear",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 140,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "getFormPattern",
                    "args": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 301,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getQuickStats",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 293,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "handleAnalyze",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 179,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "handleClear",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 209,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "handleCopy",
                    "args": [],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 227,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123,
                        134
                    ]
                },
                {
                    "name": "handleLoadExample",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 192,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "loadFormExample",
                    "args": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 285,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "navigateToSection",
                    "args": [
                        {
                            "name": "sectionId",
                            "type": "\"editor\" | \"results\"",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 122,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "sectionId",
                            "type": "\"editor\" | \"results\"",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "navigateWithHighlight",
                    "args": [
                        {
                            "name": "sectionId",
                            "type": "\"editor\" | \"results\"",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 132,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "sectionId",
                            "type": "\"editor\" | \"results\"",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onAnalysisTabChange",
                    "args": [
                        {
                            "name": "tabId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 251,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "tabId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onAnalyze",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 247,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onAppBarAction",
                    "args": [
                        {
                            "name": "actionId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 159,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "actionId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onCloseSuggestions",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 265,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onExportPoem",
                    "args": [],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 269,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ]
                },
                {
                    "name": "onQuickNav",
                    "args": [
                        {
                            "name": "section",
                            "type": "\"editor\" | \"results\"",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 315,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "section",
                            "type": "\"editor\" | \"results\"",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onReplaceWord",
                    "args": [
                        {
                            "name": "newWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 259,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "newWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onWordSelected",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 255,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setupScrollDetection",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 102,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                },
                {
                    "name": "PanoramaComponent",
                    "type": "component"
                },
                {
                    "name": "PivotComponent",
                    "type": "component"
                },
                {
                    "name": "AppBarComponent",
                    "type": "component"
                },
                {
                    "name": "ProgressComponent",
                    "type": "component"
                },
                {
                    "name": "ToastContainerComponent",
                    "type": "component"
                },
                {
                    "name": "PoemEditorComponent",
                    "type": "component"
                },
                {
                    "name": "PoemResultsComponent",
                    "type": "component"
                },
                {
                    "name": "PoemQualityComponent",
                    "type": "component"
                },
                {
                    "name": "WordSuggestionsComponent",
                    "type": "component"
                },
                {
                    "name": "QuickStatsPanelComponent",
                    "type": "component"
                },
                {
                    "name": "MeterAnalysisSectionComponent",
                    "type": "component"
                },
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "HeaderComponent",
                    "type": "component"
                },
                {
                    "name": "FooterComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, inject, signal, computed } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport {\n  PanoramaComponent,\n  PivotComponent,\n  type PivotItem,\n  AppBarComponent,\n  type AppBarAction,\n  ProgressComponent,\n  ToastContainerComponent,\n} from '../../metro';\nimport {\n  PoemEditorComponent,\n  PoemResultsComponent,\n  PoemQualityComponent,\n  WordSuggestionsComponent,\n  QuickStatsPanelComponent,\n  MeterAnalysisSectionComponent,\n} from '../../poetry';\nimport { CardComponent } from '../../ui';\nimport { HeaderComponent, FooterComponent } from '../../layout';\nimport { PoetryAnalyzerService, ToastService, StateService } from '../../../services';\n\n@Component({\n  selector: 'app-poetry-page',\n  standalone: true,\n  imports: [\n    CommonModule,\n    PanoramaComponent,\n    PivotComponent,\n    AppBarComponent,\n    ProgressComponent,\n    ToastContainerComponent,\n    PoemEditorComponent,\n    PoemResultsComponent,\n    PoemQualityComponent,\n    WordSuggestionsComponent,\n    QuickStatsPanelComponent,\n    MeterAnalysisSectionComponent,\n    CardComponent,\n    HeaderComponent,\n    FooterComponent,\n  ],\n  templateUrl: './poetry-page.component.html',\n})\nexport class PoetryPageComponent {\n  readonly analyzer = inject(PoetryAnalyzerService);\n  private readonly toastService = inject(ToastService);\n  private readonly stateService = inject(StateService);\n\n  readonly loadingState = signal<'idle' | 'analyzing' | 'loading-example' | 'assessing'>('idle');\n  readonly currentStage = signal<'syllables' | 'rhythm' | 'patterns' | null>(null);\n\n  readonly currentSection = signal<'editor' | 'results'>('editor');\n  readonly recentlyAnalyzed = signal(false);\n\n  readonly analysisTabs = signal<PivotItem[]>([\n    { id: 'structure', label: 'structure' },\n    { id: 'rhythm', label: 'rhythm' },\n    { id: 'quality', label: 'quality' },\n    { id: 'stats', label: 'stats' },\n  ]);\n  readonly selectedAnalysisTab = signal('structure');\n\n  readonly appBarActions = computed<AppBarAction[]>(() => [\n    {\n      id: 'analyze',\n      icon: 'icon-[iconoir--search]',\n      label: 'analyze',\n      disabled: this.stateService.lines().length === 0 || this.stateService.isAnalyzing(),\n    },\n    {\n      id: 'example',\n      icon: 'icon-[iconoir--page]',\n      label: 'example',\n      disabled: this.stateService.isAnalyzing(),\n    },\n    {\n      id: 'clear',\n      icon: 'icon-[iconoir--cancel]',\n      label: 'clear',\n      disabled: this.stateService.poemText().length === 0 || this.stateService.isAnalyzing(),\n    },\n    {\n      id: 'copy',\n      icon: 'icon-[iconoir--copy]',\n      label: 'copy',\n      disabled: this.stateService.poemText().length === 0 || this.stateService.isAnalyzing(),\n    },\n  ]);\n\n  readonly hasResults = computed(() => this.analyzer.result() !== null);\n  readonly isAnalyzing = computed(() => this.loadingState() !== 'idle');\n\n  constructor() {\n    if (typeof window !== 'undefined') {\n      this.setupScrollDetection();\n    }\n  }\n\n  private setupScrollDetection(): void {\n    const observer = new IntersectionObserver(\n      (entries) => {\n        entries.forEach((entry) => {\n          if (entry.isIntersecting) {\n            const section = entry.target.getAttribute('data-section') as 'editor' | 'results';\n            if (section) {\n              this.currentSection.set(section);\n            }\n          }\n        });\n      },\n      { threshold: 0.3 }\n    );\n\n    setTimeout(() => {\n      document.querySelectorAll('[data-section]').forEach((el) => observer.observe(el));\n    }, 100);\n  }\n\n  private navigateToSection(sectionId: 'editor' | 'results'): void {\n    const section = document.querySelector(`[data-section=\"${sectionId}\"]`);\n    if (section) {\n      section.scrollIntoView({\n        behavior: 'smooth',\n        block: 'start',\n      });\n    }\n  }\n\n  private navigateWithHighlight(sectionId: 'editor' | 'results'): void {\n    this.recentlyAnalyzed.set(true);\n    setTimeout(() => {\n      this.navigateToSection(sectionId);\n      setTimeout(() => this.recentlyAnalyzed.set(false), 2000);\n    }, 100);\n  }\n\n  private confirmClear(): boolean {\n    if (typeof window === 'undefined') return false;\n    return window.confirm('Clear all content? This cannot be undone.');\n  }\n\n  private async analyzeWithStages(formId: string, lines: string[]): Promise<void> {\n    this.loadingState.set('analyzing');\n    this.stateService.setIsAnalyzing(true);\n\n    await this.analyzer.analyze(formId, lines);\n\n    this.currentStage.set(null);\n    this.loadingState.set('idle');\n    this.stateService.setIsAnalyzing(false);\n    this.stateService.setHasResults(true);\n    this.toastService.success('Analysis Complete', 'Check results below');\n    this.navigateWithHighlight('results');\n  }\n\n  onAppBarAction(actionId: string): void {\n    switch (actionId) {\n      case 'analyze':\n        this.handleAnalyze();\n        break;\n\n      case 'example':\n        this.handleLoadExample();\n        break;\n\n      case 'clear':\n        this.handleClear();\n        break;\n\n      case 'copy':\n        this.handleCopy();\n        break;\n    }\n  }\n\n  private handleAnalyze(): void {\n    const lines = this.stateService.lines();\n\n    if (lines.length === 0) {\n      this.toastService.warning('Empty Poem', 'Write something first');\n      this.navigateToSection('editor');\n      return;\n    }\n\n    const formId = this.stateService.selectedForm();\n    this.analyzeWithStages(formId, lines);\n  }\n\n  private handleLoadExample(): void {\n    this.loadingState.set('loading-example');\n    const formId = this.stateService.selectedForm();\n\n    this.stateService.loadExample();\n\n    setTimeout(() => {\n      const lines = this.stateService.lines();\n      if (lines.length > 0) {\n        this.analyzeWithStages(formId, lines);\n      }\n      this.loadingState.set('idle');\n    }, 300);\n\n    this.toastService.success('Example Loaded', 'Analyzing automatically...');\n  }\n\n  private handleClear(): void {\n    const hasContent = this.stateService.poemText().length > 0 || this.hasResults();\n\n    if (hasContent) {\n      if (this.confirmClear()) {\n        this.stateService.clear();\n        this.analyzer.clear();\n        this.loadingState.set('idle');\n        this.currentStage.set(null);\n        this.stateService.setIsAnalyzing(false);\n        this.toastService.info('Cleared', 'Editor and results cleared');\n        this.navigateToSection('editor');\n      }\n    } else {\n      this.toastService.info('Already Empty', 'Nothing to clear');\n    }\n  }\n\n  private async handleCopy(): Promise<void> {\n    const text = this.stateService.poemText().trim();\n\n    if (!text) {\n      this.toastService.warning('Empty Poem', 'Nothing to copy');\n      return;\n    }\n\n    try {\n      await navigator.clipboard.writeText(text);\n      const lineCount = this.stateService.lines().length;\n      const syllableCount = this.analyzer.getQuickStats().totalSyllables;\n\n      this.toastService.success('Poem Copied!', `${lineCount} lines, ${syllableCount} syllables`);\n    } catch (err) {\n      console.error('Failed to copy poem: ', err);\n      this.toastService.error('Copy Failed', 'Could not copy to clipboard');\n    }\n  }\n\n  onAnalyze(): void {\n    this.handleAnalyze();\n  }\n\n  onAnalysisTabChange(tabId: string): void {\n    this.selectedAnalysisTab.set(tabId);\n  }\n\n  onWordSelected(word: string): void {\n    this.analyzer.selectWordEnhanced(word);\n  }\n\n  onReplaceWord(newWord: string): void {\n    const original = this.analyzer.wordAlternatives()?.original || '';\n    this.analyzer.replaceWord(original, newWord);\n    this.toastService.success('Word Replaced', `\"${original}\" → \"${newWord}\"`);\n  }\n\n  onCloseSuggestions(): void {\n    this.analyzer.selectWordEnhanced(null);\n  }\n\n  async onExportPoem(): Promise<void> {\n    const result = this.analyzer.result();\n    if (!result) return;\n\n    const poemText = result.lines.map((line) => line.text).join('\\n');\n    const formInfo = this.analyzer.selectedForm();\n    const exportText = `${formInfo.toUpperCase()} POEM\\n\\n${poemText}\\n\\n— Created with HarawiHark`;\n\n    try {\n      await navigator.clipboard.writeText(exportText);\n      this.toastService.success('Exported', 'Poem copied to clipboard');\n    } catch {\n      this.toastService.error('Export Failed', 'Could not copy to clipboard');\n    }\n  }\n\n  loadFormExample(formId: string): void {\n    this.stateService.setSelectedForm(formId);\n\n    setTimeout(() => {\n      this.handleLoadExample();\n    }, 100);\n  }\n\n  getQuickStats() {\n    const stats = this.analyzer.getQuickStats();\n    return {\n      ...stats,\n      patternMatch: this.analyzer.isCompletePoem() ? 'Perfect' : 'Partial',\n    };\n  }\n\n  getFormPattern(formId: string): string {\n    const patterns: Record<string, string> = {\n      haiku: '5-7-5',\n      tanka: '5-7-5-7-7',\n      cinquain: '2-4-6-8-2',\n      limerick: '8-8-5-5-8',\n      redondilla: '8-8-8-8',\n      lanterne: '1-2-3-4-1',\n      diamante: '1-2-3-4-3-2-1',\n      fibonacci: '1-1-2-3-5-8',\n    };\n    return patterns[formId] || '';\n  }\n\n  onQuickNav(section: 'editor' | 'results'): void {\n    this.navigateToSection(section);\n  }\n\n  get appBarActionsValue(): AppBarAction[] {\n    return this.appBarActions();\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 94
            },
            "extends": [],
            "accessors": {
                "appBarActionsValue": {
                    "name": "appBarActionsValue",
                    "getSignature": {
                        "name": "appBarActionsValue",
                        "type": "[]",
                        "returnType": "AppBarAction[]",
                        "line": 319
                    }
                }
            },
            "templateData": "<div class=\"poetry-page\" [class.results-highlight]=\"recentlyAnalyzed()\">\n  <app-toast-container />\n\n  <app-header />\n\n  <div class=\"quick-nav-buttons\">\n    <button\n      class=\"nav-pill\"\n      [class.active]=\"currentSection() === 'editor'\"\n      (click)=\"onQuickNav('editor')\"\n      aria-label=\"Go to editor\"\n    >\n      <span class=\"icon-[iconoir--edit-pencil]\"></span>\n      <span>editor</span>\n    </button>\n\n    <button\n      class=\"nav-pill\"\n      [class.active]=\"currentSection() === 'results'\"\n      [disabled]=\"!hasResults()\"\n      (click)=\"onQuickNav('results')\"\n      aria-label=\"Go to results\"\n    >\n      <span class=\"icon-[iconoir--page-search]\"></span>\n      <span>results</span>\n    </button>\n  </div>\n\n  <app-panorama>\n    <div data-section=\"editor\">\n      <div class=\"section-content\">\n        <app-poem-editor />\n\n        @if (analyzer.wordAlternatives(); as alternatives) {\n          <div class=\"suggestions-wrapper\">\n            <app-word-suggestions\n              [data]=\"alternatives\"\n              (replaceWord)=\"onReplaceWord($event)\"\n              (closeSuggestions)=\"onCloseSuggestions()\"\n            />\n          </div>\n        }\n\n        <div class=\"info-section\">\n          <div class=\"info-content\">\n            <span class=\"icon-[iconoir--light-bulb] info-icon\"></span>\n            <div class=\"info-text\">\n              <h4 class=\"info-title\">how it works</h4>\n              <p class=\"info-description\">\n                Harawihark uses advanced phonetic analysis to count syllables accurately, detect\n                rhyme schemes, and provide intelligent suggestions.\n              </p>\n              <ul class=\"info-features\">\n                <li>\n                  <span class=\"icon-[iconoir--sound-high] feature-icon\"></span>\n                  Real-time syllable counting with RiTa.js\n                </li>\n                <li>\n                  <span class=\"icon-[iconoir--music-note] feature-icon\"></span>\n                  Advanced meter analysis (iambic, trochaic, etc.)\n                </li>\n                <li>\n                  <span class=\"icon-[iconoir--star] feature-icon\"></span>\n                  Quality assessment with detailed metrics\n                </li>\n                <li>\n                  <span class=\"icon-[iconoir--book-stack] feature-icon\"></span>\n                  8 different poetic forms supported\n                </li>\n              </ul>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div data-section=\"results\" [class.section-highlight]=\"recentlyAnalyzed()\">\n      <div class=\"section-content\">\n        @if (hasResults()) {\n          @if (isAnalyzing()) {\n            <app-card padding=\"large\">\n              <div class=\"analysis-loading\">\n                <div class=\"analysis-stages\">\n                  <div class=\"stage\" [class.active]=\"currentStage() === 'syllables'\">\n                    <span class=\"icon-[iconoir--sound-high] stage-icon\"></span>\n                    <span class=\"stage-label\">counting syllables</span>\n                    @if (currentStage() === 'syllables') {\n                      <app-progress type=\"bar\" />\n                    }\n                  </div>\n\n                  <div class=\"stage\" [class.active]=\"currentStage() === 'rhythm'\">\n                    <span class=\"icon-[iconoir--music-note] stage-icon\"></span>\n                    <span class=\"stage-label\">analyzing rhythm</span>\n                    @if (currentStage() === 'rhythm') {\n                      <app-progress type=\"bar\" />\n                    }\n                  </div>\n\n                  <div class=\"stage\" [class.active]=\"currentStage() === 'patterns'\">\n                    <span class=\"icon-[iconoir--sparks] stage-icon\"></span>\n                    <span class=\"stage-label\">detecting patterns</span>\n                    @if (currentStage() === 'patterns') {\n                      <app-progress type=\"bar\" />\n                    }\n                  </div>\n                </div>\n              </div>\n            </app-card>\n          } @else {\n            <app-pivot\n              [items]=\"analysisTabs()\"\n              [selectedId]=\"selectedAnalysisTab()\"\n              (selectedChange)=\"onAnalysisTabChange($event)\"\n            />\n\n            <div class=\"analysis-content\">\n              @switch (selectedAnalysisTab()) {\n                @case ('structure') {\n                  <app-poem-results\n                    [result]=\"analyzer.result()!\"\n                    (wordSelected)=\"onWordSelected($event)\"\n                  />\n                }\n                @case ('rhythm') {\n                  <app-meter-analysis-section [result]=\"analyzer.result()!\" />\n                }\n                @case ('quality') {\n                  @if (analyzer.qualityMetrics()) {\n                    <app-poem-quality [metrics]=\"analyzer.qualityMetrics()!\" />\n                  } @else {\n                    <app-card padding=\"large\">\n                      <div class=\"quality-prompt\">\n                        <span class=\"icon-[iconoir--star] text-4xl mb-4\"></span>\n                        <p class=\"text-base mb-6 text-onSurfaceVariant\">\n                          Select the Quality tab to see detailed quality metrics\n                        </p>\n                      </div>\n                    </app-card>\n                  }\n                }\n                @case ('stats') {\n                  <app-quick-stats-panel [stats]=\"getQuickStats()\" />\n                }\n              }\n            </div>\n\n          }\n        } @else {\n          <app-card padding=\"large\">\n            <div class=\"empty-state-rich\">\n              <span class=\"icon-[iconoir--flower] empty-icon\"></span>\n              <h3 class=\"empty-title\">ready to analyze poetry</h3>\n              <p class=\"empty-description\">\n                Write your poem in the editor or load an example to see analysis\n              </p>\n\n              <div class=\"forms-showcase\">\n                <h4 class=\"forms-title\">try these poetic forms:</h4>\n                <div class=\"forms-grid\">\n                  <button class=\"form-card\" (click)=\"loadFormExample('haiku')\">\n                    <span class=\"form-name\">haiku</span>\n                    <span class=\"form-pattern\">5-7-5</span>\n                  </button>\n\n                  <button class=\"form-card\" (click)=\"loadFormExample('tanka')\">\n                    <span class=\"form-name\">tanka</span>\n                    <span class=\"form-pattern\">5-7-5-7-7</span>\n                  </button>\n\n                  <button class=\"form-card\" (click)=\"loadFormExample('limerick')\">\n                    <span class=\"form-name\">limerick</span>\n                    <span class=\"form-pattern\">8-8-5-5-8</span>\n                  </button>\n\n                  <button class=\"form-card\" (click)=\"loadFormExample('cinquain')\">\n                    <span class=\"form-name\">cinquain</span>\n                    <span class=\"form-pattern\">2-4-6-8-2</span>\n                  </button>\n\n                  <button class=\"form-card\" (click)=\"loadFormExample('diamante')\">\n                    <span class=\"form-name\">diamante</span>\n                    <span class=\"form-pattern\">1-2-3-4-3-2-1</span>\n                  </button>\n\n                  <button class=\"form-card\" (click)=\"loadFormExample('fibonacci')\">\n                    <span class=\"form-name\">fibonacci</span>\n                    <span class=\"form-pattern\">1-1-2-3-5-8</span>\n                  </button>\n\n                  <button class=\"form-card\" (click)=\"loadFormExample('redondilla')\">\n                    <span class=\"form-name\">redondilla</span>\n                    <span class=\"form-pattern\">8-8-8-8</span>\n                  </button>\n\n                  <button class=\"form-card\" (click)=\"loadFormExample('lanterne')\">\n                    <span class=\"form-name\">lanterne</span>\n                    <span class=\"form-pattern\">1-2-3-4-1</span>\n                  </button>\n                </div>\n              </div>\n            </div>\n          </app-card>\n        }\n      </div>\n    </div>\n  </app-panorama>\n\n  <app-footer />\n\n  <app-appbar\n    class=\"lg:hidden\"\n    [actions]=\"appBarActionsValue\"\n    (actionClick)=\"onAppBarAction($event)\"\n  />\n</div>"
        },
        {
            "name": "ProgressComponent",
            "id": "component-ProgressComponent-456b1d8c5f9380c844ad1414b11a3d3b6dc90cfb72d4fc519de9d797330a4286424832f250afd30637e7f6091183752c51bcdfe73dea94aeb0e616e98d2c435f",
            "file": "src/app/components/metro/progress/progress.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-progress",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./progress.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 14,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "type",
                    "defaultValue": "'bar'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 12,
                    "type": "\"bar\" | \"ring\"",
                    "decorators": []
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 13,
                    "type": "number",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-progress',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './progress.component.html',\n})\nexport class ProgressComponent {\n  @Input() type: 'bar' | 'ring' = 'bar';\n  @Input() value?: number;\n  @Input() label?: string;\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<!-- progress.component.html -->\n@if (type === 'bar') {\n  <div class=\"metro-progress-with-label\">\n    @if (label) {\n      <div class=\"metro-progress-label\">\n        <span>{{ label }}</span>\n        @if (value !== undefined) {\n          <span class=\"metro-progress-value\">{{ value }}%</span>\n        }\n      </div>\n    }\n    \n    @if (value !== undefined) {\n      <div class=\"metro-progress\">\n        <div \n          class=\"metro-progress-bar\" \n          [style.width.%]=\"value\"\n        ></div>\n      </div>\n    } @else {\n      <div class=\"metro-progress-indeterminate\"></div>\n    }\n  </div>\n}\n\n@if (type === 'ring') {\n  <div class=\"metro-progress-ring\"></div>\n}"
        },
        {
            "name": "QuickStatsPanelComponent",
            "id": "component-QuickStatsPanelComponent-3f49d7f8281c5927dfb1d212c11ba1d8a512667d01e0a77670a5f5e4d23d74709367137484311992e8105bfe5030b3147ac178d701edea0396acf24cd86cab32",
            "file": "src/app/components/poetry/quick-stats-panel/quick-stats-panel.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-quick-stats-panel",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./quick-stats-panel.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "required": true,
                    "name": "stats",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "optional": false,
                    "line": 18,
                    "type": "QuickStats",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CardComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CardComponent } from '../../ui';\n\nexport interface QuickStats {\n  totalSyllables: number;\n  avgSyllablesPerLine: number;\n  vocabularyRichness: number;\n  patternMatch: string;\n}\n\n@Component({\n  selector: 'app-quick-stats-panel',\n  standalone: true,\n  imports: [CardComponent],\n  templateUrl: './quick-stats-panel.component.html',\n})\nexport class QuickStatsPanelComponent {\n  @Input({ required: true }) stats!: QuickStats;\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card padding=\"medium\">\n  <div class=\"stats-container\">\n    <h3 class=\"stats-title\">quick stats</h3>\n    \n    <div class=\"stats-grid\">\n      <div class=\"stat-item\">\n        <div class=\"stat-icon\">\n          <span class=\"icon-[iconoir--sound-high]\"></span>\n        </div>\n        <div class=\"stat-content\">\n          <span class=\"stat-value\">{{ stats.totalSyllables }}</span>\n          <span class=\"stat-label\">total syllables</span>\n        </div>\n      </div>\n      \n      <div class=\"stat-item\">\n        <div class=\"stat-icon\">\n          <span class=\"icon-[iconoir--layout-left]\"></span>\n        </div>\n        <div class=\"stat-content\">\n          <span class=\"stat-value\">{{ stats.avgSyllablesPerLine }}</span>\n          <span class=\"stat-label\">avg per line</span>\n        </div>\n      </div>\n      \n      <div class=\"stat-item\">\n        <div class=\"stat-icon\">\n          <span class=\"icon-[iconoir--book-stack]\"></span>\n        </div>\n        <div class=\"stat-content\">\n          <span class=\"stat-value\">{{ stats.vocabularyRichness }}%</span>\n          <span class=\"stat-label\">vocabulary richness</span>\n        </div>\n      </div>\n      \n      <div class=\"stat-item\">\n        <div class=\"stat-icon\">\n          <span class=\"icon-[iconoir--check]\"></span>\n        </div>\n        <div class=\"stat-content\">\n          <span class=\"stat-value\">{{ stats.patternMatch }}</span>\n          <span class=\"stat-label\">pattern match</span>\n        </div>\n      </div>\n    </div>\n  </div>\n</app-card>"
        },
        {
            "name": "SelectComponent",
            "id": "component-SelectComponent-7edb87c8685ce9aa66b6c7c1b88f364f847e0878595029b3d42eac185c907c102a5ebd68f11888b4aed97a9b049cba0df0a3d2db7a44dc5c164fbcd8bfefab85",
            "file": "src/app/components/ui/select/select.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [
                {
                    "name": ")"
                }
            ],
            "selector": "app-select",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./select.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "disabled",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 38,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "id",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 39,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "label",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 37,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "options",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 36,
                    "type": "SelectOption[]",
                    "decorators": []
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 42,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "selectChange",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 55,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "_value",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 53
                },
                {
                    "name": "cdr",
                    "defaultValue": "inject(ChangeDetectorRef)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 34,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "isInternalUpdate",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 63,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "onChange",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 57,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "onTouched",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 60,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "stateService",
                    "defaultValue": "inject(StateService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 33,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "onBlur",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 120,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onSelectChange",
                    "args": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 98,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnChange",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "string",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ]
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 85,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "string",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnTouched",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": []
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 89,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setDisabledState",
                    "args": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 93,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "writeValue",
                    "args": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 78,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {\n  Component,\n  Input,\n  Output,\n  EventEmitter,\n  forwardRef,\n  inject,\n  effect,\n  ChangeDetectorRef,\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { StateService } from '../../../services/';\n\nexport interface SelectOption {\n  value: string;\n  label: string;\n  description?: string;\n}\n\n@Component({\n  selector: 'app-select',\n  standalone: true,\n  templateUrl: './select.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => SelectComponent),\n      multi: true,\n    },\n  ],\n})\nexport class SelectComponent implements ControlValueAccessor {\n  private readonly stateService = inject(StateService);\n  private readonly cdr = inject(ChangeDetectorRef);\n\n  @Input() options: SelectOption[] = [];\n  @Input() label = '';\n  @Input() disabled = false;\n  @Input() id = '';\n\n  @Input()\n  get value(): string {\n    return this._value;\n  }\n  set value(val: string) {\n    if (this._value !== val) {\n      this._value = val || '';\n      this.onChange(this._value);\n      this.cdr.markForCheck();\n    }\n  }\n\n  _value = '';\n\n  @Output() selectChange = new EventEmitter<string>();\n\n  private onChange: (value: string) => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private onTouched: () => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private isInternalUpdate = false;\n\n  constructor() {\n    if (this.id === 'poetry-form-selector') {\n      effect(() => {\n        const selectedForm = this.stateService.selectedForm();\n\n        if (this._value !== selectedForm && !this.isInternalUpdate) {\n          this._value = selectedForm;\n          this.cdr.detectChanges();\n        }\n      });\n    }\n  }\n\n  writeValue(value: string): void {\n    if (!this.isInternalUpdate) {\n      this._value = value || '';\n      this.cdr.markForCheck();\n    }\n  }\n\n  registerOnChange(fn: (value: string) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n    this.cdr.markForCheck();\n  }\n\n  onSelectChange(event: Event): void {\n    const target = event.target as HTMLSelectElement;\n    const newValue = target.value;\n\n    if (this._value === newValue) {\n      return;\n    }\n\n    this.isInternalUpdate = true;\n    this._value = newValue;\n    this.onChange(this._value);\n    this.selectChange.emit(this._value);\n\n    if (this.id === 'poetry-form-selector') {\n      this.stateService.setSelectedForm(this._value);\n    }\n\n    setTimeout(() => {\n      this.isInternalUpdate = false;\n    }, 0);\n  }\n\n  onBlur(): void {\n    this.onTouched();\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 63
            },
            "extends": [],
            "implements": [
                "ControlValueAccessor"
            ],
            "accessors": {
                "value": {
                    "name": "value",
                    "setSignature": {
                        "name": "value",
                        "type": "void",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "args": [
                            {
                                "name": "val",
                                "type": "string",
                                "deprecated": false,
                                "deprecationMessage": ""
                            }
                        ],
                        "returnType": "void",
                        "line": 45,
                        "jsdoctags": [
                            {
                                "name": "val",
                                "type": "string",
                                "deprecated": false,
                                "deprecationMessage": "",
                                "tagName": {
                                    "text": "param"
                                }
                            }
                        ]
                    },
                    "getSignature": {
                        "name": "value",
                        "type": "string",
                        "returnType": "string",
                        "line": 42
                    }
                }
            },
            "templateData": "<div class=\"select-wrapper\">\n  @if (label) {\n    <label class=\"select-label\" [for]=\"id\">{{ label }}</label>\n  }\n\n  <select\n    class=\"select-base\"\n    [id]=\"id\"\n    [disabled]=\"disabled\"\n    [value]=\"_value\"\n    (change)=\"onSelectChange($event)\"\n    (blur)=\"onBlur()\"\n  >\n    <option value=\"\" disabled>select an option</option>\n    @for (option of options; track option.value) {\n      <option [value]=\"option.value\" [selected]=\"_value === option.value\">\n        {{ option.label }}\n        @if (option.description) {\n          - {{ option.description }}\n        }\n      </option>\n    }\n  </select>\n\n  <span class=\"icon-[iconoir--nav-arrow-down] select-icon\"></span>\n</div>"
        },
        {
            "name": "ThemeToggleComponent",
            "id": "component-ThemeToggleComponent-612079ca484cbdbffe4bb0317cd8dd9527f7fe976f4d58475dd5581a53e8122339061d89bed37473e7938c6a2b3a7dd8f56a43eb5db7b91bdd9a44f1599333d2",
            "file": "src/app/components/theme-toggle/theme-toggle.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-theme-toggle",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./theme-toggle.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "currentTheme",
                    "defaultValue": "this.themeService.currentTheme",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 13,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "themeService",
                    "defaultValue": "inject(ThemeService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 12,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "onThemeChange",
                    "args": [
                        {
                            "name": "isDark",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 15,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "isDark",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "ToggleComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, inject } from '@angular/core';\nimport { ToggleComponent } from '../metro';\nimport { ThemeService } from '../../services/';\n\n@Component({\n  selector: 'app-theme-toggle',\n  standalone: true,\n  imports: [ToggleComponent],\n  templateUrl: './theme-toggle.component.html',\n})\nexport class ThemeToggleComponent {\n  private readonly themeService = inject(ThemeService);\n  protected readonly currentTheme = this.themeService.currentTheme;\n\n  onThemeChange(isDark: boolean): void {\n    this.themeService.setTheme(isDark ? 'dark' : 'light');\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-toggle \n  [id]=\"'theme-toggle'\" \n  [checked]=\"currentTheme() === 'dark'\" \n  (checkedChange)=\"onThemeChange($event)\"\n  class=\"theme-toggle-wrapper\">\n  <span slot=\"before\" class=\"theme-icon\">\n    @if (currentTheme() === 'light') {\n      <span class=\"icon-[iconoir--sun-light]\"></span>\n    } @else {\n      <span class=\"icon-[iconoir--moon-sat]\"></span>\n    }\n  </span>\n</app-toggle>"
        },
        {
            "name": "ToastContainerComponent",
            "id": "component-ToastContainerComponent-773f7efb38754684bf410cc697f405a37250b22aec2c4e0bf2c81e6d8711cc3bde96e81c6373d9258807e7b5e3f71094d1adf800dab37d81aa5413a0aca979c2",
            "file": "src/app/components/metro/toast-container/toast-container.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-toast-container",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./toast-container.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "toastService",
                    "defaultValue": "inject(ToastService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 13,
                    "modifierKind": [
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "getIcon",
                    "args": [
                        {
                            "name": "type",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 15,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "type",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onClose",
                    "args": [
                        {
                            "name": "id",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 25,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, inject } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ToastService } from '../../../services/core/toast.service';\n\n@Component({\n  selector: 'app-toast-container',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './toast-container.component.html',\n})\nexport class ToastContainerComponent {\n  readonly toastService = inject(ToastService);\n\n  getIcon(type: string): string {\n    const icons = {\n      info: 'icon-[iconoir--info-circle]',\n      success: 'icon-[iconoir--check-circle]',\n      warning: 'icon-[iconoir--warning-triangle]',\n      error: 'icon-[iconoir--cancel]',\n    };\n    return icons[type as keyof typeof icons] || icons.info;\n  }\n\n  onClose(id: string): void {\n    this.toastService.remove(id);\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<!-- toast-container.component.html -->\n<div class=\"metro-toast-container\">\n  @for (toast of toastService.toasts(); track toast.id) {\n    <div \n      class=\"metro-toast\"\n      [class]=\"'metro-toast-' + toast.type\"\n      role=\"alert\"\n    >\n      <span [class]=\"getIcon(toast.type) + ' metro-toast-icon'\"></span>\n      \n      <div class=\"metro-toast-content\">\n        <div class=\"metro-toast-title\">{{ toast.title }}</div>\n        @if (toast.message) {\n          <div class=\"metro-toast-message\">{{ toast.message }}</div>\n        }\n      </div>\n\n      <button\n        type=\"button\"\n        class=\"metro-toast-close\"\n        (click)=\"onClose(toast.id)\"\n        aria-label=\"Close notification\"\n      >\n        <span class=\"icon-[iconoir--cancel]\"></span>\n      </button>\n    </div>\n  }\n</div>"
        },
        {
            "name": "ToggleComponent",
            "id": "component-ToggleComponent-b9439d5dc3d4755ad7b8b2849417db53bea8cb00045726e5eff5f5a18fe103748adb32a18b7c3b65fec06a03199b62c98aba2b9c68d37e2009587625ac7f650c",
            "file": "src/app/components/metro/toggle/toggle.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [
                {
                    "name": ")"
                }
            ],
            "selector": "app-toggle",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./toggle.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "checked",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 23,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "disabled",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 22,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "id",
                    "defaultValue": "`toggle-${crypto.randomUUID()}`",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 20,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 21,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "checkedChange",
                    "defaultValue": "new EventEmitter<boolean>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 24,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "onChange",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 26,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "onTouched",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 29,
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "onToggle",
                    "args": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 33,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnChange",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "boolean",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ]
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 45,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "boolean",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnTouched",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": []
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 49,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setDisabledState",
                    "args": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 53,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "writeValue",
                    "args": [
                        {
                            "name": "value",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 41,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter, forwardRef } from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-toggle',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './toggle.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => ToggleComponent),\n      multi: true,\n    },\n  ],\n})\nexport class ToggleComponent implements ControlValueAccessor {\n  @Input() id = `toggle-${crypto.randomUUID()}`;\n  @Input() label?: string;\n  @Input() disabled = false;\n  @Input() checked = false;\n  @Output() checkedChange = new EventEmitter<boolean>();\n\n  private onChange: (value: boolean) => void = () => {\n    // Método requerido por ControlValueAccessor\n  };\n  private onTouched: () => void = () => {\n    // Método requerido por ControlValueAccessor\n  };\n\n  onToggle(event: Event): void {\n    const target = event.target as HTMLInputElement;\n    this.checked = target.checked;\n    this.onChange(this.checked);\n    this.onTouched();\n    this.checkedChange.emit(this.checked);\n  }\n\n  writeValue(value: boolean): void {\n    this.checked = value;\n  }\n\n  registerOnChange(fn: (value: boolean) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "implements": [
                "ControlValueAccessor"
            ],
            "templateData": "<!-- toggle.component.html -->\n<div class=\"metro-toggle-wrapper\">\n  <input\n    type=\"checkbox\"\n    class=\"metro-toggle-input\"\n    [id]=\"id\"\n    [checked]=\"checked\"\n    [disabled]=\"disabled\"\n    (change)=\"onToggle($event)\"\n  />\n  <label [for]=\"id\" class=\"metro-toggle\">\n    <span class=\"metro-toggle-slider\"></span>\n  </label>\n  @if (label) {\n    <label [for]=\"id\" class=\"metro-toggle-label\">{{ label }}</label>\n  }\n</div>"
        },
        {
            "name": "TooltipComponent",
            "id": "component-TooltipComponent-592c1dbb983d59c443eec14b1ca96e74c56c798f0b264a481c137734bb7f0f06d4735f9ed940cbd49f7ad6678d2ba42f2243ba137c2dce9651f5e0656e08db07",
            "file": "src/app/components/ui/tooltip/tooltip.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-tooltip",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./tooltip.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "position",
                    "defaultValue": "'top'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 10,
                    "type": "\"top\" | \"bottom\" | \"left\" | \"right\"",
                    "decorators": []
                },
                {
                    "name": "text",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 9,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-tooltip',\n  standalone: true,\n  templateUrl: './tooltip.component.html',\n})\nexport class TooltipComponent {\n  @Input() text = '';\n  @Input() position: 'top' | 'bottom' | 'left' | 'right' = 'top';\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<div class=\"metro-tooltip\" [class]=\"'tooltip-' + position\">\n  <ng-content />\n  <div class=\"tooltip-content\">\n    {{ text }}\n  </div>\n</div>"
        },
        {
            "name": "WordSuggestionsComponent",
            "id": "component-WordSuggestionsComponent-976d3bb4e3d82fdcce147b62ea95aaf8ad8297d476d99e4d0c73805ed5732c841f6d2897392c4a5e62cea2c00142f1669e12778164e18728a6401dd66adf40b0",
            "file": "src/app/components/poetry/word-suggestions/word-suggestions.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-word-suggestions",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./word-suggestions.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "required": true,
                    "name": "data",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "optional": false,
                    "line": 14,
                    "type": "WordSuggestionData",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "closeSuggestions",
                    "defaultValue": "new EventEmitter<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 16,
                    "type": "EventEmitter"
                },
                {
                    "name": "replaceWord",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 15,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "utils",
                    "defaultValue": "inject(UtilsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 12,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "getPosLabel",
                    "args": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 36,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getReasonLabel",
                    "args": [
                        {
                            "name": "reason",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 18,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "reason",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getReasonVariant",
                    "args": [
                        {
                            "name": "reason",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "\"success\" | \"info\" | \"default\"",
                    "typeParameters": [],
                    "line": 30,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "reason",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onReplaceWord",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 40,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "BadgeComponent",
                    "type": "component"
                },
                {
                    "name": "ButtonComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter, inject } from '@angular/core';\nimport { CardComponent, BadgeComponent, ButtonComponent } from '../../ui';\nimport { UtilsService, WordSuggestionData } from '../../../services';\n\n@Component({\n  selector: 'app-word-suggestions',\n  standalone: true,\n  imports: [CardComponent, BadgeComponent, ButtonComponent],\n  templateUrl: './word-suggestions.component.html',\n})\nexport class WordSuggestionsComponent {\n  private readonly utils = inject(UtilsService);\n\n  @Input({ required: true }) data!: WordSuggestionData;\n  @Output() replaceWord = new EventEmitter<string>();\n  @Output() closeSuggestions = new EventEmitter<void>();\n\n  getReasonLabel(reason: string): string {\n    const labels: Record<string, string> = {\n      'exact-match': 'exact syllables',\n      'rhyme-match': 'rhymes with original',\n      'sound-match': 'similar sound',\n      'semantic-rhyme': 'semantic rhyme',\n      'spelling-match': 'spelling match',\n      morphological: 'morphological variant',\n    };\n    return labels[reason] || reason;\n  }\n\n  getReasonVariant(reason: string): 'success' | 'info' | 'default' {\n    if (reason === 'exact-match') return 'success';\n    if (reason === 'rhyme-match' || reason === 'semantic-rhyme') return 'info';\n    return 'default';\n  }\n\n  getPosLabel(pos: string): string {\n    return this.utils.getPosLabel(pos);\n  }\n\n  onReplaceWord(word: string): void {\n    this.replaceWord.emit(word);\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card padding=\"large\">\n  <div class=\"suggestions-container\">\n    <!-- Header -->\n    <div class=\"suggestions-header\">\n      <div>\n        <h3 class=\"suggestions-title\">suggestions for \"{{ data.original }}\"</h3>\n        <p class=\"suggestions-subtitle\">\n          needs {{ data.targetSyllables }} syllable{{ data.targetSyllables !== 1 ? 's' : '' }}\n          (currently {{ data.currentSyllables }})\n        </p>\n      </div>\n      <button\n        type=\"button\"\n        class=\"close-button\"\n        (click)=\"closeSuggestions.emit()\"\n        aria-label=\"Close suggestions\"\n      >\n        <span class=\"icon-[iconoir--cancel] close-icon\"></span>\n      </button>\n    </div>\n\n    <!-- Alternatives List -->\n    @if (data.alternatives.length > 0) {\n      <div class=\"alternatives-list\">\n        @for (alt of data.alternatives; track alt.word) {\n          <div class=\"alternative-item\">\n            <div class=\"alternative-content\">\n              <div class=\"alternative-main\">\n                <span class=\"alternative-word\">{{ alt.word }}</span>\n                <app-badge\n                  [variant]=\"getReasonVariant(alt.reason)\"\n                  size=\"small\"\n                >\n                  {{ getReasonLabel(alt.reason) }}\n                </app-badge>\n              </div>\n              <div class=\"alternative-meta\">\n                <span class=\"syllable-count\">\n                  <span class=\"icon-[iconoir--sound-high] syllable-icon\"></span>\n                  {{ alt.syllables }} syllable{{ alt.syllables !== 1 ? 's' : '' }}\n                </span>\n                @if (alt.pos) {\n                  <span class=\"pos-tag\">{{ getPosLabel(alt.pos) }}</span>\n                }\n              </div>\n            </div>\n            <app-button\n              variant=\"outline\"\n              size=\"small\"\n              label=\"use\"\n              icon=\"icon-[iconoir--check]\"\n              (clicked)=\"onReplaceWord(alt.word)\"\n            />\n          </div>\n        }\n      </div>\n    } @else {\n      <div class=\"no-alternatives\">\n        <span class=\"icon-[iconoir--search] no-alternatives-icon\"></span>\n        <p class=\"no-alternatives-text\">\n          No alternatives found with {{ data.targetSyllables }} syllables\n        </p>\n      </div>\n    }\n  </div>\n</app-card>"
        }
    ],
    "modules": [],
    "miscellaneous": {
        "variables": [
            {
                "name": "ALL_CSS_VARS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "[]",
                "defaultValue": "[...THEME_CSS_VARS, ...TERMINAL_CSS_VARS]"
            },
            {
                "name": "appConfig",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/app.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "ApplicationConfig",
                "defaultValue": "{\n  providers: [\n    provideBrowserGlobalErrorListeners(),\n    provideZoneChangeDetection({ eventCoalescing: true }),\n    provideRouter(routes),\n  ],\n}"
            },
            {
                "name": "getMockPoetryData",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/data/poetry-test.utils.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "(): MockPoetryData => {\n  const mockData: MockPoetryData = { ...POETRY_EXAMPLES };\n\n  mockData['haikuWithErrors'] = [\n    'A very old silent pond in the forest',\n    'A small green frog jumps',\n    'Big splash sound and then quiet',\n  ];\n\n  return mockData;\n}"
            },
            {
                "name": "getPoetryFormsForTests",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/data/poetry-test.utils.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "() => {\n  return Object.values(POETRY_FORMS).map((form) => ({\n    id: form.id,\n    name: form.name,\n    pattern: form.pattern.join('-'),\n  }));\n}"
            },
            {
                "name": "getPoetryFormTestData",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/data/poetry-test.utils.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "(): Record<string, PoetryFormTestData> => {\n  return Object.entries(POETRY_FORMS).reduce((acc, [id, form]) => {\n    acc[id] = {\n      lines: form.lines,\n      pattern: form.pattern,\n    };\n    return acc;\n  }, {} as Record<string, PoetryFormTestData>);\n}"
            },
            {
                "name": "outputDir",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/cli.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "string",
                "defaultValue": "'src/styles'"
            },
            {
                "name": "POETRY_EXAMPLES",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/data/poetry-forms.data.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Record<string, string[]>",
                "defaultValue": "{\n  haiku: ['an old silent pond', 'a frog jumps into the pond', 'splash! silence again'],\n  tanka: [\n    'the falling flower',\n    'i saw drift back to the branch',\n    'was a butterfly',\n    'dancing in the gentle breeze',\n    \"nature's art in motion\",\n  ],\n  cinquain: [\n    'moon',\n    'silent light',\n    'casting silver shadows',\n    'illuminating the dark night',\n    'peace',\n  ],\n  limerick: [\n    'there once was a coder so bright',\n    'who worked on his app every night',\n    'with angular and code',\n    'he built a fine node',\n    \"and launched it to everyone's delight\",\n  ],\n  redondilla: [\n    'in fields of green and gold so bright',\n    'where flowers dance in morning light',\n    'the world awakens from the night',\n    'and fills my heart with pure delight',\n  ],\n  lanterne: ['moon', 'bright glow', 'silver light', 'shining through night', 'peace'],\n  diamante: [\n    'day',\n    'bright warm',\n    'shining glowing heating',\n    'sunrise sunset twilight darkness',\n    'cooling dimming fading',\n    'cold dark',\n    'night',\n  ],\n  fibonacci: ['I', 'am', 'writing', 'syllables', 'in fibonacci', 'a mathematical poetry sequence'],\n}"
            },
            {
                "name": "POETRY_FORM_OPTIONS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/data/poetry-forms.data.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "Object.values(POETRY_FORMS).map((form) => ({\n  value: form.id,\n  label: form.name,\n  description: form.pattern.join('-'),\n}))"
            },
            {
                "name": "POETRY_FORMS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/data/poetry-forms.data.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Record<string, PoetryForm>",
                "defaultValue": "{\n  haiku: {\n    id: 'haiku',\n    name: 'Haiku',\n    pattern: [5, 7, 5],\n    lines: 3,\n    origin: 'Japanese',\n    description: 'Traditional nature poem with 3 lines',\n  },\n  tanka: {\n    id: 'tanka',\n    name: 'Tanka',\n    pattern: [5, 7, 5, 7, 7],\n    lines: 5,\n    origin: 'Japanese',\n    description: 'Extended court poetry with 5 lines',\n  },\n  cinquain: {\n    id: 'cinquain',\n    name: 'Cinquain',\n    pattern: [2, 4, 6, 8, 2],\n    lines: 5,\n    origin: 'American',\n    description: 'Didactic poem with ascending/descending pattern',\n  },\n  limerick: {\n    id: 'limerick',\n    name: 'Limerick',\n    pattern: [8, 8, 5, 5, 8],\n    lines: 5,\n    origin: 'English',\n    description: 'Humorous poem with AABBA rhyme scheme',\n  },\n\n  redondilla: {\n    id: 'redondilla',\n    name: 'Redondilla',\n    pattern: [8, 8, 8, 8],\n    lines: 4,\n    origin: 'Spanish',\n    description: 'Quatrain with consonant rhyme',\n  },\n  lanterne: {\n    id: 'lanterne',\n    name: 'Lanterne',\n    pattern: [1, 2, 3, 4, 1],\n    lines: 5,\n    origin: 'Japanese-inspired',\n    description: 'Lantern-shaped syllabic poem',\n  },\n  diamante: {\n    id: 'diamante',\n    name: 'Diamante',\n    pattern: [1, 2, 3, 4, 3, 2, 1],\n    lines: 7,\n    origin: 'Modern',\n    description: 'Diamond-shaped contrast poem',\n  },\n  fibonacci: {\n    id: 'fibonacci',\n    name: 'Fibonacci',\n    pattern: [1, 1, 2, 3, 5, 8],\n    lines: 6,\n    origin: 'Mathematical',\n    description: 'Follows Fibonacci sequence',\n  },\n}"
            },
            {
                "name": "program",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/capture/cli.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "new Command()"
            },
            {
                "name": "root",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/cli.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "process.cwd()"
            },
            {
                "name": "routes",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/app.routes.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Routes",
                "defaultValue": "[]"
            },
            {
                "name": "SCHEMES",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "literal type[]",
                "defaultValue": "[\n  { name: 'tonal-spot', variant: SchemeTonalSpot },\n  { name: 'neutral', variant: SchemeNeutral },\n  { name: 'vibrant', variant: SchemeVibrant },\n  { name: 'expressive', variant: SchemeExpressive },\n  { name: 'monochrome', variant: SchemeMonochrome },\n  { name: 'content', variant: SchemeContent },\n  { name: 'fidelity', variant: SchemeFidelity },\n  { name: 'fruit-salad', variant: SchemeFruitSalad },\n  { name: 'rainbow', variant: SchemeRainbow },\n]"
            },
            {
                "name": "SEED_COLOR",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "string",
                "defaultValue": "'#F4C2C2'"
            },
            {
                "name": "SELECTED_SCHEME",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "string",
                "defaultValue": "'fidelity'"
            },
            {
                "name": "SELECTORS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/e2e/selectors.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "object",
                "defaultValue": "{\n  FORM_SELECTOR: '#poetry-form-selector',\n  FORM_OPTIONS: {\n    HAIKU: 'haiku',\n    TANKA: 'tanka',\n    CINQUAIN: 'cinquain',\n    LIMERICK: 'limerick',\n    REDONDILLA: 'redondilla',\n    LANTERNE: 'lanterne',\n    DIAMANTE: 'diamante',\n    FIBONACCI: 'fibonacci',\n  },\n\n  BUTTONS: {\n    ANALYZE: '.editor-actions button:has-text(\"analyze\")',\n    CLEAR: '.editor-actions button:has-text(\"clear\")',\n    LOAD_EXAMPLE: '.editor-actions button:has-text(\"example\")',\n    COPY: '.editor-actions button:has-text(\"copy\")',\n\n    APP_BAR: {\n      ANALYZE: '.metro-command-button:has-text(\"analyze\")',\n      CLEAR: '.metro-command-button:has-text(\"clear\")',\n      EXAMPLE: '.metro-command-button:has-text(\"example\")',\n      COPY: '.metro-command-button:has-text(\"copy\")',\n    },\n  },\n\n  EDITOR: {\n    CONTAINER: 'app-poem-editor',\n    LINE_INPUT: (index: number) => `#poem-editor-line-${index}`,\n    SYLLABLE_COUNTER: (index: number) => `.line-row:nth-child(${index + 1}) .syllable-count`,\n    MULTILINE_INPUT: 'app-multiline-input',\n  },\n\n  RESULTS: {\n    CONTAINER: 'app-poem-results',\n    QUALITY_SECTION: 'app-poem-quality',\n    METER_SECTION: 'app-meter-analysis-section',\n    WORD_DETAILS: '.word-details',\n    SUGGESTIONS: 'app-word-suggestions',\n    ANALYSIS_TABS: '.metro-pivot-item',\n  },\n\n  NAVIGATION: {\n    QUICK_NAV: '.nav-pill',\n    PANORAMA_SECTIONS: '[data-section]',\n  },\n\n  STATE: {\n    LOADING: '[class*=\"loading\"], [class*=\"progress\"]',\n    TOAST: {\n      SUCCESS: '.metro-toast-success',\n      ERROR: '.metro-toast-error',\n      INFO: '.metro-toast-info',\n      WARNING: '.metro-toast-warning',\n    },\n  },\n}"
            },
            {
                "name": "TERMINAL_COLORS_CONFIG",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "object",
                "defaultValue": "{\n  red: { hue: 10, chroma: 84, tone: 50 },\n  green: { hue: 145, chroma: 48, tone: 50 },\n  yellow: { hue: 90, chroma: 70, tone: 60 },\n  blue: { hue: 245, chroma: 80, tone: 50 },\n  magenta: { hue: 330, chroma: 68, tone: 50 },\n  cyan: { hue: 200, chroma: 48, tone: 50 },\n}"
            },
            {
                "name": "TERMINAL_CSS_VARS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "[]",
                "defaultValue": "[\n  'red',\n  'redContainer',\n  'onRedContainer',\n  'green',\n  'greenContainer',\n  'onGreenContainer',\n  'yellow',\n  'yellowContainer',\n  'onYellowContainer',\n  'blue',\n  'blueContainer',\n  'onBlueContainer',\n  'magenta',\n  'magentaContainer',\n  'onMagentaContainer',\n  'cyan',\n  'cyanContainer',\n  'onCyanContainer',\n\n  'inverseRed',\n  'inverseRedContainer',\n  'inverseOnRedContainer',\n  'inverseGreen',\n  'inverseGreenContainer',\n  'inverseOnGreenContainer',\n  'inverseYellow',\n  'inverseYellowContainer',\n  'inverseOnYellowContainer',\n  'inverseBlue',\n  'inverseBlueContainer',\n  'inverseOnBlueContainer',\n  'inverseMagenta',\n  'inverseMagentaContainer',\n  'inverseOnMagentaContainer',\n  'inverseCyan',\n  'inverseCyanContainer',\n  'inverseOnCyanContainer',\n]"
            },
            {
                "name": "TEST_EXAMPLES",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/data/poetry-test.utils.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "object",
                "defaultValue": "{\n  HAIKU_WITH_ERRORS: [\n    'A very old silent pond in the forest',\n    'A small green frog jumps',\n    'Big splash sound and then quiet',\n  ] as string[],\n}"
            },
            {
                "name": "TEST_POEMS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/e2e/selectors.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "object",
                "defaultValue": "{\n  HAIKU: ['An old silent pond', 'A frog jumps into the pond', 'Splash! Silence again'],\n  HAIKU_SPANISH: ['Un estanque silencioso', 'Una rana salta al agua', '¡Chap! Silencio otra vez'],\n  TANKA: [\n    'The falling flower',\n    'I saw drift back to the branch',\n    'Was a butterfly',\n    'Dancing in the gentle breeze',\n    \"Nature's art in motion\",\n  ],\n  CINQUAIN: [\n    'Moon',\n    'Silent light',\n    'Casting silver shadows',\n    'Illuminating the dark night',\n    'Peace',\n  ],\n}"
            },
            {
                "name": "THEME_CONFIG",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "object",
                "defaultValue": "{\n  seedColor: SEED_COLOR,\n  selectedScheme: SELECTED_SCHEME,\n  availableSchemes: SCHEMES.map((s) => s.name),\n  materialVariables: THEME_CSS_VARS.length,\n  terminalVariables: TERMINAL_CSS_VARS.length,\n  totalVariables: ALL_CSS_VARS.length,\n}"
            },
            {
                "name": "THEME_CSS_VARS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "[]",
                "defaultValue": "[\n  'primary',\n  'onPrimary',\n  'primaryContainer',\n  'onPrimaryContainer',\n  'secondary',\n  'onSecondary',\n  'secondaryContainer',\n  'onSecondaryContainer',\n  'tertiary',\n  'onTertiary',\n  'tertiaryContainer',\n  'onTertiaryContainer',\n  'error',\n  'onError',\n  'errorContainer',\n  'onErrorContainer',\n  'background',\n  'onBackground',\n  'surface',\n  'surfaceDim',\n  'surfaceBright',\n  'surfaceContainerLowest',\n  'surfaceContainerLow',\n  'surfaceContainer',\n  'surfaceContainerHigh',\n  'surfaceContainerHighest',\n  'onSurface',\n  'surfaceVariant',\n  'onSurfaceVariant',\n  'outline',\n  'outlineVariant',\n  'shadow',\n  'scrim',\n  'inverseSurface',\n  'inverseOnSurface',\n  'inversePrimary',\n]"
            }
        ],
        "functions": [
            {
                "name": "capitalizeFirst",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "str",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "string",
                "jsdoctags": [
                    {
                        "name": "str",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "captureScreenshots",
                "file": "src/lib/capture/screenshot-capture.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "options",
                        "type": "ScreenshotCaptureOptions",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    }
                ],
                "returnType": "Promise<CaptureResult>",
                "jsdoctags": [
                    {
                        "name": "options",
                        "type": "ScreenshotCaptureOptions",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "captureVideo",
                "file": "src/lib/capture/video-capture.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "options",
                        "type": "VideoCaptureOptions",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    }
                ],
                "returnType": "Promise<CaptureResult>",
                "jsdoctags": [
                    {
                        "name": "options",
                        "type": "VideoCaptureOptions",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "createTerminalColorVariations",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "baseHct",
                        "type": "Hct",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "isDark",
                        "type": "boolean",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "literal type",
                "jsdoctags": [
                    {
                        "name": "baseHct",
                        "type": "Hct",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "isDark",
                        "type": "boolean",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "extractColors",
                "file": "src/lib/material-theme/theme-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "scheme",
                        "type": "DynamicScheme",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "Record<string, string>",
                "jsdoctags": [
                    {
                        "name": "scheme",
                        "type": "DynamicScheme",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "generateTerminalColors",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "seedColor",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "defaultValue": "SEED_COLOR"
                    }
                ],
                "returnType": "literal type",
                "jsdoctags": [
                    {
                        "name": "seedColor",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "defaultValue": "SEED_COLOR",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "generateTerminalCSS",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [],
                "returnType": "string"
            },
            {
                "name": "generateTerminalFiles",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "root",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "outputDir",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "void",
                "jsdoctags": [
                    {
                        "name": "root",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "outputDir",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "generateThemeFiles",
                "file": "src/lib/material-theme/theme-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "root",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "outputDir",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "void",
                "jsdoctags": [
                    {
                        "name": "root",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "outputDir",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "getAvailableSchemes",
                "file": "src/lib/material-theme/theme.config.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [],
                "returnType": "string[]"
            },
            {
                "name": "getColorFromScheme",
                "file": "src/lib/material-theme/theme-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "prop",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "scheme",
                        "type": "DynamicScheme",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "number",
                "jsdoctags": [
                    {
                        "name": "prop",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "scheme",
                        "type": "DynamicScheme",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "getConfigInfo",
                "file": "src/lib/material-theme/theme.config.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [],
                "returnType": "string"
            },
            {
                "name": "getSchemeConstructor",
                "file": "src/lib/material-theme/theme.config.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "schemeName",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "SchemeConstructor",
                "jsdoctags": [
                    {
                        "name": "schemeName",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "harmonizeWithSeed",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "baseColor",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "seedColor",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "number",
                "jsdoctags": [
                    {
                        "name": "baseColor",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "seedColor",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "isValidScheme",
                "file": "src/lib/material-theme/theme.config.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "schemeName",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "boolean",
                "jsdoctags": [
                    {
                        "name": "schemeName",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            }
        ],
        "typealiases": [
            {
                "name": "AllColors",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "MaterialColors | TerminalColors",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 193
            },
            {
                "name": "MaterialColors",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 200
            },
            {
                "name": "MeterType",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "\"iambic\" | \"trochaic\" | \"anapestic\" | \"dactylic\" | \"irregular\"",
                "file": "src/app/services/poetry/meter-analysis.service.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 193
            },
            {
                "name": "MockPoetryData",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "Record<string | string[]>",
                "file": "src/app/data/poetry-test.utils.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 184
            },
            {
                "name": "SchemeConstructor",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 186
            },
            {
                "name": "TerminalColors",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 199
            },
            {
                "name": "Theme",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "\"light\" | \"dark\"",
                "file": "src/app/services/core/theme.service.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 193
            }
        ],
        "enumerations": [],
        "groupedVariables": {
            "src/lib/material-theme/theme.config.ts": [
                {
                    "name": "ALL_CSS_VARS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "[]",
                    "defaultValue": "[...THEME_CSS_VARS, ...TERMINAL_CSS_VARS]"
                },
                {
                    "name": "SCHEMES",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type[]",
                    "defaultValue": "[\n  { name: 'tonal-spot', variant: SchemeTonalSpot },\n  { name: 'neutral', variant: SchemeNeutral },\n  { name: 'vibrant', variant: SchemeVibrant },\n  { name: 'expressive', variant: SchemeExpressive },\n  { name: 'monochrome', variant: SchemeMonochrome },\n  { name: 'content', variant: SchemeContent },\n  { name: 'fidelity', variant: SchemeFidelity },\n  { name: 'fruit-salad', variant: SchemeFruitSalad },\n  { name: 'rainbow', variant: SchemeRainbow },\n]"
                },
                {
                    "name": "SEED_COLOR",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "defaultValue": "'#F4C2C2'"
                },
                {
                    "name": "SELECTED_SCHEME",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "defaultValue": "'fidelity'"
                },
                {
                    "name": "TERMINAL_COLORS_CONFIG",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "defaultValue": "{\n  red: { hue: 10, chroma: 84, tone: 50 },\n  green: { hue: 145, chroma: 48, tone: 50 },\n  yellow: { hue: 90, chroma: 70, tone: 60 },\n  blue: { hue: 245, chroma: 80, tone: 50 },\n  magenta: { hue: 330, chroma: 68, tone: 50 },\n  cyan: { hue: 200, chroma: 48, tone: 50 },\n}"
                },
                {
                    "name": "TERMINAL_CSS_VARS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "[]",
                    "defaultValue": "[\n  'red',\n  'redContainer',\n  'onRedContainer',\n  'green',\n  'greenContainer',\n  'onGreenContainer',\n  'yellow',\n  'yellowContainer',\n  'onYellowContainer',\n  'blue',\n  'blueContainer',\n  'onBlueContainer',\n  'magenta',\n  'magentaContainer',\n  'onMagentaContainer',\n  'cyan',\n  'cyanContainer',\n  'onCyanContainer',\n\n  'inverseRed',\n  'inverseRedContainer',\n  'inverseOnRedContainer',\n  'inverseGreen',\n  'inverseGreenContainer',\n  'inverseOnGreenContainer',\n  'inverseYellow',\n  'inverseYellowContainer',\n  'inverseOnYellowContainer',\n  'inverseBlue',\n  'inverseBlueContainer',\n  'inverseOnBlueContainer',\n  'inverseMagenta',\n  'inverseMagentaContainer',\n  'inverseOnMagentaContainer',\n  'inverseCyan',\n  'inverseCyanContainer',\n  'inverseOnCyanContainer',\n]"
                },
                {
                    "name": "THEME_CONFIG",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "defaultValue": "{\n  seedColor: SEED_COLOR,\n  selectedScheme: SELECTED_SCHEME,\n  availableSchemes: SCHEMES.map((s) => s.name),\n  materialVariables: THEME_CSS_VARS.length,\n  terminalVariables: TERMINAL_CSS_VARS.length,\n  totalVariables: ALL_CSS_VARS.length,\n}"
                },
                {
                    "name": "THEME_CSS_VARS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "[]",
                    "defaultValue": "[\n  'primary',\n  'onPrimary',\n  'primaryContainer',\n  'onPrimaryContainer',\n  'secondary',\n  'onSecondary',\n  'secondaryContainer',\n  'onSecondaryContainer',\n  'tertiary',\n  'onTertiary',\n  'tertiaryContainer',\n  'onTertiaryContainer',\n  'error',\n  'onError',\n  'errorContainer',\n  'onErrorContainer',\n  'background',\n  'onBackground',\n  'surface',\n  'surfaceDim',\n  'surfaceBright',\n  'surfaceContainerLowest',\n  'surfaceContainerLow',\n  'surfaceContainer',\n  'surfaceContainerHigh',\n  'surfaceContainerHighest',\n  'onSurface',\n  'surfaceVariant',\n  'onSurfaceVariant',\n  'outline',\n  'outlineVariant',\n  'shadow',\n  'scrim',\n  'inverseSurface',\n  'inverseOnSurface',\n  'inversePrimary',\n]"
                }
            ],
            "src/app/app.config.ts": [
                {
                    "name": "appConfig",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/app.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "ApplicationConfig",
                    "defaultValue": "{\n  providers: [\n    provideBrowserGlobalErrorListeners(),\n    provideZoneChangeDetection({ eventCoalescing: true }),\n    provideRouter(routes),\n  ],\n}"
                }
            ],
            "src/app/data/poetry-test.utils.ts": [
                {
                    "name": "getMockPoetryData",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/data/poetry-test.utils.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "(): MockPoetryData => {\n  const mockData: MockPoetryData = { ...POETRY_EXAMPLES };\n\n  mockData['haikuWithErrors'] = [\n    'A very old silent pond in the forest',\n    'A small green frog jumps',\n    'Big splash sound and then quiet',\n  ];\n\n  return mockData;\n}"
                },
                {
                    "name": "getPoetryFormsForTests",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/data/poetry-test.utils.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "() => {\n  return Object.values(POETRY_FORMS).map((form) => ({\n    id: form.id,\n    name: form.name,\n    pattern: form.pattern.join('-'),\n  }));\n}"
                },
                {
                    "name": "getPoetryFormTestData",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/data/poetry-test.utils.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "(): Record<string, PoetryFormTestData> => {\n  return Object.entries(POETRY_FORMS).reduce((acc, [id, form]) => {\n    acc[id] = {\n      lines: form.lines,\n      pattern: form.pattern,\n    };\n    return acc;\n  }, {} as Record<string, PoetryFormTestData>);\n}"
                },
                {
                    "name": "TEST_EXAMPLES",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/data/poetry-test.utils.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "defaultValue": "{\n  HAIKU_WITH_ERRORS: [\n    'A very old silent pond in the forest',\n    'A small green frog jumps',\n    'Big splash sound and then quiet',\n  ] as string[],\n}"
                }
            ],
            "src/lib/material-theme/cli.ts": [
                {
                    "name": "outputDir",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/cli.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "defaultValue": "'src/styles'"
                },
                {
                    "name": "root",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/cli.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "process.cwd()"
                }
            ],
            "src/app/data/poetry-forms.data.ts": [
                {
                    "name": "POETRY_EXAMPLES",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/data/poetry-forms.data.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Record<string, string[]>",
                    "defaultValue": "{\n  haiku: ['an old silent pond', 'a frog jumps into the pond', 'splash! silence again'],\n  tanka: [\n    'the falling flower',\n    'i saw drift back to the branch',\n    'was a butterfly',\n    'dancing in the gentle breeze',\n    \"nature's art in motion\",\n  ],\n  cinquain: [\n    'moon',\n    'silent light',\n    'casting silver shadows',\n    'illuminating the dark night',\n    'peace',\n  ],\n  limerick: [\n    'there once was a coder so bright',\n    'who worked on his app every night',\n    'with angular and code',\n    'he built a fine node',\n    \"and launched it to everyone's delight\",\n  ],\n  redondilla: [\n    'in fields of green and gold so bright',\n    'where flowers dance in morning light',\n    'the world awakens from the night',\n    'and fills my heart with pure delight',\n  ],\n  lanterne: ['moon', 'bright glow', 'silver light', 'shining through night', 'peace'],\n  diamante: [\n    'day',\n    'bright warm',\n    'shining glowing heating',\n    'sunrise sunset twilight darkness',\n    'cooling dimming fading',\n    'cold dark',\n    'night',\n  ],\n  fibonacci: ['I', 'am', 'writing', 'syllables', 'in fibonacci', 'a mathematical poetry sequence'],\n}"
                },
                {
                    "name": "POETRY_FORM_OPTIONS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/data/poetry-forms.data.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "Object.values(POETRY_FORMS).map((form) => ({\n  value: form.id,\n  label: form.name,\n  description: form.pattern.join('-'),\n}))"
                },
                {
                    "name": "POETRY_FORMS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/data/poetry-forms.data.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Record<string, PoetryForm>",
                    "defaultValue": "{\n  haiku: {\n    id: 'haiku',\n    name: 'Haiku',\n    pattern: [5, 7, 5],\n    lines: 3,\n    origin: 'Japanese',\n    description: 'Traditional nature poem with 3 lines',\n  },\n  tanka: {\n    id: 'tanka',\n    name: 'Tanka',\n    pattern: [5, 7, 5, 7, 7],\n    lines: 5,\n    origin: 'Japanese',\n    description: 'Extended court poetry with 5 lines',\n  },\n  cinquain: {\n    id: 'cinquain',\n    name: 'Cinquain',\n    pattern: [2, 4, 6, 8, 2],\n    lines: 5,\n    origin: 'American',\n    description: 'Didactic poem with ascending/descending pattern',\n  },\n  limerick: {\n    id: 'limerick',\n    name: 'Limerick',\n    pattern: [8, 8, 5, 5, 8],\n    lines: 5,\n    origin: 'English',\n    description: 'Humorous poem with AABBA rhyme scheme',\n  },\n\n  redondilla: {\n    id: 'redondilla',\n    name: 'Redondilla',\n    pattern: [8, 8, 8, 8],\n    lines: 4,\n    origin: 'Spanish',\n    description: 'Quatrain with consonant rhyme',\n  },\n  lanterne: {\n    id: 'lanterne',\n    name: 'Lanterne',\n    pattern: [1, 2, 3, 4, 1],\n    lines: 5,\n    origin: 'Japanese-inspired',\n    description: 'Lantern-shaped syllabic poem',\n  },\n  diamante: {\n    id: 'diamante',\n    name: 'Diamante',\n    pattern: [1, 2, 3, 4, 3, 2, 1],\n    lines: 7,\n    origin: 'Modern',\n    description: 'Diamond-shaped contrast poem',\n  },\n  fibonacci: {\n    id: 'fibonacci',\n    name: 'Fibonacci',\n    pattern: [1, 1, 2, 3, 5, 8],\n    lines: 6,\n    origin: 'Mathematical',\n    description: 'Follows Fibonacci sequence',\n  },\n}"
                }
            ],
            "src/lib/capture/cli.ts": [
                {
                    "name": "program",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/capture/cli.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "new Command()"
                }
            ],
            "src/app/app.routes.ts": [
                {
                    "name": "routes",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/app.routes.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Routes",
                    "defaultValue": "[]"
                }
            ],
            "src/e2e/selectors.ts": [
                {
                    "name": "SELECTORS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/e2e/selectors.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "defaultValue": "{\n  FORM_SELECTOR: '#poetry-form-selector',\n  FORM_OPTIONS: {\n    HAIKU: 'haiku',\n    TANKA: 'tanka',\n    CINQUAIN: 'cinquain',\n    LIMERICK: 'limerick',\n    REDONDILLA: 'redondilla',\n    LANTERNE: 'lanterne',\n    DIAMANTE: 'diamante',\n    FIBONACCI: 'fibonacci',\n  },\n\n  BUTTONS: {\n    ANALYZE: '.editor-actions button:has-text(\"analyze\")',\n    CLEAR: '.editor-actions button:has-text(\"clear\")',\n    LOAD_EXAMPLE: '.editor-actions button:has-text(\"example\")',\n    COPY: '.editor-actions button:has-text(\"copy\")',\n\n    APP_BAR: {\n      ANALYZE: '.metro-command-button:has-text(\"analyze\")',\n      CLEAR: '.metro-command-button:has-text(\"clear\")',\n      EXAMPLE: '.metro-command-button:has-text(\"example\")',\n      COPY: '.metro-command-button:has-text(\"copy\")',\n    },\n  },\n\n  EDITOR: {\n    CONTAINER: 'app-poem-editor',\n    LINE_INPUT: (index: number) => `#poem-editor-line-${index}`,\n    SYLLABLE_COUNTER: (index: number) => `.line-row:nth-child(${index + 1}) .syllable-count`,\n    MULTILINE_INPUT: 'app-multiline-input',\n  },\n\n  RESULTS: {\n    CONTAINER: 'app-poem-results',\n    QUALITY_SECTION: 'app-poem-quality',\n    METER_SECTION: 'app-meter-analysis-section',\n    WORD_DETAILS: '.word-details',\n    SUGGESTIONS: 'app-word-suggestions',\n    ANALYSIS_TABS: '.metro-pivot-item',\n  },\n\n  NAVIGATION: {\n    QUICK_NAV: '.nav-pill',\n    PANORAMA_SECTIONS: '[data-section]',\n  },\n\n  STATE: {\n    LOADING: '[class*=\"loading\"], [class*=\"progress\"]',\n    TOAST: {\n      SUCCESS: '.metro-toast-success',\n      ERROR: '.metro-toast-error',\n      INFO: '.metro-toast-info',\n      WARNING: '.metro-toast-warning',\n    },\n  },\n}"
                },
                {
                    "name": "TEST_POEMS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/e2e/selectors.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "defaultValue": "{\n  HAIKU: ['An old silent pond', 'A frog jumps into the pond', 'Splash! Silence again'],\n  HAIKU_SPANISH: ['Un estanque silencioso', 'Una rana salta al agua', '¡Chap! Silencio otra vez'],\n  TANKA: [\n    'The falling flower',\n    'I saw drift back to the branch',\n    'Was a butterfly',\n    'Dancing in the gentle breeze',\n    \"Nature's art in motion\",\n  ],\n  CINQUAIN: [\n    'Moon',\n    'Silent light',\n    'Casting silver shadows',\n    'Illuminating the dark night',\n    'Peace',\n  ],\n}"
                }
            ]
        },
        "groupedFunctions": {
            "src/lib/material-theme/terminal-generator.ts": [
                {
                    "name": "capitalizeFirst",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "str",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "string",
                    "jsdoctags": [
                        {
                            "name": "str",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "createTerminalColorVariations",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "baseHct",
                            "type": "Hct",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "isDark",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "literal type",
                    "jsdoctags": [
                        {
                            "name": "baseHct",
                            "type": "Hct",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "isDark",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateTerminalColors",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "seedColor",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "SEED_COLOR"
                        }
                    ],
                    "returnType": "literal type",
                    "jsdoctags": [
                        {
                            "name": "seedColor",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "SEED_COLOR",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateTerminalCSS",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [],
                    "returnType": "string"
                },
                {
                    "name": "generateTerminalFiles",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "root",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "void",
                    "jsdoctags": [
                        {
                            "name": "root",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "harmonizeWithSeed",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "baseColor",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "seedColor",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "number",
                    "jsdoctags": [
                        {
                            "name": "baseColor",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "seedColor",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "src/lib/capture/screenshot-capture.ts": [
                {
                    "name": "captureScreenshots",
                    "file": "src/lib/capture/screenshot-capture.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "options",
                            "type": "ScreenshotCaptureOptions",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "returnType": "Promise<CaptureResult>",
                    "jsdoctags": [
                        {
                            "name": "options",
                            "type": "ScreenshotCaptureOptions",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "src/lib/capture/video-capture.ts": [
                {
                    "name": "captureVideo",
                    "file": "src/lib/capture/video-capture.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "options",
                            "type": "VideoCaptureOptions",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "returnType": "Promise<CaptureResult>",
                    "jsdoctags": [
                        {
                            "name": "options",
                            "type": "VideoCaptureOptions",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "src/lib/material-theme/theme-generator.ts": [
                {
                    "name": "extractColors",
                    "file": "src/lib/material-theme/theme-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "scheme",
                            "type": "DynamicScheme",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "Record<string, string>",
                    "jsdoctags": [
                        {
                            "name": "scheme",
                            "type": "DynamicScheme",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateThemeFiles",
                    "file": "src/lib/material-theme/theme-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "root",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "void",
                    "jsdoctags": [
                        {
                            "name": "root",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getColorFromScheme",
                    "file": "src/lib/material-theme/theme-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "prop",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "scheme",
                            "type": "DynamicScheme",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "number",
                    "jsdoctags": [
                        {
                            "name": "prop",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "scheme",
                            "type": "DynamicScheme",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "src/lib/material-theme/theme.config.ts": [
                {
                    "name": "getAvailableSchemes",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [],
                    "returnType": "string[]"
                },
                {
                    "name": "getConfigInfo",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [],
                    "returnType": "string"
                },
                {
                    "name": "getSchemeConstructor",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "schemeName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "SchemeConstructor",
                    "jsdoctags": [
                        {
                            "name": "schemeName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isValidScheme",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "schemeName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "boolean",
                    "jsdoctags": [
                        {
                            "name": "schemeName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ]
        },
        "groupedEnumerations": {},
        "groupedTypeAliases": {
            "src/lib/material-theme/theme.config.ts": [
                {
                    "name": "AllColors",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "MaterialColors | TerminalColors",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 193
                },
                {
                    "name": "MaterialColors",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 200
                },
                {
                    "name": "SchemeConstructor",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 186
                },
                {
                    "name": "TerminalColors",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 199
                }
            ],
            "src/app/services/poetry/meter-analysis.service.ts": [
                {
                    "name": "MeterType",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "\"iambic\" | \"trochaic\" | \"anapestic\" | \"dactylic\" | \"irregular\"",
                    "file": "src/app/services/poetry/meter-analysis.service.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 193
                }
            ],
            "src/app/data/poetry-test.utils.ts": [
                {
                    "name": "MockPoetryData",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "Record<string | string[]>",
                    "file": "src/app/data/poetry-test.utils.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 184
                }
            ],
            "src/app/services/core/theme.service.ts": [
                {
                    "name": "Theme",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "\"light\" | \"dark\"",
                    "file": "src/app/services/core/theme.service.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 193
                }
            ]
        }
    },
    "routes": {
        "name": "<root>",
        "kind": "module",
        "children": []
    },
    "coverage": {
        "count": 2,
        "status": "low",
        "files": [
            {
                "filePath": "src/app/app.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "appConfig",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/app.routes.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "routes",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/app.ts",
                "type": "component",
                "linktype": "component",
                "name": "App",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/components/layout/footer/footer.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "FooterComponent",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/app/components/layout/header/header.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "HeaderComponent",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/components/layout/poetry-page/poetry-page.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PoetryPageComponent",
                "coveragePercent": 0,
                "coverageCount": "0/34",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/appbar/appbar.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "AppBarComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/appbar/appbar.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "AppBarAction",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/list-item/list-item.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ListItemComponent",
                "coveragePercent": 0,
                "coverageCount": "0/10",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/panorama/panorama.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PanoramaComponent",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/pivot/pivot.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PivotComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/pivot/pivot.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "PivotItem",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/progress/progress.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ProgressComponent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/toast-container/toast-container.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ToastContainerComponent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/toggle/toggle.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ToggleComponent",
                "coveragePercent": 0,
                "coverageCount": "0/13",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poetry/meter-analysis-section/meter-analysis-section.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "MeterAnalysisSectionComponent",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poetry/poem-editor/poem-editor.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PoemEditorComponent",
                "coveragePercent": 0,
                "coverageCount": "0/27",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poetry/poem-quality/poem-quality.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PoemQualityComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poetry/poem-results/poem-results.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PoemResultsComponent",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poetry/quick-stats-panel/quick-stats-panel.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "QuickStatsPanelComponent",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poetry/quick-stats-panel/quick-stats-panel.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "QuickStats",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poetry/word-suggestions/word-suggestions.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "WordSuggestionsComponent",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/app/components/theme-toggle/theme-toggle.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ThemeToggleComponent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/accordion/accordion.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "AccordionComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/analysis-panel/analysis-panel.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "AnalysisPanelComponent",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/analysis-panel/analysis-panel.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "AnalysisMetric",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/badge/badge.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "BadgeComponent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/button/button.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ButtonComponent",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/card/card.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "CardComponent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/input/input.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "InputComponent",
                "coveragePercent": 0,
                "coverageCount": "0/20",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/multiline-input/multiline-input.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "MultilineInputComponent",
                "coveragePercent": 0,
                "coverageCount": "0/46",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/multiline-input/multiline-input.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "LineData",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/multiline-input/multiline-input.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "SyllableSegment",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/select/select.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "SelectComponent",
                "coveragePercent": 0,
                "coverageCount": "0/20",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/select/select.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "SelectOption",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/tooltip/tooltip.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "TooltipComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/data/poetry-forms.data.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "POETRY_EXAMPLES",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/data/poetry-forms.data.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "POETRY_FORM_OPTIONS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/data/poetry-forms.data.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "POETRY_FORMS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/data/poetry-test.utils.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "PoetryFormTestData",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/data/poetry-test.utils.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "getMockPoetryData",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/data/poetry-test.utils.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "getPoetryFormsForTests",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/data/poetry-test.utils.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "getPoetryFormTestData",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/data/poetry-test.utils.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "TEST_EXAMPLES",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/data/poetry-test.utils.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "MockPoetryData",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/models/poetry.model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "LineAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/models/poetry.model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "MeterAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/models/poetry.model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "PoetryForm",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/models/poetry.model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "PoetryResult",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/services/core/state.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "StateService",
                "coveragePercent": 0,
                "coverageCount": "0/21",
                "status": "low"
            },
            {
                "filePath": "src/app/services/core/state.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "AppState",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/services/core/theme.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "ThemeService",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/services/core/theme.service.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "Theme",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/services/core/toast.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "ToastService",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/services/core/toast.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "Toast",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/services/core/utils.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "UtilsService",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/meter-analysis.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "MeterAnalysisService",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/meter-analysis.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "MeterAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/meter-analysis.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "RhythmSuggestion",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/meter-analysis.service.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "MeterType",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poem-quality.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "PoemQualityService",
                "coveragePercent": 0,
                "coverageCount": "0/14",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poem-quality.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "QualityMetrics",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analysis.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "PoetryAnalysisService",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analysis.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "PoetryStructure",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analyzer.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "PoetryAnalyzerService",
                "coveragePercent": 0,
                "coverageCount": "0/30",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analyzer.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "EnhancedLineAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analyzer.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "EnhancedPoetryResult",
                "coveragePercent": 0,
                "coverageCount": "0/12",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analyzer.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "WordSuggestionData",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-patterns.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "PoetryPatternsService",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-suggestions.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "PoetrySuggestionsService",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-suggestions.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "SuggestionContext",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-suggestions.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "WordSuggestionData",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rhyme-analysis.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "RhymeAnalysisService",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "RitaService",
                "coveragePercent": 0,
                "coverageCount": "0/15",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "AdvancedSearchOptions",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "AlliterationMatch",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "AlternativeWord",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "GrammaticalAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/11",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "RhymeMatch",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "SyllableAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "WordAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/e2e/advanced-interactions.ts",
                "type": "class",
                "linktype": "classe",
                "name": "AdvancedInteractions",
                "coveragePercent": 91,
                "coverageCount": "11/12",
                "status": "very-good"
            },
            {
                "filePath": "src/e2e/selectors.ts",
                "type": "class",
                "linktype": "classe",
                "name": "TestHelpers",
                "coveragePercent": 90,
                "coverageCount": "10/11",
                "status": "very-good"
            },
            {
                "filePath": "src/e2e/selectors.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "SELECTORS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/e2e/selectors.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "TEST_POEMS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/capture/browser-utils.ts",
                "type": "class",
                "linktype": "classe",
                "name": "BrowserManager",
                "coveragePercent": 87,
                "coverageCount": "7/8",
                "status": "very-good"
            },
            {
                "filePath": "src/lib/capture/browser-utils.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "BrowserLaunchOptions",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/lib/capture/cli.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "program",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/capture/screenshot-capture.ts",
                "type": "class",
                "linktype": "classe",
                "name": "ScreenshotCapture",
                "coveragePercent": 9,
                "coverageCount": "1/11",
                "status": "low"
            },
            {
                "filePath": "src/lib/capture/screenshot-capture.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ScreenshotCaptureOptions",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/lib/capture/screenshot-capture.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "captureScreenshots",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/capture/types.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "BrowserLaunchOptions",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/lib/capture/types.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "CaptureOptions",
                "coveragePercent": 0,
                "coverageCount": "0/10",
                "status": "low"
            },
            {
                "filePath": "src/lib/capture/types.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "CaptureResult",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/lib/capture/video-capture.ts",
                "type": "class",
                "linktype": "classe",
                "name": "VideoCapture",
                "coveragePercent": 55,
                "coverageCount": "5/9",
                "status": "good"
            },
            {
                "filePath": "src/lib/capture/video-capture.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "VideoCaptureOptions",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/lib/capture/video-capture.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "captureVideo",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/cli.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "outputDir",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/cli.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "root",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "capitalizeFirst",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "createTerminalColorVariations",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "generateTerminalColors",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "generateTerminalCSS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "generateTerminalFiles",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "harmonizeWithSeed",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "extractColors",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "generateThemeFiles",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "getColorFromScheme",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ThemeColor",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "getAvailableSchemes",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "getConfigInfo",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "getSchemeConstructor",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "isValidScheme",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "ALL_CSS_VARS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "SCHEMES",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "SEED_COLOR",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "SELECTED_SCHEME",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "TERMINAL_COLORS_CONFIG",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "TERMINAL_CSS_VARS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "THEME_CONFIG",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "THEME_CSS_VARS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "AllColors",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "MaterialColors",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "SchemeConstructor",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "TerminalColors",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            }
        ]
    }
}