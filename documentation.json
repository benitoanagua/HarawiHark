{
    "pipes": [],
    "interfaces": [
        {
            "name": "AdvancedSearchOptions",
            "id": "interface-AdvancedSearchOptions-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "contains",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 51
                },
                {
                    "name": "endsWith",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 50
                },
                {
                    "name": "maxLength",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 53
                },
                {
                    "name": "minLength",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 52
                },
                {
                    "name": "pos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 48
                },
                {
                    "name": "startsWith",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 49
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 47
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "AlliterationMatch",
            "id": "interface-AlliterationMatch-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "positions",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 35
                },
                {
                    "name": "sound",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 36
                },
                {
                    "name": "words",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 34
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "AlternativeWord",
            "id": "interface-AlternativeWord-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "pos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 30
                },
                {
                    "name": "reason",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"exact-match\" | \"rhyme-match\" | \"sound-match\" | \"semantic-rhyme\" | \"spelling-match\" | \"morphological\"",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 23
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22
                },
                {
                    "name": "word",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 21
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "AnalysisMetric",
            "id": "interface-AnalysisMetric-2b245ee2f221fd7660980b99bb7705281f89720740969f8b6fd377319e7ad0ee82c03f5c08db2e9dc1956112fb67663e8a4208df091cf46939a3b11e7b5197c9",
            "file": "src/app/components/ui/analysis-panel/analysis-panel.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CardComponent } from '../card/card.component';\n\nexport interface AnalysisMetric {\n  label: string;\n  value: number | string;\n  maxValue?: number;\n  variant?: 'default' | 'success' | 'warning' | 'error';\n  icon?: string;\n}\n\n@Component({\n  selector: 'app-analysis-panel',\n  standalone: true,\n  imports: [CardComponent],\n  templateUrl: './analysis-panel.component.html',\n})\nexport class AnalysisPanelComponent {\n  @Input() title = '';\n  @Input() metrics: AnalysisMetric[] = [];\n  @Input() compact = false;\n\n  getMetricVariant(metric: AnalysisMetric): string {\n    return `metric-${metric.variant || 'default'}`;\n  }\n\n  getProgressWidth(metric: AnalysisMetric): string {\n    if (metric.maxValue && typeof metric.value === 'number') {\n      const percentage = (metric.value / metric.maxValue) * 100;\n      return `${Math.min(percentage, 100)}%`;\n    }\n    return '0%';\n  }\n}\n",
            "properties": [
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "maxValue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number | string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "variant",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"default\" | \"success\" | \"warning\" | \"error\"",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 8
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "AppBarAction",
            "id": "interface-AppBarAction-e2b9c1c22b3661e41ffb4d97c5f3f2661396ff2f7a1d5f44a0fb7f0d1c26a8dffab14706f2858074a38dc4a9387a9f50a316802752f408c20e23b8e8daa58fe2",
            "file": "src/app/components/metro/appbar/appbar.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nexport interface AppBarAction {\n  id: string;\n  icon: string;\n  label: string;\n  disabled?: boolean;\n}\n\n@Component({\n  selector: 'app-appbar',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './appbar.component.html',\n})\nexport class AppBarComponent {\n  @Input() actions: AppBarAction[] = [];\n  @Input() hidden = false;\n  @Output() actionClick = new EventEmitter<string>();\n\n  onActionClick(actionId: string, disabled?: boolean): void {\n    if (!disabled) {\n      this.actionClick.emit(actionId);\n    }\n  }\n}\n",
            "properties": [
                {
                    "name": "disabled",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "EnhancedLineAnalysis",
            "id": "interface-EnhancedLineAnalysis-cc01c88b56c2eb0b88baa736de26edf66653299b14fecfbb0dc7434c68b3977c7f382c4e601296066b01dfe98a03a03a66ecf008c0598e91718873cd4c5aefdb",
            "file": "src/app/services/poetry/poetry-analyzer.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject, signal } from '@angular/core';\nimport { PoetryAnalysisService } from './poetry-analysis.service';\nimport { PoetrySuggestionsService } from './poetry-suggestions.service';\nimport { PoetryPatternsService } from './poetry-patterns.service';\nimport { RhymeAnalysisService } from './rhyme-analysis.service';\nimport { PoemQualityService, type QualityMetrics } from './poem-quality.service';\nimport {\n  MeterAnalysisService,\n  type MeterAnalysis,\n  type RhythmSuggestion,\n} from './meter-analysis.service';\nimport {\n  RitaService,\n  type GrammaticalAnalysis,\n  type AlliterationMatch,\n  type AlternativeWord,\n} from './rita.service';\nimport { POETRY_FORMS, POETRY_EXAMPLES } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface EnhancedLineAnalysis extends LineAnalysis {\n  words: {\n    word: string;\n    syllables: number;\n    pos: string;\n    phones: string;\n    grammar?: GrammaticalAnalysis;\n  }[];\n  alliterations?: AlliterationMatch[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n}\n\nexport interface EnhancedPoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: EnhancedLineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n  overallAlliterations: AlliterationMatch[];\n  detectedPatterns: string[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n  meterAnalysis?: MeterAnalysis;\n}\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalyzerService {\n  private readonly analysis = inject(PoetryAnalysisService);\n  private readonly suggestions = inject(PoetrySuggestionsService);\n  private readonly patterns = inject(PoetryPatternsService);\n  private readonly rhymes = inject(RhymeAnalysisService);\n  private readonly quality = inject(PoemQualityService);\n  private readonly meterService = inject(MeterAnalysisService);\n  private readonly rita = inject(RitaService);\n\n  readonly isLoading = signal(false);\n  readonly result = signal<EnhancedPoetryResult | null>(null);\n  readonly selectedWord = signal<string | null>(null);\n  readonly wordAlternatives = signal<WordSuggestionData | null>(null);\n  readonly qualityMetrics = signal<QualityMetrics | null>(null);\n  readonly selectedForm = signal<string>('haiku');\n  readonly poemText = signal<string>('');\n  readonly rhythmSuggestions = signal<RhythmSuggestion[]>([]);\n\n  async analyze(formKey: string, rawLines: string[]): Promise<EnhancedPoetryResult> {\n    this.isLoading.set(true);\n\n    try {\n      const form = POETRY_FORMS[formKey];\n      if (!form) {\n        throw new Error(`Unknown form \"${formKey}\"`);\n      }\n\n      const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n      // Análisis dinámico basado en el poema actual\n      const typos = await this.rita.detectTypos(lines);\n      const meterAnalysis = this.meterService.detectMeter(lines);\n      const rhythmSuggestions = this.meterService.generateRhythmSuggestions(\n        lines,\n        meterAnalysis.type\n      );\n      this.rhythmSuggestions.set(rhythmSuggestions);\n\n      const lineAnalyses: EnhancedLineAnalysis[] = await Promise.all(\n        lines.map(async (line, index) => {\n          const analysis = this.rita.analyzeLine(line);\n          const words = this.rita.analyzeWords(line);\n          const alliterations = this.rita.detectAlliterations(line);\n          const expected = form.pattern[index] ?? 0;\n\n          const wordsWithGrammar = words.map((word) => ({\n            ...word,\n            grammar: this.rita.analyzeGrammar(word.word),\n          }));\n\n          return {\n            text: line,\n            count: analysis.syllables,\n            expected,\n            match: analysis.syllables === expected,\n            syllables: analysis.breakdown,\n            stresses: analysis.stresses,\n            words: wordsWithGrammar,\n            alliterations: alliterations.length > 0 ? alliterations : undefined,\n            typos: typos.filter((t) => t.line === index),\n          };\n        })\n      );\n\n      // Calcular calidad basada en el poema actual\n      const quality = this.quality.assessQuality(\n        lines,\n        form.pattern,\n        this.createResultForQualityAssessment(formKey, lineAnalyses)\n      );\n\n      const overallAlliterations = this.rhymes.detectCrossLineAlliterations(lines);\n      const detectedPatterns = [\n        ...this.detectPatterns(lineAnalyses),\n        ...this.generateMeterPatterns(meterAnalysis),\n      ];\n\n      const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n      const mismatches = lineAnalyses.filter((l) => !l.match).length;\n      const summary = ok\n        ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n            '-'\n          )} pattern`\n        : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n      const suggestions = this.generateEnhancedSuggestions(\n        lineAnalyses,\n        form.pattern,\n        meterAnalysis\n      );\n      const rhymeScheme = lines.length > 1 ? this.rita.analyzeRhymeScheme(lines) : undefined;\n\n      const result: EnhancedPoetryResult = {\n        ok,\n        form: formKey,\n        totalLines: {\n          expected: form.pattern.length,\n          actual: lineAnalyses.length,\n        },\n        lines: lineAnalyses,\n        summary,\n        rhymeScheme,\n        suggestions,\n        overallAlliterations,\n        detectedPatterns,\n        typos: typos.length > 0 ? typos : undefined,\n        meterAnalysis,\n      };\n\n      this.result.set(result);\n      this.qualityMetrics.set(quality);\n      return result;\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  async selectWordEnhanced(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) return;\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.suggestions.getWordAlternativesEnhanced(\n              word,\n              neededSyllables,\n              {\n                pos: wordAnalysis.pos,\n                lineIndex: result.lines.indexOf(line),\n                isLineEnd: line.words[line.words.length - 1]?.word === word,\n                previousWord: this.getPreviousWord(line.words, word),\n              }\n            );\n\n            this.wordAlternatives.set(alternatives);\n          } catch (error) {\n            console.warn('Error getting enhanced alternatives:', error);\n            await this.selectWord(word);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  async selectWord(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) {\n      return;\n    }\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.rita.suggestAlternatives(word, neededSyllables, 8);\n            this.wordAlternatives.set({\n              original: word,\n              currentSyllables: wordAnalysis.syllables,\n              targetSyllables: neededSyllables,\n              alternatives,\n            });\n          } catch (error) {\n            console.warn('Error getting word alternatives:', error);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  loadExample(): void {\n    const formId = this.selectedForm();\n    const example = POETRY_EXAMPLES[formId];\n    if (example) {\n      this.poemText.set(example.join('\\n'));\n      // Analizar automáticamente el ejemplo cargado\n      this.analyze(formId, example);\n    }\n  }\n\n  assessQuality(): void {\n    const result = this.result();\n    if (!result) return;\n\n    const lines = result.lines.map((l) => l.text);\n    const pattern = POETRY_FORMS[result.form].pattern;\n\n    const metrics = this.quality.assessQuality(lines, pattern, result);\n    this.qualityMetrics.set(metrics);\n  }\n\n  replaceWord(oldWord: string, newWord: string): void {\n    const result = this.result();\n    if (!result) return;\n\n    const updatedLines = result.lines.map((line) => {\n      const updatedText = line.text.replace(new RegExp(`\\\\b${oldWord}\\\\b`, 'gi'), newWord);\n      return updatedText;\n    });\n\n    this.poemText.set(updatedLines.join('\\n'));\n    this.analyze(result.form, updatedLines);\n    this.selectWordEnhanced(null);\n  }\n\n  clear(): void {\n    this.result.set(null);\n    this.selectedWord.set(null);\n    this.wordAlternatives.set(null);\n    this.qualityMetrics.set(null);\n    this.rhythmSuggestions.set([]);\n    this.poemText.set('');\n  }\n\n  private detectPatterns(lines: EnhancedLineAnalysis[]): string[] {\n    const patterns: string[] = [];\n\n    // Detectar patrones basados en el análisis real\n    const stressPatterns = lines.map((l) => l.stresses).filter((s) => s);\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent stress pattern: ${firstPattern}`);\n      }\n    }\n\n    // Detectar aliteraciones en el poema actual\n    const linesWithAlliteration = lines.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length > 0) {\n      patterns.push(\n        `${linesWithAlliteration.length} line${\n          linesWithAlliteration.length > 1 ? 's' : ''\n        } contain alliteration`\n      );\n    }\n\n    // Análisis de vocabulario del poema actual\n    const allWords = lines.flatMap((l) => l.words);\n    const nouns = allWords.filter((w) => w.pos.startsWith('nn')).length;\n    const verbs = allWords.filter((w) => w.pos.startsWith('vb')).length;\n    const adjectives = allWords.filter((w) => w.pos.startsWith('jj')).length;\n    const adverbs = allWords.filter((w) => w.pos.startsWith('rb')).length;\n\n    if (nouns > verbs * 2) {\n      patterns.push('Noun-heavy composition (descriptive style)');\n    } else if (verbs > nouns * 1.5) {\n      patterns.push('Verb-heavy composition (active style)');\n    }\n\n    if (adjectives > allWords.length * 0.2) {\n      patterns.push('High use of adjectives (vivid imagery)');\n    }\n\n    if (adverbs > allWords.length * 0.15) {\n      patterns.push('Adverb-rich language (detailed action)');\n    }\n\n    // Análisis de longitud de palabras\n    const avgWordLength =\n      allWords.reduce((sum, w) => sum + w.word.length, 0) / (allWords.length || 1);\n    if (avgWordLength > 6) {\n      patterns.push('Complex vocabulary (long words)');\n    } else if (avgWordLength < 4) {\n      patterns.push('Simple vocabulary (short words)');\n    }\n\n    return patterns;\n  }\n\n  private generateMeterPatterns(meter: MeterAnalysis): string[] {\n    const patterns: string[] = [];\n\n    if (meter.consistency > 70) {\n      patterns.push(`Strong ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    } else if (meter.consistency > 40) {\n      patterns.push(`Emerging ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    }\n\n    if (meter.type !== 'irregular') {\n      patterns.push(`Meter: ${meter.pattern}`);\n    }\n\n    return patterns;\n  }\n\n  private generateEnhancedSuggestions(\n    lineAnalyses: EnhancedLineAnalysis[],\n    pattern: number[],\n    meterAnalysis: MeterAnalysis\n  ): string[] {\n    const suggestions: string[] = [];\n\n    // Sugerencias basadas en la estructura del poema actual\n    if (lineAnalyses.length < pattern.length) {\n      const missing = pattern.length - lineAnalyses.length;\n      suggestions.push(`Add ${missing} more line${missing > 1 ? 's' : ''} to complete the pattern`);\n    } else if (lineAnalyses.length > pattern.length) {\n      const extra = lineAnalyses.length - pattern.length;\n      suggestions.push(`Remove ${extra} line${extra > 1 ? 's' : ''} to match the pattern`);\n    }\n\n    // Sugerencias rítmicas basadas en el análisis métrico\n    if (meterAnalysis.consistency < 60) {\n      suggestions.push(\n        `Improve rhythm consistency: ${meterAnalysis.type} meter detected but inconsistent`\n      );\n    }\n\n    if (meterAnalysis.type === 'irregular' && lineAnalyses.length > 2) {\n      suggestions.push('Consider using a regular meter pattern for better poetic flow');\n    }\n\n    // Sugerencias específicas por línea\n    lineAnalyses.forEach((line, index) => {\n      if (!line.match && index < pattern.length) {\n        const lineSuggestions = this.rita.generateSuggestions(line.text, pattern[index]);\n        suggestions.push(`Line ${index + 1}: ${lineSuggestions[0]}`);\n\n        const diff = pattern[index] - line.count;\n        if (diff > 0) {\n          const shortWords = line.words.filter((w) => w.syllables === 1);\n          if (shortWords.length > 0) {\n            suggestions.push(`  → Try replacing \"${shortWords[0].word}\" with a longer synonym`);\n          }\n        } else if (diff < 0) {\n          const longWords = line.words\n            .filter((w) => w.syllables > 2)\n            .sort((a, b) => b.syllables - a.syllables);\n          if (longWords.length > 0) {\n            suggestions.push(\n              `  → Try replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter word`\n            );\n          }\n        }\n      }\n    });\n\n    // Sugerencias de dispositivos literarios\n    const linesWithAlliteration = lineAnalyses.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length === 0 && lineAnalyses.length > 2) {\n      suggestions.push('Consider adding alliteration for poetic effect');\n    }\n\n    const hasRhyme = lineAnalyses.some((line) =>\n      line.words.some(\n        (word) => (word.pos && word.pos.startsWith('nn')) || word.pos.startsWith('vb')\n      )\n    );\n    if (!hasRhyme && lineAnalyses.length > 1) {\n      suggestions.push('Try incorporating rhyme for musical quality');\n    }\n\n    return suggestions.slice(0, 6);\n  }\n\n  private getPreviousWord(words: { word: string }[], currentWord: string): string | undefined {\n    const currentIndex = words.findIndex((w) => w.word.toLowerCase() === currentWord.toLowerCase());\n    return currentIndex > 0 ? words[currentIndex - 1].word : undefined;\n  }\n\n  private createResultForQualityAssessment(\n    formKey: string,\n    lineAnalyses: EnhancedLineAnalysis[]\n  ): EnhancedPoetryResult {\n    const form = POETRY_FORMS[formKey];\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n    return {\n      ok,\n      form: formKey,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      lines: lineAnalyses,\n      summary: '',\n      suggestions: [],\n      overallAlliterations: [],\n      detectedPatterns: [],\n    };\n  }\n\n  isCompletePoem(): boolean {\n    const result = this.result();\n    if (!result) return false;\n\n    return (\n      result.lines.length === result.totalLines.expected && result.lines.every((line) => line.match)\n    );\n  }\n\n  getQuickStats(): {\n    totalSyllables: number;\n    avgSyllablesPerLine: number;\n    vocabularyRichness: number;\n  } {\n    const result = this.result();\n    if (!result || result.lines.length === 0) {\n      return { totalSyllables: 0, avgSyllablesPerLine: 0, vocabularyRichness: 0 };\n    }\n\n    const totalSyllables = result.lines.reduce((sum, line) => sum + line.count, 0);\n    const avgSyllablesPerLine = totalSyllables / result.lines.length;\n\n    const allWords = result.lines.flatMap((line) => line.words.map((w) => w.word.toLowerCase()));\n    const uniqueWords = new Set(allWords);\n    const vocabularyRichness = (uniqueWords.size / allWords.length) * 100;\n\n    return {\n      totalSyllables,\n      avgSyllablesPerLine: Math.round(avgSyllablesPerLine * 10) / 10,\n      vocabularyRichness: Math.round(vocabularyRichness * 10) / 10,\n    };\n  }\n}\n",
            "properties": [
                {
                    "name": "alliterations",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "AlliterationMatch[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 29
                },
                {
                    "name": "typos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 30
                },
                {
                    "name": "words",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": [
                "LineAnalysis"
            ]
        },
        {
            "name": "EnhancedPoetryResult",
            "id": "interface-EnhancedPoetryResult-cc01c88b56c2eb0b88baa736de26edf66653299b14fecfbb0dc7434c68b3977c7f382c4e601296066b01dfe98a03a03a66ecf008c0598e91718873cd4c5aefdb",
            "file": "src/app/services/poetry/poetry-analyzer.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject, signal } from '@angular/core';\nimport { PoetryAnalysisService } from './poetry-analysis.service';\nimport { PoetrySuggestionsService } from './poetry-suggestions.service';\nimport { PoetryPatternsService } from './poetry-patterns.service';\nimport { RhymeAnalysisService } from './rhyme-analysis.service';\nimport { PoemQualityService, type QualityMetrics } from './poem-quality.service';\nimport {\n  MeterAnalysisService,\n  type MeterAnalysis,\n  type RhythmSuggestion,\n} from './meter-analysis.service';\nimport {\n  RitaService,\n  type GrammaticalAnalysis,\n  type AlliterationMatch,\n  type AlternativeWord,\n} from './rita.service';\nimport { POETRY_FORMS, POETRY_EXAMPLES } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface EnhancedLineAnalysis extends LineAnalysis {\n  words: {\n    word: string;\n    syllables: number;\n    pos: string;\n    phones: string;\n    grammar?: GrammaticalAnalysis;\n  }[];\n  alliterations?: AlliterationMatch[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n}\n\nexport interface EnhancedPoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: EnhancedLineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n  overallAlliterations: AlliterationMatch[];\n  detectedPatterns: string[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n  meterAnalysis?: MeterAnalysis;\n}\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalyzerService {\n  private readonly analysis = inject(PoetryAnalysisService);\n  private readonly suggestions = inject(PoetrySuggestionsService);\n  private readonly patterns = inject(PoetryPatternsService);\n  private readonly rhymes = inject(RhymeAnalysisService);\n  private readonly quality = inject(PoemQualityService);\n  private readonly meterService = inject(MeterAnalysisService);\n  private readonly rita = inject(RitaService);\n\n  readonly isLoading = signal(false);\n  readonly result = signal<EnhancedPoetryResult | null>(null);\n  readonly selectedWord = signal<string | null>(null);\n  readonly wordAlternatives = signal<WordSuggestionData | null>(null);\n  readonly qualityMetrics = signal<QualityMetrics | null>(null);\n  readonly selectedForm = signal<string>('haiku');\n  readonly poemText = signal<string>('');\n  readonly rhythmSuggestions = signal<RhythmSuggestion[]>([]);\n\n  async analyze(formKey: string, rawLines: string[]): Promise<EnhancedPoetryResult> {\n    this.isLoading.set(true);\n\n    try {\n      const form = POETRY_FORMS[formKey];\n      if (!form) {\n        throw new Error(`Unknown form \"${formKey}\"`);\n      }\n\n      const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n      // Análisis dinámico basado en el poema actual\n      const typos = await this.rita.detectTypos(lines);\n      const meterAnalysis = this.meterService.detectMeter(lines);\n      const rhythmSuggestions = this.meterService.generateRhythmSuggestions(\n        lines,\n        meterAnalysis.type\n      );\n      this.rhythmSuggestions.set(rhythmSuggestions);\n\n      const lineAnalyses: EnhancedLineAnalysis[] = await Promise.all(\n        lines.map(async (line, index) => {\n          const analysis = this.rita.analyzeLine(line);\n          const words = this.rita.analyzeWords(line);\n          const alliterations = this.rita.detectAlliterations(line);\n          const expected = form.pattern[index] ?? 0;\n\n          const wordsWithGrammar = words.map((word) => ({\n            ...word,\n            grammar: this.rita.analyzeGrammar(word.word),\n          }));\n\n          return {\n            text: line,\n            count: analysis.syllables,\n            expected,\n            match: analysis.syllables === expected,\n            syllables: analysis.breakdown,\n            stresses: analysis.stresses,\n            words: wordsWithGrammar,\n            alliterations: alliterations.length > 0 ? alliterations : undefined,\n            typos: typos.filter((t) => t.line === index),\n          };\n        })\n      );\n\n      // Calcular calidad basada en el poema actual\n      const quality = this.quality.assessQuality(\n        lines,\n        form.pattern,\n        this.createResultForQualityAssessment(formKey, lineAnalyses)\n      );\n\n      const overallAlliterations = this.rhymes.detectCrossLineAlliterations(lines);\n      const detectedPatterns = [\n        ...this.detectPatterns(lineAnalyses),\n        ...this.generateMeterPatterns(meterAnalysis),\n      ];\n\n      const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n      const mismatches = lineAnalyses.filter((l) => !l.match).length;\n      const summary = ok\n        ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n            '-'\n          )} pattern`\n        : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n      const suggestions = this.generateEnhancedSuggestions(\n        lineAnalyses,\n        form.pattern,\n        meterAnalysis\n      );\n      const rhymeScheme = lines.length > 1 ? this.rita.analyzeRhymeScheme(lines) : undefined;\n\n      const result: EnhancedPoetryResult = {\n        ok,\n        form: formKey,\n        totalLines: {\n          expected: form.pattern.length,\n          actual: lineAnalyses.length,\n        },\n        lines: lineAnalyses,\n        summary,\n        rhymeScheme,\n        suggestions,\n        overallAlliterations,\n        detectedPatterns,\n        typos: typos.length > 0 ? typos : undefined,\n        meterAnalysis,\n      };\n\n      this.result.set(result);\n      this.qualityMetrics.set(quality);\n      return result;\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  async selectWordEnhanced(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) return;\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.suggestions.getWordAlternativesEnhanced(\n              word,\n              neededSyllables,\n              {\n                pos: wordAnalysis.pos,\n                lineIndex: result.lines.indexOf(line),\n                isLineEnd: line.words[line.words.length - 1]?.word === word,\n                previousWord: this.getPreviousWord(line.words, word),\n              }\n            );\n\n            this.wordAlternatives.set(alternatives);\n          } catch (error) {\n            console.warn('Error getting enhanced alternatives:', error);\n            await this.selectWord(word);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  async selectWord(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) {\n      return;\n    }\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.rita.suggestAlternatives(word, neededSyllables, 8);\n            this.wordAlternatives.set({\n              original: word,\n              currentSyllables: wordAnalysis.syllables,\n              targetSyllables: neededSyllables,\n              alternatives,\n            });\n          } catch (error) {\n            console.warn('Error getting word alternatives:', error);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  loadExample(): void {\n    const formId = this.selectedForm();\n    const example = POETRY_EXAMPLES[formId];\n    if (example) {\n      this.poemText.set(example.join('\\n'));\n      // Analizar automáticamente el ejemplo cargado\n      this.analyze(formId, example);\n    }\n  }\n\n  assessQuality(): void {\n    const result = this.result();\n    if (!result) return;\n\n    const lines = result.lines.map((l) => l.text);\n    const pattern = POETRY_FORMS[result.form].pattern;\n\n    const metrics = this.quality.assessQuality(lines, pattern, result);\n    this.qualityMetrics.set(metrics);\n  }\n\n  replaceWord(oldWord: string, newWord: string): void {\n    const result = this.result();\n    if (!result) return;\n\n    const updatedLines = result.lines.map((line) => {\n      const updatedText = line.text.replace(new RegExp(`\\\\b${oldWord}\\\\b`, 'gi'), newWord);\n      return updatedText;\n    });\n\n    this.poemText.set(updatedLines.join('\\n'));\n    this.analyze(result.form, updatedLines);\n    this.selectWordEnhanced(null);\n  }\n\n  clear(): void {\n    this.result.set(null);\n    this.selectedWord.set(null);\n    this.wordAlternatives.set(null);\n    this.qualityMetrics.set(null);\n    this.rhythmSuggestions.set([]);\n    this.poemText.set('');\n  }\n\n  private detectPatterns(lines: EnhancedLineAnalysis[]): string[] {\n    const patterns: string[] = [];\n\n    // Detectar patrones basados en el análisis real\n    const stressPatterns = lines.map((l) => l.stresses).filter((s) => s);\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent stress pattern: ${firstPattern}`);\n      }\n    }\n\n    // Detectar aliteraciones en el poema actual\n    const linesWithAlliteration = lines.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length > 0) {\n      patterns.push(\n        `${linesWithAlliteration.length} line${\n          linesWithAlliteration.length > 1 ? 's' : ''\n        } contain alliteration`\n      );\n    }\n\n    // Análisis de vocabulario del poema actual\n    const allWords = lines.flatMap((l) => l.words);\n    const nouns = allWords.filter((w) => w.pos.startsWith('nn')).length;\n    const verbs = allWords.filter((w) => w.pos.startsWith('vb')).length;\n    const adjectives = allWords.filter((w) => w.pos.startsWith('jj')).length;\n    const adverbs = allWords.filter((w) => w.pos.startsWith('rb')).length;\n\n    if (nouns > verbs * 2) {\n      patterns.push('Noun-heavy composition (descriptive style)');\n    } else if (verbs > nouns * 1.5) {\n      patterns.push('Verb-heavy composition (active style)');\n    }\n\n    if (adjectives > allWords.length * 0.2) {\n      patterns.push('High use of adjectives (vivid imagery)');\n    }\n\n    if (adverbs > allWords.length * 0.15) {\n      patterns.push('Adverb-rich language (detailed action)');\n    }\n\n    // Análisis de longitud de palabras\n    const avgWordLength =\n      allWords.reduce((sum, w) => sum + w.word.length, 0) / (allWords.length || 1);\n    if (avgWordLength > 6) {\n      patterns.push('Complex vocabulary (long words)');\n    } else if (avgWordLength < 4) {\n      patterns.push('Simple vocabulary (short words)');\n    }\n\n    return patterns;\n  }\n\n  private generateMeterPatterns(meter: MeterAnalysis): string[] {\n    const patterns: string[] = [];\n\n    if (meter.consistency > 70) {\n      patterns.push(`Strong ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    } else if (meter.consistency > 40) {\n      patterns.push(`Emerging ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    }\n\n    if (meter.type !== 'irregular') {\n      patterns.push(`Meter: ${meter.pattern}`);\n    }\n\n    return patterns;\n  }\n\n  private generateEnhancedSuggestions(\n    lineAnalyses: EnhancedLineAnalysis[],\n    pattern: number[],\n    meterAnalysis: MeterAnalysis\n  ): string[] {\n    const suggestions: string[] = [];\n\n    // Sugerencias basadas en la estructura del poema actual\n    if (lineAnalyses.length < pattern.length) {\n      const missing = pattern.length - lineAnalyses.length;\n      suggestions.push(`Add ${missing} more line${missing > 1 ? 's' : ''} to complete the pattern`);\n    } else if (lineAnalyses.length > pattern.length) {\n      const extra = lineAnalyses.length - pattern.length;\n      suggestions.push(`Remove ${extra} line${extra > 1 ? 's' : ''} to match the pattern`);\n    }\n\n    // Sugerencias rítmicas basadas en el análisis métrico\n    if (meterAnalysis.consistency < 60) {\n      suggestions.push(\n        `Improve rhythm consistency: ${meterAnalysis.type} meter detected but inconsistent`\n      );\n    }\n\n    if (meterAnalysis.type === 'irregular' && lineAnalyses.length > 2) {\n      suggestions.push('Consider using a regular meter pattern for better poetic flow');\n    }\n\n    // Sugerencias específicas por línea\n    lineAnalyses.forEach((line, index) => {\n      if (!line.match && index < pattern.length) {\n        const lineSuggestions = this.rita.generateSuggestions(line.text, pattern[index]);\n        suggestions.push(`Line ${index + 1}: ${lineSuggestions[0]}`);\n\n        const diff = pattern[index] - line.count;\n        if (diff > 0) {\n          const shortWords = line.words.filter((w) => w.syllables === 1);\n          if (shortWords.length > 0) {\n            suggestions.push(`  → Try replacing \"${shortWords[0].word}\" with a longer synonym`);\n          }\n        } else if (diff < 0) {\n          const longWords = line.words\n            .filter((w) => w.syllables > 2)\n            .sort((a, b) => b.syllables - a.syllables);\n          if (longWords.length > 0) {\n            suggestions.push(\n              `  → Try replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter word`\n            );\n          }\n        }\n      }\n    });\n\n    // Sugerencias de dispositivos literarios\n    const linesWithAlliteration = lineAnalyses.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length === 0 && lineAnalyses.length > 2) {\n      suggestions.push('Consider adding alliteration for poetic effect');\n    }\n\n    const hasRhyme = lineAnalyses.some((line) =>\n      line.words.some(\n        (word) => (word.pos && word.pos.startsWith('nn')) || word.pos.startsWith('vb')\n      )\n    );\n    if (!hasRhyme && lineAnalyses.length > 1) {\n      suggestions.push('Try incorporating rhyme for musical quality');\n    }\n\n    return suggestions.slice(0, 6);\n  }\n\n  private getPreviousWord(words: { word: string }[], currentWord: string): string | undefined {\n    const currentIndex = words.findIndex((w) => w.word.toLowerCase() === currentWord.toLowerCase());\n    return currentIndex > 0 ? words[currentIndex - 1].word : undefined;\n  }\n\n  private createResultForQualityAssessment(\n    formKey: string,\n    lineAnalyses: EnhancedLineAnalysis[]\n  ): EnhancedPoetryResult {\n    const form = POETRY_FORMS[formKey];\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n    return {\n      ok,\n      form: formKey,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      lines: lineAnalyses,\n      summary: '',\n      suggestions: [],\n      overallAlliterations: [],\n      detectedPatterns: [],\n    };\n  }\n\n  isCompletePoem(): boolean {\n    const result = this.result();\n    if (!result) return false;\n\n    return (\n      result.lines.length === result.totalLines.expected && result.lines.every((line) => line.match)\n    );\n  }\n\n  getQuickStats(): {\n    totalSyllables: number;\n    avgSyllablesPerLine: number;\n    vocabularyRichness: number;\n  } {\n    const result = this.result();\n    if (!result || result.lines.length === 0) {\n      return { totalSyllables: 0, avgSyllablesPerLine: 0, vocabularyRichness: 0 };\n    }\n\n    const totalSyllables = result.lines.reduce((sum, line) => sum + line.count, 0);\n    const avgSyllablesPerLine = totalSyllables / result.lines.length;\n\n    const allWords = result.lines.flatMap((line) => line.words.map((w) => w.word.toLowerCase()));\n    const uniqueWords = new Set(allWords);\n    const vocabularyRichness = (uniqueWords.size / allWords.length) * 100;\n\n    return {\n      totalSyllables,\n      avgSyllablesPerLine: Math.round(avgSyllablesPerLine * 10) / 10,\n      vocabularyRichness: Math.round(vocabularyRichness * 10) / 10,\n    };\n  }\n}\n",
            "properties": [
                {
                    "name": "detectedPatterns",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 49
                },
                {
                    "name": "form",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 39
                },
                {
                    "name": "lines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "EnhancedLineAnalysis[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 44
                },
                {
                    "name": "meterAnalysis",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MeterAnalysis",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 55
                },
                {
                    "name": "ok",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 38
                },
                {
                    "name": "overallAlliterations",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "AlliterationMatch[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 48
                },
                {
                    "name": "rhymeScheme",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 46
                },
                {
                    "name": "suggestions",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 47
                },
                {
                    "name": "summary",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 45
                },
                {
                    "name": "totalLines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 40
                },
                {
                    "name": "typos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 50
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "GrammaticalAnalysis",
            "id": "interface-GrammaticalAnalysis-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "conjugations",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 64
                },
                {
                    "name": "isAdjective",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 62
                },
                {
                    "name": "isAdverb",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 63
                },
                {
                    "name": "isNoun",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 60
                },
                {
                    "name": "isVerb",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 61
                },
                {
                    "name": "pluralForm",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 65
                },
                {
                    "name": "pos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 58
                },
                {
                    "name": "posLabel",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 59
                },
                {
                    "name": "stemForm",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 66
                },
                {
                    "name": "word",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 57
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "LineAnalysis",
            "id": "interface-LineAnalysis-9f2e5258c8513a233d7e44d78b9506fca3eaeaafe3f4b50c162e9e041de2e3840e9864cfac6cecc24684c7a1eef955a1eafc933f527dada08a89fe2e14324029",
            "file": "src/app/models/poetry.model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface PoetryForm {\n  id: string;\n  name: string;\n  pattern: number[];\n  lines: number;\n  origin: string;\n  description: string;\n}\n\nexport interface LineAnalysis {\n  text: string;\n  count: number;\n  expected: number;\n  match: boolean;\n  syllables: string[];\n  stresses?: string;\n}\n\nexport interface PoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: LineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n}\n\nexport interface MeterAnalysis {\n  pattern: string;\n  type: string;\n  consistency: number;\n}\n",
            "properties": [
                {
                    "name": "count",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 12
                },
                {
                    "name": "expected",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 13
                },
                {
                    "name": "match",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 14
                },
                {
                    "name": "stresses",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15
                },
                {
                    "name": "text",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 11
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "LineData",
            "id": "interface-LineData-37d48f33eba6c5623d25c8f76e5e975918d9aedf3a02260f8aea6fd0400a4cf0e5b27179cd2a277af437f90a7a908c660fa6c2993a0cfacc7ac99b75a262e23e",
            "file": "src/app/components/ui/multiline-input/multiline-input.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {\n  Component,\n  Input,\n  Output,\n  EventEmitter,\n  forwardRef,\n  ElementRef,\n  ViewChild,\n  HostListener,\n  signal,\n  computed,\n  OnInit,\n  inject,\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\nimport { RitaService } from '../../../services/poetry/rita.service';\n\nexport interface LineData {\n  text: string;\n  number: number;\n  focused: boolean;\n  syllables: number;\n  expectedSyllables: number;\n  isCorrect: boolean;\n  isOver: boolean;\n}\n\nexport interface SyllableSegment {\n  index: number;\n  filled: boolean;\n}\n\n@Component({\n  selector: 'app-multiline-input',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './multiline-input.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => MultilineInputComponent),\n      multi: true,\n    },\n  ],\n})\nexport class MultilineInputComponent implements ControlValueAccessor, OnInit {\n  @ViewChild('linesContainer') linesContainer!: ElementRef<HTMLDivElement>;\n\n  @Input() label = '';\n  @Input() placeholder = 'Write your poem line by line...';\n  @Input() error = '';\n  @Input() disabled = false;\n  @Input() rows = 12;\n  @Input() id = 'multiline-input';\n  @Input() showLineNumbers = true;\n  @Input() showLineValidation = false;\n  @Input() expectedPattern: number[] = [];\n  @Input() fontSizeClass = 'text-base'; // Clase por defecto\n\n  private readonly rita = inject(RitaService);\n\n  readonly lines = signal<LineData[]>([]);\n  readonly focusedLineIndex = signal<number | null>(null);\n\n  readonly poemText = computed(() =>\n    this.lines()\n      .map((l) => l.text)\n      .join('\\n')\n  );\n\n  @Input()\n  get value(): string {\n    return this.poemText();\n  }\n  set value(val: string) {\n    this.initializeLines(val || '');\n    this.onChange(this.poemText());\n  }\n\n  @Output() valueChange = new EventEmitter<string>();\n  @Output() inputBlur = new EventEmitter<void>();\n  @Output() lineFocus = new EventEmitter<{ index: number; text: string }>();\n  @Output() lineValidationChange = new EventEmitter<LineData[]>();\n\n  private onChange: (value: string) => void = () => {};\n  private onTouched: () => void = () => {};\n\n  ngOnInit() {\n    this.initializeLines('');\n  }\n\n  private initializeLines(text: string): void {\n    const linesArray = text.split('\\n');\n    const total = this.rows; // Número fijo de líneas\n    const result: LineData[] = [];\n\n    for (let i = 0; i < total; i++) {\n      const expectedSyllables = this.expectedPattern[i] || 0;\n      result.push({\n        text: linesArray[i] || '',\n        number: i + 1,\n        focused: false,\n        syllables: 0,\n        expectedSyllables,\n        isCorrect: false,\n        isOver: false,\n      });\n    }\n    this.lines.set(result);\n    this.updateLineValidation();\n  }\n\n  writeValue(value: string): void {\n    this.initializeLines(value || '');\n  }\n\n  registerOnChange(fn: (value: string) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  onLineInput(index: number, text: string): void {\n    const updated = [...this.lines()];\n    updated[index].text = text;\n\n    // Actualizar validación de sílabas usando RiTa\n    if (this.showLineValidation) {\n      this.updateLineSyllables(updated[index]);\n    }\n\n    this.lines.set(updated);\n    this.emitChanges();\n    this.updateLineValidation();\n  }\n\n  onLineFocus(index: number): void {\n    this.focusedLineIndex.set(index);\n    this.lineFocus.emit({ index, text: this.lines()[index].text });\n  }\n\n  onLineBlur(): void {\n    this.focusedLineIndex.set(null);\n    this.onTouched();\n    this.inputBlur.emit();\n  }\n\n  @HostListener('keydown', ['$event'])\n  handleKeyboardNavigation(event: KeyboardEvent): void {\n    const current = this.focusedLineIndex();\n    if (current === null) return;\n\n    const lines = this.lines();\n\n    switch (event.key) {\n      case 'ArrowUp':\n        event.preventDefault();\n        if (current > 0) this.focusLine(current - 1);\n        break;\n\n      case 'ArrowDown':\n        event.preventDefault();\n        if (current < lines.length - 1) this.focusLine(current + 1);\n        break;\n\n      case 'Enter':\n        if (!event.shiftKey) {\n          event.preventDefault();\n          // No agregar nuevas líneas automáticamente\n          if (current < lines.length - 1) {\n            this.focusLine(current + 1);\n          }\n        }\n        break;\n\n      case 'Tab':\n        event.preventDefault();\n        this.insertTextAtCursor('  ');\n        break;\n    }\n  }\n\n  private focusLine(index: number): void {\n    const input = document.getElementById(`${this.id}-line-${index}`) as HTMLInputElement;\n    if (!input) return;\n\n    input.focus();\n    this.focusedLineIndex.set(index);\n  }\n\n  private insertTextAtCursor(text: string): void {\n    const current = this.focusedLineIndex();\n    if (current === null) return;\n\n    const input = document.getElementById(`${this.id}-line-${current}`) as HTMLInputElement;\n    if (!input) return;\n\n    const start = input.selectionStart || 0;\n    const end = input.selectionEnd || 0;\n    const currentText = this.lines()[current].text;\n\n    const newText = currentText.substring(0, start) + text + currentText.substring(end);\n\n    const updated = [...this.lines()];\n    updated[current].text = newText;\n\n    if (this.showLineValidation) {\n      this.updateLineSyllables(updated[current]);\n    }\n\n    this.lines.set(updated);\n    this.emitChanges();\n    this.updateLineValidation();\n\n    setTimeout(() => {\n      input.focus();\n      input.setSelectionRange(start + text.length, start + text.length);\n    });\n  }\n\n  private updateLineSyllables(line: LineData): void {\n    if (!line.text.trim()) {\n      line.syllables = 0;\n      line.isCorrect = false;\n      line.isOver = false;\n      return;\n    }\n\n    // Usar RiTa para análisis real de sílabas\n    const analysis = this.rita.analyzeLine(line.text);\n    line.syllables = analysis.syllables;\n    line.isCorrect = line.syllables === line.expectedSyllables;\n    line.isOver = line.syllables > line.expectedSyllables;\n  }\n\n  private updateLineValidation(): void {\n    if (this.showLineValidation) {\n      const lines = this.lines();\n      lines.forEach((line) => {\n        if (line.text.trim()) {\n          this.updateLineSyllables(line);\n        }\n      });\n      this.lineValidationChange.emit(lines);\n    }\n  }\n\n  private emitChanges(): void {\n    this.onChange(this.poemText());\n    this.valueChange.emit(this.poemText());\n  }\n\n  // Método para generar segmentos de sílabas\n  getSyllableSegments(line: LineData): SyllableSegment[] {\n    const segments: SyllableSegment[] = [];\n    const expected = line.expectedSyllables;\n    const current = line.syllables;\n\n    for (let i = 0; i < expected; i++) {\n      segments.push({\n        index: i,\n        filled: i < current,\n      });\n    }\n\n    return segments;\n  }\n\n  clear(): void {\n    this.initializeLines('');\n    this.emitChanges();\n    this.focusLine(0);\n  }\n\n  focus(): void {\n    this.focusLine(0);\n  }\n}\n",
            "properties": [
                {
                    "name": "expectedSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 24
                },
                {
                    "name": "focused",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22
                },
                {
                    "name": "isCorrect",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 25
                },
                {
                    "name": "isOver",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 26
                },
                {
                    "name": "number",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 21
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 23
                },
                {
                    "name": "text",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 20
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "MeterAnalysis",
            "id": "interface-MeterAnalysis-9f2e5258c8513a233d7e44d78b9506fca3eaeaafe3f4b50c162e9e041de2e3840e9864cfac6cecc24684c7a1eef955a1eafc933f527dada08a89fe2e14324029",
            "file": "src/app/models/poetry.model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface PoetryForm {\n  id: string;\n  name: string;\n  pattern: number[];\n  lines: number;\n  origin: string;\n  description: string;\n}\n\nexport interface LineAnalysis {\n  text: string;\n  count: number;\n  expected: number;\n  match: boolean;\n  syllables: string[];\n  stresses?: string;\n}\n\nexport interface PoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: LineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n}\n\nexport interface MeterAnalysis {\n  pattern: string;\n  type: string;\n  consistency: number;\n}\n",
            "properties": [
                {
                    "name": "consistency",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 35
                },
                {
                    "name": "pattern",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 33
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 34
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "MeterAnalysis",
            "id": "interface-MeterAnalysis-c8ff5e422e8554e34650a202a0a41732300cf56a1ad0853b3fc676499f4c2ce0c687dd9ecb78f3df657e4274fec3fdc34b0adea4b92825d6d4813ddbc9d71d07-1",
            "file": "src/app/services/poetry/meter-analysis.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService } from './rita.service';\n\nexport type MeterType = 'iambic' | 'trochaic' | 'anapestic' | 'dactylic' | 'irregular';\n\nexport interface MeterAnalysis {\n  type: MeterType;\n  consistency: number;\n  pattern: string;\n  description: string;\n  examples: string[];\n}\n\nexport interface RhythmSuggestion {\n  line: number;\n  current: string;\n  issue: string;\n  suggestion: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class MeterAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  detectMeter(lines: string[]): MeterAnalysis {\n    const stressPatterns = lines\n      .map((line) => this.rita.analyzeLine(line).stresses)\n      .filter((s) => s && s.length > 0);\n\n    if (stressPatterns.length === 0) {\n      return this.getIrregularMeter();\n    }\n\n    const meterCounts = {\n      iambic: 0,\n      trochaic: 0,\n      anapestic: 0,\n      dactylic: 0,\n    };\n\n    stressPatterns.forEach((pattern) => {\n      const stresses = pattern.split('/').map((s) => parseInt(s));\n      const type = this.classifyStressPattern(stresses);\n      if (type !== 'irregular') {\n        meterCounts[type]++;\n      }\n    });\n\n    const total = stressPatterns.length;\n    const dominant = Object.entries(meterCounts).sort(([, a], [, b]) => b - a)[0];\n\n    if (!dominant) {\n      return this.getIrregularMeter();\n    }\n\n    const [type, count] = dominant as [MeterType, number];\n    const consistency = (count / total) * 100;\n\n    if (consistency < 40) {\n      return this.getIrregularMeter();\n    }\n\n    return {\n      type,\n      consistency,\n      pattern: this.getMeterPattern(type),\n      description: this.getMeterDescription(type),\n      examples: this.getMeterExamples(type),\n    };\n  }\n\n  private classifyStressPattern(stresses: number[]): MeterType | 'irregular' {\n    if (stresses.length < 2) return 'irregular';\n\n    const pairs: string[] = [];\n    for (let i = 0; i < stresses.length - 1; i++) {\n      pairs.push(`${stresses[i]}${stresses[i + 1]}`);\n    }\n\n    const pairCounts = {\n      '01': 0,\n      '10': 0,\n      '001': 0,\n      '100': 0,\n    };\n\n    pairs.forEach((pair) => {\n      if (pair === '01') pairCounts['01']++;\n      if (pair === '10') pairCounts['10']++;\n    });\n\n    for (let i = 0; i < stresses.length - 2; i++) {\n      const triplet = `${stresses[i]}${stresses[i + 1]}${stresses[i + 2]}`;\n      if (triplet === '001') pairCounts['001']++;\n      if (triplet === '100') pairCounts['100']++;\n    }\n\n    const max = Math.max(...Object.values(pairCounts));\n    if (max === 0) return 'irregular';\n\n    if (pairCounts['01'] === max) return 'iambic';\n    if (pairCounts['10'] === max) return 'trochaic';\n    if (pairCounts['001'] === max) return 'anapestic';\n    if (pairCounts['100'] === max) return 'dactylic';\n\n    return 'irregular';\n  }\n\n  generateRhythmSuggestions(lines: string[], targetMeter?: MeterType): RhythmSuggestion[] {\n    const suggestions: RhythmSuggestion[] = [];\n    const detectedMeter = this.detectMeter(lines);\n    const target = targetMeter || detectedMeter.type;\n\n    if (target === 'irregular') {\n      return suggestions;\n    }\n\n    lines.forEach((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      if (!analysis.stresses) return;\n\n      const stresses = analysis.stresses.split('/').map((s) => parseInt(s));\n      const lineType = this.classifyStressPattern(stresses);\n\n      if (lineType !== target) {\n        suggestions.push({\n          line: index + 1,\n          current: analysis.stresses,\n          issue: `This line follows a ${lineType} pattern instead of ${target}`,\n          suggestion: `Try restructuring to match the ${target} rhythm (${this.getMeterPattern(\n            target\n          )})`,\n        });\n      }\n    });\n\n    return suggestions;\n  }\n\n  private getMeterPattern(type: MeterType): string {\n    const patterns: Record<MeterType, string> = {\n      iambic: 'da-DUM (0/1)',\n      trochaic: 'DUM-da (1/0)',\n      anapestic: 'da-da-DUM (0/0/1)',\n      dactylic: 'DUM-da-da (1/0/0)',\n      irregular: 'mixed or free verse',\n    };\n    return patterns[type];\n  }\n\n  private getMeterDescription(type: MeterType): string {\n    const descriptions: Record<MeterType, string> = {\n      iambic: 'Most common in English poetry. Sounds natural and flowing.',\n      trochaic: \"Strong, emphatic rhythm. Common in children's verse.\",\n      anapestic: 'Galloping, energetic rhythm. Creates sense of movement.',\n      dactylic: 'Falling rhythm. Rare in English, common in ancient Greek.',\n      irregular: 'No consistent metrical pattern. Free verse or mixed meters.',\n    };\n    return descriptions[type];\n  }\n\n  private getMeterExamples(type: MeterType): string[] {\n    const examples: Record<MeterType, string[]> = {\n      iambic: [\n        \"Shall I compare thee to a summer's day?\",\n        'The curfew tolls the knell of parting day',\n      ],\n      trochaic: ['Tell me not in mournful numbers', 'Tiger, tiger, burning bright'],\n      anapestic: ['Twas the night before Christmas', 'And the sound of a voice that is still'],\n      dactylic: ['This is the forest primeval', 'Cannon to right of them'],\n      irregular: ['Free verse has no set pattern', 'Modern poetry often breaks rules'],\n    };\n    return examples[type];\n  }\n\n  private getIrregularMeter(): MeterAnalysis {\n    return {\n      type: 'irregular',\n      consistency: 0,\n      pattern: 'mixed or free verse',\n      description:\n        'No consistent metrical pattern detected. This could be free verse or mixed meters.',\n      examples: [],\n    };\n  }\n}\n",
            "properties": [
                {
                    "name": "consistency",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "description",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 10
                },
                {
                    "name": "examples",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 11
                },
                {
                    "name": "pattern",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MeterType",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": [],
            "isDuplicate": true,
            "duplicateId": 1,
            "duplicateName": "MeterAnalysis-1"
        },
        {
            "name": "PivotItem",
            "id": "interface-PivotItem-abfe3bd76968416e3e585932504a29deab143cbe42168579def4858ffb8ad907f8caec6ed31cf18d91b80838fe19c44217aa33eeb57eab9e0dc27c36be543685",
            "file": "src/app/components/metro/pivot/pivot.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nexport interface PivotItem {\n  id: string;\n  label: string;\n  disabled?: boolean;\n}\n\n@Component({\n  selector: 'app-pivot',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './pivot.component.html',\n})\nexport class PivotComponent {\n  @Input() items: PivotItem[] = [];\n  @Input() selectedId = '';\n  @Output() selectedChange = new EventEmitter<string>();\n\n  select(id: string): void {\n    if (this.selectedId !== id) {\n      this.selectedId = id;\n      this.selectedChange.emit(id);\n    }\n  }\n}\n",
            "properties": [
                {
                    "name": "disabled",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "PoetryForm",
            "id": "interface-PoetryForm-9f2e5258c8513a233d7e44d78b9506fca3eaeaafe3f4b50c162e9e041de2e3840e9864cfac6cecc24684c7a1eef955a1eafc933f527dada08a89fe2e14324029",
            "file": "src/app/models/poetry.model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface PoetryForm {\n  id: string;\n  name: string;\n  pattern: number[];\n  lines: number;\n  origin: string;\n  description: string;\n}\n\nexport interface LineAnalysis {\n  text: string;\n  count: number;\n  expected: number;\n  match: boolean;\n  syllables: string[];\n  stresses?: string;\n}\n\nexport interface PoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: LineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n}\n\nexport interface MeterAnalysis {\n  pattern: string;\n  type: string;\n  consistency: number;\n}\n",
            "properties": [
                {
                    "name": "description",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 2
                },
                {
                    "name": "lines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 3
                },
                {
                    "name": "origin",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "pattern",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 4
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "PoetryResult",
            "id": "interface-PoetryResult-9f2e5258c8513a233d7e44d78b9506fca3eaeaafe3f4b50c162e9e041de2e3840e9864cfac6cecc24684c7a1eef955a1eafc933f527dada08a89fe2e14324029",
            "file": "src/app/models/poetry.model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface PoetryForm {\n  id: string;\n  name: string;\n  pattern: number[];\n  lines: number;\n  origin: string;\n  description: string;\n}\n\nexport interface LineAnalysis {\n  text: string;\n  count: number;\n  expected: number;\n  match: boolean;\n  syllables: string[];\n  stresses?: string;\n}\n\nexport interface PoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: LineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n}\n\nexport interface MeterAnalysis {\n  pattern: string;\n  type: string;\n  consistency: number;\n}\n",
            "properties": [
                {
                    "name": "form",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 21
                },
                {
                    "name": "lines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "LineAnalysis[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 26
                },
                {
                    "name": "ok",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 20
                },
                {
                    "name": "rhymeScheme",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 28
                },
                {
                    "name": "suggestions",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 29
                },
                {
                    "name": "summary",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 27
                },
                {
                    "name": "totalLines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "PoetryStructure",
            "id": "interface-PoetryStructure-87839deece079bc7847173139a67015b54b1d00fdeef757ab3e95c0a0bdf68b78cba002925ff807dfb5be309a363c259bd762ca785914d525a6a44d20747e0bd",
            "file": "src/app/services/poetry/poetry-analysis.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService } from './rita.service';\nimport { POETRY_FORMS } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface PoetryStructure {\n  lines: LineAnalysis[];\n  totalLines: { expected: number; actual: number };\n  ok: boolean;\n  summary: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  analyzePoemStructure(rawLines: string[], formKey: string): PoetryStructure {\n    const form = POETRY_FORMS[formKey];\n    if (!form) {\n      throw new Error(`Unknown form \"${formKey}\"`);\n    }\n\n    const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n    const lineAnalyses: LineAnalysis[] = lines.map((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      const expected = form.pattern[index] ?? 0;\n\n      return {\n        text: line,\n        count: analysis.syllables,\n        expected,\n        match: analysis.syllables === expected,\n        syllables: analysis.breakdown,\n        stresses: analysis.stresses,\n      };\n    });\n\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n    const mismatches = lineAnalyses.filter((l) => !l.match).length;\n    const summary = ok\n      ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n          '-'\n        )} pattern`\n      : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n    return {\n      lines: lineAnalyses,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      ok,\n      summary,\n    };\n  }\n\n  validateLineSyllables(\n    line: string,\n    expectedSyllables: number\n  ): { valid: boolean; actual: number } {\n    const analysis = this.rita.analyzeLine(line);\n    return {\n      valid: analysis.syllables === expectedSyllables,\n      actual: analysis.syllables,\n    };\n  }\n\n  calculateSyllableAccuracy(lines: string[], pattern: number[]): number {\n    if (lines.length !== pattern.length) return 0;\n\n    let matches = 0;\n    lines.forEach((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      if (analysis.syllables === pattern[index]) {\n        matches++;\n      }\n    });\n\n    return (matches / pattern.length) * 100;\n  }\n\n  detectMeterPattern(lines: string[]): string[] {\n    const patterns: string[] = [];\n    const stressPatterns = lines\n      .map((line) => {\n        const analysis = this.rita.analyzeLine(line);\n        return analysis.stresses;\n      })\n      .filter((s) => s && s.length > 0);\n\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent meter: ${firstPattern}`);\n      }\n    }\n\n    return patterns;\n  }\n}\n",
            "properties": [
                {
                    "name": "lines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "LineAnalysis[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "ok",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "summary",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 10
                },
                {
                    "name": "totalLines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "QualityMetrics",
            "id": "interface-QualityMetrics-7ce486a65750df1898e54ad355d397e9260f98fe45ae68caa60242e267f5634701e7c08a6a7f0953319376c9e4cf54f03e3ba75dc7c2cb9a7365b440b75ed93d",
            "file": "src/app/services/poetry/poem-quality.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { RitaService } from './rita.service';\nimport type { EnhancedPoetryResult } from './poetry-analyzer.service';\n\nexport interface QualityMetrics {\n  score: number;\n  breakdown: {\n    syllableAccuracy: number;\n    phoneticsRichness: number;\n    vocabularyDiversity: number;\n    rhythmConsistency: number;\n    rhetoricalDevices: number;\n  };\n  strengths: string[];\n  improvements: string[];\n  grade: 'A+' | 'A' | 'B+' | 'B' | 'C+' | 'C' | 'D' | 'F';\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoemQualityService {\n  private readonly rita = inject(RitaService);\n\n  assessQuality(lines: string[], pattern: number[], result: EnhancedPoetryResult): QualityMetrics {\n    const metrics = {\n      syllableAccuracy: this.calculateSyllableAccuracy(result, pattern),\n      phoneticsRichness: this.calculatePhoneticRichness(lines),\n      vocabularyDiversity: this.calculateVocabularyDiversity(lines),\n      rhythmConsistency: this.calculateRhythmConsistency(result),\n      rhetoricalDevices: this.calculateRhetoricalDevices(result),\n    };\n\n    const score = this.computeOverallScore(metrics);\n    const grade = this.assignGrade(score);\n    const strengths = this.identifyStrengths(metrics);\n    const improvements = this.suggestImprovements(metrics);\n\n    return {\n      score,\n      breakdown: metrics,\n      strengths,\n      improvements,\n      grade,\n    };\n  }\n\n  private calculateSyllableAccuracy(result: EnhancedPoetryResult, pattern: number[]): number {\n    if (result.lines.length !== pattern.length) return 0;\n\n    const matches = result.lines.filter((line) => line.match).length;\n    return (matches / pattern.length) * 100;\n  }\n\n  private calculatePhoneticRichness(lines: string[]): number {\n    const text = lines.join(' ');\n    const words = RiTa.tokens(text);\n\n    if (words.length === 0) return 0;\n\n    const uniquePhonemes = new Set<string>();\n    words.forEach((word) => {\n      const phones = RiTa.phones(word);\n      if (phones) {\n        phones.split('-').forEach((p) => uniquePhonemes.add(p));\n      }\n    });\n\n    return Math.min(100, (uniquePhonemes.size / 15) * 100);\n  }\n\n  private calculateVocabularyDiversity(lines: string[]): number {\n    const text = lines.join(' ');\n    const tokens = RiTa.tokenize(text);\n    const words = tokens.filter((t) => !RiTa.isPunct(t));\n\n    if (words.length === 0) return 0;\n\n    const unique = new Set(words.map((w) => w.toLowerCase()));\n    const ttr = unique.size / words.length;\n\n    return Math.min(100, (ttr / 0.6) * 100);\n  }\n\n  private calculateRhythmConsistency(result: EnhancedPoetryResult): number {\n    const stressPatterns = result.lines\n      .map((l) => l.stresses)\n      .filter((s): s is string => s !== undefined && s.length > 0);\n\n    if (stressPatterns.length < 2) return 50;\n\n    const firstPattern = stressPatterns[0];\n    const similarCount = stressPatterns.filter(\n      (p) => this.stressSimilarity(firstPattern, p) > 0.6\n    ).length;\n\n    return (similarCount / stressPatterns.length) * 100;\n  }\n\n  private calculateRhetoricalDevices(result: EnhancedPoetryResult): number {\n    let score = 0;\n\n    if (result.overallAlliterations.length > 0) {\n      score += Math.min(20, result.overallAlliterations.length * 5);\n    }\n\n    if (result.rhymeScheme && result.rhymeScheme !== 'A'.repeat(result.lines.length)) {\n      score += 30;\n    }\n\n    const concordance = RiTa.concordance(result.lines.map((l) => l.text).join(' '));\n    const repeatedWords = Object.values(concordance).filter((count) => count > 1).length;\n    if (repeatedWords > 0) {\n      score += Math.min(20, repeatedWords * 4);\n    }\n\n    const allWords = result.lines.flatMap((l) => l.words);\n    const uniquePOS = new Set(allWords.map((w) => w.pos));\n    if (uniquePOS.size >= 4) {\n      score += 15;\n    }\n\n    const sensoryWords = this.countSensoryWords(allWords.map((w) => w.word));\n    if (sensoryWords >= 3) {\n      score += 15;\n    }\n\n    return Math.min(100, score);\n  }\n\n  private computeOverallScore(metrics: QualityMetrics['breakdown']): number {\n    const weights = {\n      syllableAccuracy: 0.35,\n      phoneticsRichness: 0.15,\n      vocabularyDiversity: 0.2,\n      rhythmConsistency: 0.15,\n      rhetoricalDevices: 0.15,\n    };\n\n    return Object.entries(weights).reduce((total, [key, weight]) => {\n      return total + metrics[key as keyof typeof metrics] * weight;\n    }, 0);\n  }\n\n  private assignGrade(score: number): QualityMetrics['grade'] {\n    if (score >= 95) return 'A+';\n    if (score >= 90) return 'A';\n    if (score >= 85) return 'B+';\n    if (score >= 80) return 'B';\n    if (score >= 75) return 'C+';\n    if (score >= 70) return 'C';\n    if (score >= 60) return 'D';\n    return 'F';\n  }\n\n  private identifyStrengths(metrics: QualityMetrics['breakdown']): string[] {\n    const strengths: string[] = [];\n\n    if (metrics.syllableAccuracy === 100) {\n      strengths.push('Perfect syllable matching');\n    } else if (metrics.syllableAccuracy >= 80) {\n      strengths.push('Good syllable accuracy');\n    }\n\n    if (metrics.phoneticsRichness > 80) {\n      strengths.push('Rich phonetic variety');\n    }\n\n    if (metrics.vocabularyDiversity > 75) {\n      strengths.push('Diverse vocabulary');\n    }\n\n    if (metrics.rhythmConsistency > 80) {\n      strengths.push('Consistent rhythm');\n    }\n\n    if (metrics.rhetoricalDevices > 70) {\n      strengths.push('Strong use of literary devices');\n    }\n\n    return strengths.length > 0 ? strengths : ['Good foundation - keep practicing!'];\n  }\n\n  private suggestImprovements(metrics: QualityMetrics['breakdown']): string[] {\n    const improvements: string[] = [];\n\n    if (metrics.syllableAccuracy < 100) {\n      improvements.push('Adjust syllable counts to match the pattern');\n    }\n\n    if (metrics.phoneticsRichness < 60) {\n      improvements.push('Use more varied sounds and phonemes');\n    }\n\n    if (metrics.vocabularyDiversity < 50) {\n      improvements.push('Avoid repeating the same words');\n    }\n\n    if (metrics.rhythmConsistency < 60) {\n      improvements.push('Create more consistent stress patterns');\n    }\n\n    if (metrics.rhetoricalDevices < 50) {\n      improvements.push('Add alliteration, rhyme, or other literary devices');\n    }\n\n    return improvements.length > 0\n      ? improvements\n      : ['Excellent work! Consider experimenting with more complex forms.'];\n  }\n\n  private stressSimilarity(pattern1: string, pattern2: string): number {\n    const arr1 = pattern1.split('/');\n    const arr2 = pattern2.split('/');\n    const maxLen = Math.max(arr1.length, arr2.length);\n\n    let matches = 0;\n    for (let i = 0; i < maxLen; i++) {\n      if (arr1[i] === arr2[i]) matches++;\n    }\n\n    return matches / maxLen;\n  }\n\n  private countSensoryWords(words: string[]): number {\n    const sensoryPatterns = [\n      /bright|dark|color|hue|shade/i,\n      /loud|quiet|sound|music|voice|echo/i,\n      /soft|hard|smooth|rough|warm|cold/i,\n      /sweet|bitter|fragrant|scent|smell/i,\n      /taste|flavor|savory|delicious/i,\n    ];\n\n    return words.filter((word) => sensoryPatterns.some((pattern) => pattern.test(word))).length;\n  }\n}\n",
            "properties": [
                {
                    "name": "breakdown",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "grade",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"A+\" | \"A\" | \"B+\" | \"B\" | \"C+\" | \"C\" | \"D\" | \"F\"",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "improvements",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "score",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "strengths",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "QuickStats",
            "id": "interface-QuickStats-3f49d7f8281c5927dfb1d212c11ba1d8a512667d01e0a77670a5f5e4d23d74709367137484311992e8105bfe5030b3147ac178d701edea0396acf24cd86cab32",
            "file": "src/app/components/poetry/quick-stats-panel/quick-stats-panel.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CardComponent } from '../../ui';\n\nexport interface QuickStats {\n  totalSyllables: number;\n  avgSyllablesPerLine: number;\n  vocabularyRichness: number;\n  patternMatch: string;\n}\n\n@Component({\n  selector: 'app-quick-stats-panel',\n  standalone: true,\n  imports: [CardComponent],\n  templateUrl: './quick-stats-panel.component.html',\n})\nexport class QuickStatsPanelComponent {\n  @Input({ required: true }) stats!: QuickStats;\n}\n",
            "properties": [
                {
                    "name": "avgSyllablesPerLine",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "patternMatch",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "totalSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "vocabularyRichness",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "RhymeMatch",
            "id": "interface-RhymeMatch-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "nearRhymes",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 43
                },
                {
                    "name": "perfectRhymes",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 42
                },
                {
                    "name": "rhymesWith",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 41
                },
                {
                    "name": "word",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 40
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "RhythmSuggestion",
            "id": "interface-RhythmSuggestion-c8ff5e422e8554e34650a202a0a41732300cf56a1ad0853b3fc676499f4c2ce0c687dd9ecb78f3df657e4274fec3fdc34b0adea4b92825d6d4813ddbc9d71d07",
            "file": "src/app/services/poetry/meter-analysis.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService } from './rita.service';\n\nexport type MeterType = 'iambic' | 'trochaic' | 'anapestic' | 'dactylic' | 'irregular';\n\nexport interface MeterAnalysis {\n  type: MeterType;\n  consistency: number;\n  pattern: string;\n  description: string;\n  examples: string[];\n}\n\nexport interface RhythmSuggestion {\n  line: number;\n  current: string;\n  issue: string;\n  suggestion: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class MeterAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  detectMeter(lines: string[]): MeterAnalysis {\n    const stressPatterns = lines\n      .map((line) => this.rita.analyzeLine(line).stresses)\n      .filter((s) => s && s.length > 0);\n\n    if (stressPatterns.length === 0) {\n      return this.getIrregularMeter();\n    }\n\n    const meterCounts = {\n      iambic: 0,\n      trochaic: 0,\n      anapestic: 0,\n      dactylic: 0,\n    };\n\n    stressPatterns.forEach((pattern) => {\n      const stresses = pattern.split('/').map((s) => parseInt(s));\n      const type = this.classifyStressPattern(stresses);\n      if (type !== 'irregular') {\n        meterCounts[type]++;\n      }\n    });\n\n    const total = stressPatterns.length;\n    const dominant = Object.entries(meterCounts).sort(([, a], [, b]) => b - a)[0];\n\n    if (!dominant) {\n      return this.getIrregularMeter();\n    }\n\n    const [type, count] = dominant as [MeterType, number];\n    const consistency = (count / total) * 100;\n\n    if (consistency < 40) {\n      return this.getIrregularMeter();\n    }\n\n    return {\n      type,\n      consistency,\n      pattern: this.getMeterPattern(type),\n      description: this.getMeterDescription(type),\n      examples: this.getMeterExamples(type),\n    };\n  }\n\n  private classifyStressPattern(stresses: number[]): MeterType | 'irregular' {\n    if (stresses.length < 2) return 'irregular';\n\n    const pairs: string[] = [];\n    for (let i = 0; i < stresses.length - 1; i++) {\n      pairs.push(`${stresses[i]}${stresses[i + 1]}`);\n    }\n\n    const pairCounts = {\n      '01': 0,\n      '10': 0,\n      '001': 0,\n      '100': 0,\n    };\n\n    pairs.forEach((pair) => {\n      if (pair === '01') pairCounts['01']++;\n      if (pair === '10') pairCounts['10']++;\n    });\n\n    for (let i = 0; i < stresses.length - 2; i++) {\n      const triplet = `${stresses[i]}${stresses[i + 1]}${stresses[i + 2]}`;\n      if (triplet === '001') pairCounts['001']++;\n      if (triplet === '100') pairCounts['100']++;\n    }\n\n    const max = Math.max(...Object.values(pairCounts));\n    if (max === 0) return 'irregular';\n\n    if (pairCounts['01'] === max) return 'iambic';\n    if (pairCounts['10'] === max) return 'trochaic';\n    if (pairCounts['001'] === max) return 'anapestic';\n    if (pairCounts['100'] === max) return 'dactylic';\n\n    return 'irregular';\n  }\n\n  generateRhythmSuggestions(lines: string[], targetMeter?: MeterType): RhythmSuggestion[] {\n    const suggestions: RhythmSuggestion[] = [];\n    const detectedMeter = this.detectMeter(lines);\n    const target = targetMeter || detectedMeter.type;\n\n    if (target === 'irregular') {\n      return suggestions;\n    }\n\n    lines.forEach((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      if (!analysis.stresses) return;\n\n      const stresses = analysis.stresses.split('/').map((s) => parseInt(s));\n      const lineType = this.classifyStressPattern(stresses);\n\n      if (lineType !== target) {\n        suggestions.push({\n          line: index + 1,\n          current: analysis.stresses,\n          issue: `This line follows a ${lineType} pattern instead of ${target}`,\n          suggestion: `Try restructuring to match the ${target} rhythm (${this.getMeterPattern(\n            target\n          )})`,\n        });\n      }\n    });\n\n    return suggestions;\n  }\n\n  private getMeterPattern(type: MeterType): string {\n    const patterns: Record<MeterType, string> = {\n      iambic: 'da-DUM (0/1)',\n      trochaic: 'DUM-da (1/0)',\n      anapestic: 'da-da-DUM (0/0/1)',\n      dactylic: 'DUM-da-da (1/0/0)',\n      irregular: 'mixed or free verse',\n    };\n    return patterns[type];\n  }\n\n  private getMeterDescription(type: MeterType): string {\n    const descriptions: Record<MeterType, string> = {\n      iambic: 'Most common in English poetry. Sounds natural and flowing.',\n      trochaic: \"Strong, emphatic rhythm. Common in children's verse.\",\n      anapestic: 'Galloping, energetic rhythm. Creates sense of movement.',\n      dactylic: 'Falling rhythm. Rare in English, common in ancient Greek.',\n      irregular: 'No consistent metrical pattern. Free verse or mixed meters.',\n    };\n    return descriptions[type];\n  }\n\n  private getMeterExamples(type: MeterType): string[] {\n    const examples: Record<MeterType, string[]> = {\n      iambic: [\n        \"Shall I compare thee to a summer's day?\",\n        'The curfew tolls the knell of parting day',\n      ],\n      trochaic: ['Tell me not in mournful numbers', 'Tiger, tiger, burning bright'],\n      anapestic: ['Twas the night before Christmas', 'And the sound of a voice that is still'],\n      dactylic: ['This is the forest primeval', 'Cannon to right of them'],\n      irregular: ['Free verse has no set pattern', 'Modern poetry often breaks rules'],\n    };\n    return examples[type];\n  }\n\n  private getIrregularMeter(): MeterAnalysis {\n    return {\n      type: 'irregular',\n      consistency: 0,\n      pattern: 'mixed or free verse',\n      description:\n        'No consistent metrical pattern detected. This could be free verse or mixed meters.',\n      examples: [],\n    };\n  }\n}\n",
            "properties": [
                {
                    "name": "current",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "issue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "line",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15
                },
                {
                    "name": "suggestion",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 18
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "SelectOption",
            "id": "interface-SelectOption-3d3b3a668c59b4c80e2beae9f494be39347e4d0b0c447b11b5aa7a9376f4e3b82c1289dffb65c84d1a0aa2f0974374d1df99eeaabcb1fbf2257e6342344964ef",
            "file": "src/app/components/ui/select/select.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Component, Input, Output, EventEmitter, forwardRef } from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\n\nexport interface SelectOption {\n  value: string;\n  label: string;\n  description?: string;\n}\n\n@Component({\n  selector: 'app-select',\n  standalone: true,\n  templateUrl: './select.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => SelectComponent),\n      multi: true,\n    },\n  ],\n})\nexport class SelectComponent implements ControlValueAccessor {\n  @Input() options: SelectOption[] = [];\n  @Input() label = '';\n  @Input() disabled = false;\n  @Input() id = '';\n\n  @Input()\n  get value(): string {\n    return this._value;\n  }\n  set value(val: string) {\n    this._value = val || '';\n    this.onChange(this._value);\n  }\n\n  _value = '';\n\n  @Output() selectChange = new EventEmitter<string>();\n\n  private onChange: (value: string) => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private onTouched: () => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n\n  writeValue(value: string): void {\n    this._value = value || '';\n  }\n\n  registerOnChange(fn: (value: string) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  onSelectChange(event: Event): void {\n    const target = event.target as HTMLSelectElement;\n    this._value = target.value;\n    this.onChange(this._value);\n    this.selectChange.emit(this._value);\n  }\n\n  onBlur(): void {\n    this.onTouched();\n  }\n}\n",
            "properties": [
                {
                    "name": "description",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "SuggestionContext",
            "id": "interface-SuggestionContext-24eb12fada130bc88b863f4d93cc015155ad8963e6b439cd89626c34ffadb8c508817746d6d4f5f7e11b910ca3bb30339b231a1a9016833254b2677222c8462e",
            "file": "src/app/services/poetry/poetry-suggestions.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService, type AlternativeWord } from './rita.service';\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\nexport interface SuggestionContext {\n  pos?: string;\n  lineIndex?: number;\n  isLineEnd?: boolean;\n  previousWord?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetrySuggestionsService {\n  private readonly rita = inject(RitaService);\n\n  async getWordAlternativesEnhanced(\n    word: string,\n    targetSyllables: number,\n    context: SuggestionContext = {}\n  ): Promise<WordSuggestionData> {\n    const currentSyllables = this.rita.analyzeLine(word).syllables;\n\n    // Búsqueda simple y efectiva - CORREGIR parámetros\n    const [exactMatches, rhymes, phonetic] = await Promise.all([\n      this.searchBySyllables(targetSyllables), // ❌ Eliminar context.pos\n      context.isLineEnd\n        ? this.rita.findRhymes(word, targetSyllables).then((r) => r.perfectRhymes)\n        : Promise.resolve([]),\n      this.rita.suggestAlternatives(word, targetSyllables, 6),\n    ]);\n\n    const allAlternatives = [\n      ...exactMatches,\n      ...rhymes.map((w) => ({\n        word: w, // ✅ w es string, no AlternativeWord\n        syllables: targetSyllables,\n        reason: 'rhyme-match' as const,\n        pos: this.rita.analyzeGrammar(w).pos,\n      })),\n      ...phonetic,\n    ];\n\n    const unique = this.deduplicateAndRank(allAlternatives, word, context);\n\n    return {\n      original: word,\n      currentSyllables,\n      targetSyllables,\n      alternatives: unique.slice(0, 10),\n    };\n  }\n\n  private async searchBySyllables(syllables: number): Promise<AlternativeWord[]> {\n    // ❌ Eliminar pos parameter\n    try {\n      // Búsqueda simple por primera letra y sílabas\n      const results = await this.rita.suggestAlternatives('a', syllables, 8);\n\n      // CORREGIR: results ya son AlternativeWord[], no strings\n      return results.map((altWord) => ({\n        // ✅ altWord es AlternativeWord\n        ...altWord,\n        reason: 'exact-match' as const,\n      }));\n    } catch (error) {\n      console.warn('Search by syllables failed:', error);\n      return [];\n    }\n  }\n\n  private deduplicateAndRank(\n    alternatives: AlternativeWord[],\n    originalWord: string,\n    context: SuggestionContext\n  ): AlternativeWord[] {\n    const seen = new Set<string>();\n    const unique = alternatives.filter((alt) => {\n      const key = alt.word.toLowerCase();\n      if (seen.has(key) || key === originalWord.toLowerCase()) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n\n    return unique.sort((a, b) => {\n      if (a.reason === 'exact-match' && b.reason !== 'exact-match') return -1;\n      if (b.reason === 'exact-match' && a.reason !== 'exact-match') return 1;\n\n      if (context.isLineEnd) {\n        if (a.reason === 'rhyme-match' && b.reason !== 'rhyme-match') return -1;\n        if (b.reason === 'rhyme-match' && a.reason !== 'rhyme-match') return 1;\n      }\n\n      if (context.pos) {\n        const aMatchesPOS = a.pos === context.pos;\n        const bMatchesPOS = b.pos === context.pos;\n        if (aMatchesPOS && !bMatchesPOS) return -1;\n        if (bMatchesPOS && !aMatchesPOS) return 1;\n      }\n\n      return 0;\n    });\n  }\n\n  async getWordAlternatives(word: string, targetSyllables: number): Promise<WordSuggestionData> {\n    return this.getWordAlternativesEnhanced(word, targetSyllables);\n  }\n\n  generateLineSuggestions(line: string, targetSyllables: number): string[] {\n    return this.rita.generateSuggestions(line, targetSyllables);\n  }\n}\n",
            "properties": [
                {
                    "name": "isLineEnd",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 14
                },
                {
                    "name": "lineIndex",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 13
                },
                {
                    "name": "pos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 12
                },
                {
                    "name": "previousWord",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 15
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "SyllableAnalysis",
            "id": "interface-SyllableAnalysis-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "breakdown",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "phones",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "stresses",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "SyllableSegment",
            "id": "interface-SyllableSegment-37d48f33eba6c5623d25c8f76e5e975918d9aedf3a02260f8aea6fd0400a4cf0e5b27179cd2a277af437f90a7a908c660fa6c2993a0cfacc7ac99b75a262e23e",
            "file": "src/app/components/ui/multiline-input/multiline-input.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {\n  Component,\n  Input,\n  Output,\n  EventEmitter,\n  forwardRef,\n  ElementRef,\n  ViewChild,\n  HostListener,\n  signal,\n  computed,\n  OnInit,\n  inject,\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\nimport { RitaService } from '../../../services/poetry/rita.service';\n\nexport interface LineData {\n  text: string;\n  number: number;\n  focused: boolean;\n  syllables: number;\n  expectedSyllables: number;\n  isCorrect: boolean;\n  isOver: boolean;\n}\n\nexport interface SyllableSegment {\n  index: number;\n  filled: boolean;\n}\n\n@Component({\n  selector: 'app-multiline-input',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './multiline-input.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => MultilineInputComponent),\n      multi: true,\n    },\n  ],\n})\nexport class MultilineInputComponent implements ControlValueAccessor, OnInit {\n  @ViewChild('linesContainer') linesContainer!: ElementRef<HTMLDivElement>;\n\n  @Input() label = '';\n  @Input() placeholder = 'Write your poem line by line...';\n  @Input() error = '';\n  @Input() disabled = false;\n  @Input() rows = 12;\n  @Input() id = 'multiline-input';\n  @Input() showLineNumbers = true;\n  @Input() showLineValidation = false;\n  @Input() expectedPattern: number[] = [];\n  @Input() fontSizeClass = 'text-base'; // Clase por defecto\n\n  private readonly rita = inject(RitaService);\n\n  readonly lines = signal<LineData[]>([]);\n  readonly focusedLineIndex = signal<number | null>(null);\n\n  readonly poemText = computed(() =>\n    this.lines()\n      .map((l) => l.text)\n      .join('\\n')\n  );\n\n  @Input()\n  get value(): string {\n    return this.poemText();\n  }\n  set value(val: string) {\n    this.initializeLines(val || '');\n    this.onChange(this.poemText());\n  }\n\n  @Output() valueChange = new EventEmitter<string>();\n  @Output() inputBlur = new EventEmitter<void>();\n  @Output() lineFocus = new EventEmitter<{ index: number; text: string }>();\n  @Output() lineValidationChange = new EventEmitter<LineData[]>();\n\n  private onChange: (value: string) => void = () => {};\n  private onTouched: () => void = () => {};\n\n  ngOnInit() {\n    this.initializeLines('');\n  }\n\n  private initializeLines(text: string): void {\n    const linesArray = text.split('\\n');\n    const total = this.rows; // Número fijo de líneas\n    const result: LineData[] = [];\n\n    for (let i = 0; i < total; i++) {\n      const expectedSyllables = this.expectedPattern[i] || 0;\n      result.push({\n        text: linesArray[i] || '',\n        number: i + 1,\n        focused: false,\n        syllables: 0,\n        expectedSyllables,\n        isCorrect: false,\n        isOver: false,\n      });\n    }\n    this.lines.set(result);\n    this.updateLineValidation();\n  }\n\n  writeValue(value: string): void {\n    this.initializeLines(value || '');\n  }\n\n  registerOnChange(fn: (value: string) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  onLineInput(index: number, text: string): void {\n    const updated = [...this.lines()];\n    updated[index].text = text;\n\n    // Actualizar validación de sílabas usando RiTa\n    if (this.showLineValidation) {\n      this.updateLineSyllables(updated[index]);\n    }\n\n    this.lines.set(updated);\n    this.emitChanges();\n    this.updateLineValidation();\n  }\n\n  onLineFocus(index: number): void {\n    this.focusedLineIndex.set(index);\n    this.lineFocus.emit({ index, text: this.lines()[index].text });\n  }\n\n  onLineBlur(): void {\n    this.focusedLineIndex.set(null);\n    this.onTouched();\n    this.inputBlur.emit();\n  }\n\n  @HostListener('keydown', ['$event'])\n  handleKeyboardNavigation(event: KeyboardEvent): void {\n    const current = this.focusedLineIndex();\n    if (current === null) return;\n\n    const lines = this.lines();\n\n    switch (event.key) {\n      case 'ArrowUp':\n        event.preventDefault();\n        if (current > 0) this.focusLine(current - 1);\n        break;\n\n      case 'ArrowDown':\n        event.preventDefault();\n        if (current < lines.length - 1) this.focusLine(current + 1);\n        break;\n\n      case 'Enter':\n        if (!event.shiftKey) {\n          event.preventDefault();\n          // No agregar nuevas líneas automáticamente\n          if (current < lines.length - 1) {\n            this.focusLine(current + 1);\n          }\n        }\n        break;\n\n      case 'Tab':\n        event.preventDefault();\n        this.insertTextAtCursor('  ');\n        break;\n    }\n  }\n\n  private focusLine(index: number): void {\n    const input = document.getElementById(`${this.id}-line-${index}`) as HTMLInputElement;\n    if (!input) return;\n\n    input.focus();\n    this.focusedLineIndex.set(index);\n  }\n\n  private insertTextAtCursor(text: string): void {\n    const current = this.focusedLineIndex();\n    if (current === null) return;\n\n    const input = document.getElementById(`${this.id}-line-${current}`) as HTMLInputElement;\n    if (!input) return;\n\n    const start = input.selectionStart || 0;\n    const end = input.selectionEnd || 0;\n    const currentText = this.lines()[current].text;\n\n    const newText = currentText.substring(0, start) + text + currentText.substring(end);\n\n    const updated = [...this.lines()];\n    updated[current].text = newText;\n\n    if (this.showLineValidation) {\n      this.updateLineSyllables(updated[current]);\n    }\n\n    this.lines.set(updated);\n    this.emitChanges();\n    this.updateLineValidation();\n\n    setTimeout(() => {\n      input.focus();\n      input.setSelectionRange(start + text.length, start + text.length);\n    });\n  }\n\n  private updateLineSyllables(line: LineData): void {\n    if (!line.text.trim()) {\n      line.syllables = 0;\n      line.isCorrect = false;\n      line.isOver = false;\n      return;\n    }\n\n    // Usar RiTa para análisis real de sílabas\n    const analysis = this.rita.analyzeLine(line.text);\n    line.syllables = analysis.syllables;\n    line.isCorrect = line.syllables === line.expectedSyllables;\n    line.isOver = line.syllables > line.expectedSyllables;\n  }\n\n  private updateLineValidation(): void {\n    if (this.showLineValidation) {\n      const lines = this.lines();\n      lines.forEach((line) => {\n        if (line.text.trim()) {\n          this.updateLineSyllables(line);\n        }\n      });\n      this.lineValidationChange.emit(lines);\n    }\n  }\n\n  private emitChanges(): void {\n    this.onChange(this.poemText());\n    this.valueChange.emit(this.poemText());\n  }\n\n  // Método para generar segmentos de sílabas\n  getSyllableSegments(line: LineData): SyllableSegment[] {\n    const segments: SyllableSegment[] = [];\n    const expected = line.expectedSyllables;\n    const current = line.syllables;\n\n    for (let i = 0; i < expected; i++) {\n      segments.push({\n        index: i,\n        filled: i < current,\n      });\n    }\n\n    return segments;\n  }\n\n  clear(): void {\n    this.initializeLines('');\n    this.emitChanges();\n    this.focusLine(0);\n  }\n\n  focus(): void {\n    this.focusLine(0);\n  }\n}\n",
            "properties": [
                {
                    "name": "filled",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 31
                },
                {
                    "name": "index",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 30
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "ThemeColor",
            "id": "interface-ThemeColor-29cfd58f74de1dba14f11aa909802f2e70d9e93dcf90e3100a1d0aa8c6d81a367c96a7f818a276a876bd9065787802d4cb308f76a4f67e543e96d47808c31a60",
            "file": "src/lib/material-theme/theme.config.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {\n  SchemeTonalSpot,\n  SchemeNeutral,\n  SchemeVibrant,\n  SchemeExpressive,\n  SchemeMonochrome,\n  SchemeContent,\n  SchemeFidelity,\n  SchemeFruitSalad,\n  SchemeRainbow,\n  Hct,\n  type DynamicScheme,\n} from '@material/material-color-utilities';\n\nexport type SchemeConstructor = new (\n  sourceColorHct: Hct,\n  isDark: boolean,\n  contrastLevel: number\n) => DynamicScheme;\n\nexport const SEED_COLOR = '#F4C2C2';\n\nexport const SCHEMES: { name: string; variant: SchemeConstructor }[] = [\n  { name: 'tonal-spot', variant: SchemeTonalSpot },\n  { name: 'neutral', variant: SchemeNeutral },\n  { name: 'vibrant', variant: SchemeVibrant },\n  { name: 'expressive', variant: SchemeExpressive },\n  { name: 'monochrome', variant: SchemeMonochrome },\n  { name: 'content', variant: SchemeContent },\n  { name: 'fidelity', variant: SchemeFidelity },\n  { name: 'fruit-salad', variant: SchemeFruitSalad },\n  { name: 'rainbow', variant: SchemeRainbow },\n];\n\nexport const SELECTED_SCHEME = 'fidelity';\n\nexport const TERMINAL_COLORS_CONFIG = {\n  red: { hue: 10, chroma: 84, tone: 50 },\n  green: { hue: 145, chroma: 48, tone: 50 },\n  yellow: { hue: 90, chroma: 70, tone: 60 },\n  blue: { hue: 245, chroma: 80, tone: 50 },\n  magenta: { hue: 330, chroma: 68, tone: 50 },\n  cyan: { hue: 200, chroma: 48, tone: 50 },\n};\n\nexport const THEME_CSS_VARS = [\n  'primary',\n  'onPrimary',\n  'primaryContainer',\n  'onPrimaryContainer',\n  'secondary',\n  'onSecondary',\n  'secondaryContainer',\n  'onSecondaryContainer',\n  'tertiary',\n  'onTertiary',\n  'tertiaryContainer',\n  'onTertiaryContainer',\n  'error',\n  'onError',\n  'errorContainer',\n  'onErrorContainer',\n  'background',\n  'onBackground',\n  'surface',\n  'surfaceDim',\n  'surfaceBright',\n  'surfaceContainerLowest',\n  'surfaceContainerLow',\n  'surfaceContainer',\n  'surfaceContainerHigh',\n  'surfaceContainerHighest',\n  'onSurface',\n  'surfaceVariant',\n  'onSurfaceVariant',\n  'outline',\n  'outlineVariant',\n  'shadow',\n  'scrim',\n  'inverseSurface',\n  'inverseOnSurface',\n  'inversePrimary',\n];\n\nexport const TERMINAL_CSS_VARS = [\n  'red',\n  'redContainer',\n  'onRedContainer',\n  'green',\n  'greenContainer',\n  'onGreenContainer',\n  'yellow',\n  'yellowContainer',\n  'onYellowContainer',\n  'blue',\n  'blueContainer',\n  'onBlueContainer',\n  'magenta',\n  'magentaContainer',\n  'onMagentaContainer',\n  'cyan',\n  'cyanContainer',\n  'onCyanContainer',\n\n  'inverseRed',\n  'inverseRedContainer',\n  'inverseOnRedContainer',\n  'inverseGreen',\n  'inverseGreenContainer',\n  'inverseOnGreenContainer',\n  'inverseYellow',\n  'inverseYellowContainer',\n  'inverseOnYellowContainer',\n  'inverseBlue',\n  'inverseBlueContainer',\n  'inverseOnBlueContainer',\n  'inverseMagenta',\n  'inverseMagentaContainer',\n  'inverseOnMagentaContainer',\n  'inverseCyan',\n  'inverseCyanContainer',\n  'inverseOnCyanContainer',\n];\n\nexport const ALL_CSS_VARS = [...THEME_CSS_VARS, ...TERMINAL_CSS_VARS];\n\nexport const THEME_CONFIG = {\n  seedColor: SEED_COLOR,\n  selectedScheme: SELECTED_SCHEME,\n  availableSchemes: SCHEMES.map((s) => s.name),\n  materialVariables: THEME_CSS_VARS.length,\n  terminalVariables: TERMINAL_CSS_VARS.length,\n  totalVariables: ALL_CSS_VARS.length,\n};\n\nexport interface ThemeColor {\n  hue: number;\n  chroma: number;\n  tone: number;\n}\n\nexport type TerminalColors = keyof typeof TERMINAL_COLORS_CONFIG;\nexport type MaterialColors = (typeof THEME_CSS_VARS)[number];\nexport type AllColors = MaterialColors | TerminalColors;\n\nexport function getSchemeConstructor(schemeName: string): SchemeConstructor {\n  const scheme = SCHEMES.find((s) => s.name === schemeName);\n  if (!scheme) {\n    throw new Error(\n      `Scheme not found: ${schemeName}. Available schemes: ${SCHEMES.map((s) => s.name).join(', ')}`\n    );\n  }\n  return scheme.variant;\n}\n\nexport function isValidScheme(schemeName: string): boolean {\n  return SCHEMES.some((s) => s.name === schemeName);\n}\n\nexport function getAvailableSchemes(): string[] {\n  return SCHEMES.map((s) => s.name);\n}\n\nexport function getConfigInfo(): string {\n  return `\nTheme Configuration:\n-------------------\nSeed Color: ${SEED_COLOR}\nSelected Scheme: ${SELECTED_SCHEME}\nAvailable Schemes: ${getAvailableSchemes().join(', ')}\nMaterial Variables: ${THEME_CSS_VARS.length}\nTerminal Variables: ${TERMINAL_CSS_VARS.length}\nTotal Variables: ${ALL_CSS_VARS.length}\n  `.trim();\n}\n",
            "properties": [
                {
                    "name": "chroma",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 138
                },
                {
                    "name": "hue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 137
                },
                {
                    "name": "tone",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 139
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "Toast",
            "id": "interface-Toast-205f8fc4fe55ff61e7a3cf41dd3a9d73f11125462cf7913be0245820b502a81c21aa52c8693e3125c6a9cacd729836a9ad71c7771ba8cb8c9178a57c63c1e422",
            "file": "src/app/services/core/toast.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, signal } from '@angular/core';\n\nexport interface Toast {\n  id: string;\n  title: string;\n  message?: string;\n  type: 'info' | 'success' | 'warning' | 'error';\n  duration?: number;\n}\n\n@Injectable({ providedIn: 'root' })\nexport class ToastService {\n  readonly toasts = signal<Toast[]>([]);\n\n  show(toast: Omit<Toast, 'id'>): void {\n    const id = crypto.randomUUID();\n    const duration = toast.duration ?? 3000;\n\n    this.toasts.update((toasts) => [...toasts, { ...toast, id }]);\n\n    if (duration > 0) {\n      setTimeout(() => this.remove(id), duration);\n    }\n  }\n\n  remove(id: string): void {\n    this.toasts.update((toasts) => toasts.filter((t) => t.id !== id));\n  }\n\n  success(title: string, message?: string, duration?: number): void {\n    this.show({ title, message, type: 'success', duration });\n  }\n\n  error(title: string, message?: string, duration?: number): void {\n    this.show({ title, message, type: 'error', duration });\n  }\n\n  info(title: string, message?: string, duration?: number): void {\n    this.show({ title, message, type: 'info', duration });\n  }\n\n  warning(title: string, message?: string, duration?: number): void {\n    this.show({ title, message, type: 'warning', duration });\n  }\n}\n",
            "properties": [
                {
                    "name": "duration",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "message",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "title",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"info\" | \"success\" | \"warning\" | \"error\"",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "WordAnalysis",
            "id": "interface-WordAnalysis-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "phones",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15
                },
                {
                    "name": "pos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "stresses",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 14
                },
                {
                    "name": "word",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 13
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "WordSuggestionData",
            "id": "interface-WordSuggestionData-cc01c88b56c2eb0b88baa736de26edf66653299b14fecfbb0dc7434c68b3977c7f382c4e601296066b01dfe98a03a03a66ecf008c0598e91718873cd4c5aefdb",
            "file": "src/app/services/poetry/poetry-analyzer.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject, signal } from '@angular/core';\nimport { PoetryAnalysisService } from './poetry-analysis.service';\nimport { PoetrySuggestionsService } from './poetry-suggestions.service';\nimport { PoetryPatternsService } from './poetry-patterns.service';\nimport { RhymeAnalysisService } from './rhyme-analysis.service';\nimport { PoemQualityService, type QualityMetrics } from './poem-quality.service';\nimport {\n  MeterAnalysisService,\n  type MeterAnalysis,\n  type RhythmSuggestion,\n} from './meter-analysis.service';\nimport {\n  RitaService,\n  type GrammaticalAnalysis,\n  type AlliterationMatch,\n  type AlternativeWord,\n} from './rita.service';\nimport { POETRY_FORMS, POETRY_EXAMPLES } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface EnhancedLineAnalysis extends LineAnalysis {\n  words: {\n    word: string;\n    syllables: number;\n    pos: string;\n    phones: string;\n    grammar?: GrammaticalAnalysis;\n  }[];\n  alliterations?: AlliterationMatch[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n}\n\nexport interface EnhancedPoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: EnhancedLineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n  overallAlliterations: AlliterationMatch[];\n  detectedPatterns: string[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n  meterAnalysis?: MeterAnalysis;\n}\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalyzerService {\n  private readonly analysis = inject(PoetryAnalysisService);\n  private readonly suggestions = inject(PoetrySuggestionsService);\n  private readonly patterns = inject(PoetryPatternsService);\n  private readonly rhymes = inject(RhymeAnalysisService);\n  private readonly quality = inject(PoemQualityService);\n  private readonly meterService = inject(MeterAnalysisService);\n  private readonly rita = inject(RitaService);\n\n  readonly isLoading = signal(false);\n  readonly result = signal<EnhancedPoetryResult | null>(null);\n  readonly selectedWord = signal<string | null>(null);\n  readonly wordAlternatives = signal<WordSuggestionData | null>(null);\n  readonly qualityMetrics = signal<QualityMetrics | null>(null);\n  readonly selectedForm = signal<string>('haiku');\n  readonly poemText = signal<string>('');\n  readonly rhythmSuggestions = signal<RhythmSuggestion[]>([]);\n\n  async analyze(formKey: string, rawLines: string[]): Promise<EnhancedPoetryResult> {\n    this.isLoading.set(true);\n\n    try {\n      const form = POETRY_FORMS[formKey];\n      if (!form) {\n        throw new Error(`Unknown form \"${formKey}\"`);\n      }\n\n      const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n      // Análisis dinámico basado en el poema actual\n      const typos = await this.rita.detectTypos(lines);\n      const meterAnalysis = this.meterService.detectMeter(lines);\n      const rhythmSuggestions = this.meterService.generateRhythmSuggestions(\n        lines,\n        meterAnalysis.type\n      );\n      this.rhythmSuggestions.set(rhythmSuggestions);\n\n      const lineAnalyses: EnhancedLineAnalysis[] = await Promise.all(\n        lines.map(async (line, index) => {\n          const analysis = this.rita.analyzeLine(line);\n          const words = this.rita.analyzeWords(line);\n          const alliterations = this.rita.detectAlliterations(line);\n          const expected = form.pattern[index] ?? 0;\n\n          const wordsWithGrammar = words.map((word) => ({\n            ...word,\n            grammar: this.rita.analyzeGrammar(word.word),\n          }));\n\n          return {\n            text: line,\n            count: analysis.syllables,\n            expected,\n            match: analysis.syllables === expected,\n            syllables: analysis.breakdown,\n            stresses: analysis.stresses,\n            words: wordsWithGrammar,\n            alliterations: alliterations.length > 0 ? alliterations : undefined,\n            typos: typos.filter((t) => t.line === index),\n          };\n        })\n      );\n\n      // Calcular calidad basada en el poema actual\n      const quality = this.quality.assessQuality(\n        lines,\n        form.pattern,\n        this.createResultForQualityAssessment(formKey, lineAnalyses)\n      );\n\n      const overallAlliterations = this.rhymes.detectCrossLineAlliterations(lines);\n      const detectedPatterns = [\n        ...this.detectPatterns(lineAnalyses),\n        ...this.generateMeterPatterns(meterAnalysis),\n      ];\n\n      const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n      const mismatches = lineAnalyses.filter((l) => !l.match).length;\n      const summary = ok\n        ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n            '-'\n          )} pattern`\n        : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n      const suggestions = this.generateEnhancedSuggestions(\n        lineAnalyses,\n        form.pattern,\n        meterAnalysis\n      );\n      const rhymeScheme = lines.length > 1 ? this.rita.analyzeRhymeScheme(lines) : undefined;\n\n      const result: EnhancedPoetryResult = {\n        ok,\n        form: formKey,\n        totalLines: {\n          expected: form.pattern.length,\n          actual: lineAnalyses.length,\n        },\n        lines: lineAnalyses,\n        summary,\n        rhymeScheme,\n        suggestions,\n        overallAlliterations,\n        detectedPatterns,\n        typos: typos.length > 0 ? typos : undefined,\n        meterAnalysis,\n      };\n\n      this.result.set(result);\n      this.qualityMetrics.set(quality);\n      return result;\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  async selectWordEnhanced(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) return;\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.suggestions.getWordAlternativesEnhanced(\n              word,\n              neededSyllables,\n              {\n                pos: wordAnalysis.pos,\n                lineIndex: result.lines.indexOf(line),\n                isLineEnd: line.words[line.words.length - 1]?.word === word,\n                previousWord: this.getPreviousWord(line.words, word),\n              }\n            );\n\n            this.wordAlternatives.set(alternatives);\n          } catch (error) {\n            console.warn('Error getting enhanced alternatives:', error);\n            await this.selectWord(word);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  async selectWord(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) {\n      return;\n    }\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.rita.suggestAlternatives(word, neededSyllables, 8);\n            this.wordAlternatives.set({\n              original: word,\n              currentSyllables: wordAnalysis.syllables,\n              targetSyllables: neededSyllables,\n              alternatives,\n            });\n          } catch (error) {\n            console.warn('Error getting word alternatives:', error);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  loadExample(): void {\n    const formId = this.selectedForm();\n    const example = POETRY_EXAMPLES[formId];\n    if (example) {\n      this.poemText.set(example.join('\\n'));\n      // Analizar automáticamente el ejemplo cargado\n      this.analyze(formId, example);\n    }\n  }\n\n  assessQuality(): void {\n    const result = this.result();\n    if (!result) return;\n\n    const lines = result.lines.map((l) => l.text);\n    const pattern = POETRY_FORMS[result.form].pattern;\n\n    const metrics = this.quality.assessQuality(lines, pattern, result);\n    this.qualityMetrics.set(metrics);\n  }\n\n  replaceWord(oldWord: string, newWord: string): void {\n    const result = this.result();\n    if (!result) return;\n\n    const updatedLines = result.lines.map((line) => {\n      const updatedText = line.text.replace(new RegExp(`\\\\b${oldWord}\\\\b`, 'gi'), newWord);\n      return updatedText;\n    });\n\n    this.poemText.set(updatedLines.join('\\n'));\n    this.analyze(result.form, updatedLines);\n    this.selectWordEnhanced(null);\n  }\n\n  clear(): void {\n    this.result.set(null);\n    this.selectedWord.set(null);\n    this.wordAlternatives.set(null);\n    this.qualityMetrics.set(null);\n    this.rhythmSuggestions.set([]);\n    this.poemText.set('');\n  }\n\n  private detectPatterns(lines: EnhancedLineAnalysis[]): string[] {\n    const patterns: string[] = [];\n\n    // Detectar patrones basados en el análisis real\n    const stressPatterns = lines.map((l) => l.stresses).filter((s) => s);\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent stress pattern: ${firstPattern}`);\n      }\n    }\n\n    // Detectar aliteraciones en el poema actual\n    const linesWithAlliteration = lines.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length > 0) {\n      patterns.push(\n        `${linesWithAlliteration.length} line${\n          linesWithAlliteration.length > 1 ? 's' : ''\n        } contain alliteration`\n      );\n    }\n\n    // Análisis de vocabulario del poema actual\n    const allWords = lines.flatMap((l) => l.words);\n    const nouns = allWords.filter((w) => w.pos.startsWith('nn')).length;\n    const verbs = allWords.filter((w) => w.pos.startsWith('vb')).length;\n    const adjectives = allWords.filter((w) => w.pos.startsWith('jj')).length;\n    const adverbs = allWords.filter((w) => w.pos.startsWith('rb')).length;\n\n    if (nouns > verbs * 2) {\n      patterns.push('Noun-heavy composition (descriptive style)');\n    } else if (verbs > nouns * 1.5) {\n      patterns.push('Verb-heavy composition (active style)');\n    }\n\n    if (adjectives > allWords.length * 0.2) {\n      patterns.push('High use of adjectives (vivid imagery)');\n    }\n\n    if (adverbs > allWords.length * 0.15) {\n      patterns.push('Adverb-rich language (detailed action)');\n    }\n\n    // Análisis de longitud de palabras\n    const avgWordLength =\n      allWords.reduce((sum, w) => sum + w.word.length, 0) / (allWords.length || 1);\n    if (avgWordLength > 6) {\n      patterns.push('Complex vocabulary (long words)');\n    } else if (avgWordLength < 4) {\n      patterns.push('Simple vocabulary (short words)');\n    }\n\n    return patterns;\n  }\n\n  private generateMeterPatterns(meter: MeterAnalysis): string[] {\n    const patterns: string[] = [];\n\n    if (meter.consistency > 70) {\n      patterns.push(`Strong ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    } else if (meter.consistency > 40) {\n      patterns.push(`Emerging ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    }\n\n    if (meter.type !== 'irregular') {\n      patterns.push(`Meter: ${meter.pattern}`);\n    }\n\n    return patterns;\n  }\n\n  private generateEnhancedSuggestions(\n    lineAnalyses: EnhancedLineAnalysis[],\n    pattern: number[],\n    meterAnalysis: MeterAnalysis\n  ): string[] {\n    const suggestions: string[] = [];\n\n    // Sugerencias basadas en la estructura del poema actual\n    if (lineAnalyses.length < pattern.length) {\n      const missing = pattern.length - lineAnalyses.length;\n      suggestions.push(`Add ${missing} more line${missing > 1 ? 's' : ''} to complete the pattern`);\n    } else if (lineAnalyses.length > pattern.length) {\n      const extra = lineAnalyses.length - pattern.length;\n      suggestions.push(`Remove ${extra} line${extra > 1 ? 's' : ''} to match the pattern`);\n    }\n\n    // Sugerencias rítmicas basadas en el análisis métrico\n    if (meterAnalysis.consistency < 60) {\n      suggestions.push(\n        `Improve rhythm consistency: ${meterAnalysis.type} meter detected but inconsistent`\n      );\n    }\n\n    if (meterAnalysis.type === 'irregular' && lineAnalyses.length > 2) {\n      suggestions.push('Consider using a regular meter pattern for better poetic flow');\n    }\n\n    // Sugerencias específicas por línea\n    lineAnalyses.forEach((line, index) => {\n      if (!line.match && index < pattern.length) {\n        const lineSuggestions = this.rita.generateSuggestions(line.text, pattern[index]);\n        suggestions.push(`Line ${index + 1}: ${lineSuggestions[0]}`);\n\n        const diff = pattern[index] - line.count;\n        if (diff > 0) {\n          const shortWords = line.words.filter((w) => w.syllables === 1);\n          if (shortWords.length > 0) {\n            suggestions.push(`  → Try replacing \"${shortWords[0].word}\" with a longer synonym`);\n          }\n        } else if (diff < 0) {\n          const longWords = line.words\n            .filter((w) => w.syllables > 2)\n            .sort((a, b) => b.syllables - a.syllables);\n          if (longWords.length > 0) {\n            suggestions.push(\n              `  → Try replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter word`\n            );\n          }\n        }\n      }\n    });\n\n    // Sugerencias de dispositivos literarios\n    const linesWithAlliteration = lineAnalyses.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length === 0 && lineAnalyses.length > 2) {\n      suggestions.push('Consider adding alliteration for poetic effect');\n    }\n\n    const hasRhyme = lineAnalyses.some((line) =>\n      line.words.some(\n        (word) => (word.pos && word.pos.startsWith('nn')) || word.pos.startsWith('vb')\n      )\n    );\n    if (!hasRhyme && lineAnalyses.length > 1) {\n      suggestions.push('Try incorporating rhyme for musical quality');\n    }\n\n    return suggestions.slice(0, 6);\n  }\n\n  private getPreviousWord(words: { word: string }[], currentWord: string): string | undefined {\n    const currentIndex = words.findIndex((w) => w.word.toLowerCase() === currentWord.toLowerCase());\n    return currentIndex > 0 ? words[currentIndex - 1].word : undefined;\n  }\n\n  private createResultForQualityAssessment(\n    formKey: string,\n    lineAnalyses: EnhancedLineAnalysis[]\n  ): EnhancedPoetryResult {\n    const form = POETRY_FORMS[formKey];\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n    return {\n      ok,\n      form: formKey,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      lines: lineAnalyses,\n      summary: '',\n      suggestions: [],\n      overallAlliterations: [],\n      detectedPatterns: [],\n    };\n  }\n\n  isCompletePoem(): boolean {\n    const result = this.result();\n    if (!result) return false;\n\n    return (\n      result.lines.length === result.totalLines.expected && result.lines.every((line) => line.match)\n    );\n  }\n\n  getQuickStats(): {\n    totalSyllables: number;\n    avgSyllablesPerLine: number;\n    vocabularyRichness: number;\n  } {\n    const result = this.result();\n    if (!result || result.lines.length === 0) {\n      return { totalSyllables: 0, avgSyllablesPerLine: 0, vocabularyRichness: 0 };\n    }\n\n    const totalSyllables = result.lines.reduce((sum, line) => sum + line.count, 0);\n    const avgSyllablesPerLine = totalSyllables / result.lines.length;\n\n    const allWords = result.lines.flatMap((line) => line.words.map((w) => w.word.toLowerCase()));\n    const uniqueWords = new Set(allWords);\n    const vocabularyRichness = (uniqueWords.size / allWords.length) * 100;\n\n    return {\n      totalSyllables,\n      avgSyllablesPerLine: Math.round(avgSyllablesPerLine * 10) / 10,\n      vocabularyRichness: Math.round(vocabularyRichness * 10) / 10,\n    };\n  }\n}\n",
            "properties": [
                {
                    "name": "alternatives",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "AlternativeWord[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 62
                },
                {
                    "name": "currentSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 60
                },
                {
                    "name": "original",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 59
                },
                {
                    "name": "targetSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 61
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "WordSuggestionData",
            "id": "interface-WordSuggestionData-24eb12fada130bc88b863f4d93cc015155ad8963e6b439cd89626c34ffadb8c508817746d6d4f5f7e11b910ca3bb30339b231a1a9016833254b2677222c8462e-1",
            "file": "src/app/services/poetry/poetry-suggestions.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService, type AlternativeWord } from './rita.service';\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\nexport interface SuggestionContext {\n  pos?: string;\n  lineIndex?: number;\n  isLineEnd?: boolean;\n  previousWord?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetrySuggestionsService {\n  private readonly rita = inject(RitaService);\n\n  async getWordAlternativesEnhanced(\n    word: string,\n    targetSyllables: number,\n    context: SuggestionContext = {}\n  ): Promise<WordSuggestionData> {\n    const currentSyllables = this.rita.analyzeLine(word).syllables;\n\n    // Búsqueda simple y efectiva - CORREGIR parámetros\n    const [exactMatches, rhymes, phonetic] = await Promise.all([\n      this.searchBySyllables(targetSyllables), // ❌ Eliminar context.pos\n      context.isLineEnd\n        ? this.rita.findRhymes(word, targetSyllables).then((r) => r.perfectRhymes)\n        : Promise.resolve([]),\n      this.rita.suggestAlternatives(word, targetSyllables, 6),\n    ]);\n\n    const allAlternatives = [\n      ...exactMatches,\n      ...rhymes.map((w) => ({\n        word: w, // ✅ w es string, no AlternativeWord\n        syllables: targetSyllables,\n        reason: 'rhyme-match' as const,\n        pos: this.rita.analyzeGrammar(w).pos,\n      })),\n      ...phonetic,\n    ];\n\n    const unique = this.deduplicateAndRank(allAlternatives, word, context);\n\n    return {\n      original: word,\n      currentSyllables,\n      targetSyllables,\n      alternatives: unique.slice(0, 10),\n    };\n  }\n\n  private async searchBySyllables(syllables: number): Promise<AlternativeWord[]> {\n    // ❌ Eliminar pos parameter\n    try {\n      // Búsqueda simple por primera letra y sílabas\n      const results = await this.rita.suggestAlternatives('a', syllables, 8);\n\n      // CORREGIR: results ya son AlternativeWord[], no strings\n      return results.map((altWord) => ({\n        // ✅ altWord es AlternativeWord\n        ...altWord,\n        reason: 'exact-match' as const,\n      }));\n    } catch (error) {\n      console.warn('Search by syllables failed:', error);\n      return [];\n    }\n  }\n\n  private deduplicateAndRank(\n    alternatives: AlternativeWord[],\n    originalWord: string,\n    context: SuggestionContext\n  ): AlternativeWord[] {\n    const seen = new Set<string>();\n    const unique = alternatives.filter((alt) => {\n      const key = alt.word.toLowerCase();\n      if (seen.has(key) || key === originalWord.toLowerCase()) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n\n    return unique.sort((a, b) => {\n      if (a.reason === 'exact-match' && b.reason !== 'exact-match') return -1;\n      if (b.reason === 'exact-match' && a.reason !== 'exact-match') return 1;\n\n      if (context.isLineEnd) {\n        if (a.reason === 'rhyme-match' && b.reason !== 'rhyme-match') return -1;\n        if (b.reason === 'rhyme-match' && a.reason !== 'rhyme-match') return 1;\n      }\n\n      if (context.pos) {\n        const aMatchesPOS = a.pos === context.pos;\n        const bMatchesPOS = b.pos === context.pos;\n        if (aMatchesPOS && !bMatchesPOS) return -1;\n        if (bMatchesPOS && !aMatchesPOS) return 1;\n      }\n\n      return 0;\n    });\n  }\n\n  async getWordAlternatives(word: string, targetSyllables: number): Promise<WordSuggestionData> {\n    return this.getWordAlternativesEnhanced(word, targetSyllables);\n  }\n\n  generateLineSuggestions(line: string, targetSyllables: number): string[] {\n    return this.rita.generateSuggestions(line, targetSyllables);\n  }\n}\n",
            "properties": [
                {
                    "name": "alternatives",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "AlternativeWord[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "currentSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "original",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "targetSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": [],
            "isDuplicate": true,
            "duplicateId": 1,
            "duplicateName": "WordSuggestionData-1"
        }
    ],
    "injectables": [
        {
            "name": "MeterAnalysisService",
            "id": "injectable-MeterAnalysisService-c8ff5e422e8554e34650a202a0a41732300cf56a1ad0853b3fc676499f4c2ce0c687dd9ecb78f3df657e4274fec3fdc34b0adea4b92825d6d4813ddbc9d71d07",
            "file": "src/app/services/poetry/meter-analysis.service.ts",
            "properties": [
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 25,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "classifyStressPattern",
                    "args": [
                        {
                            "name": "stresses",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "MeterType | \"irregular\"",
                    "typeParameters": [],
                    "line": 74,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "stresses",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectMeter",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "MeterAnalysis",
                    "typeParameters": [],
                    "line": 27,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateRhythmSuggestions",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetMeter",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "RhythmSuggestion[]",
                    "typeParameters": [],
                    "line": 111,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetMeter",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getIrregularMeter",
                    "args": [],
                    "optional": false,
                    "returnType": "MeterAnalysis",
                    "typeParameters": [],
                    "line": 178,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "getMeterDescription",
                    "args": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 153,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getMeterExamples",
                    "args": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 164,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getMeterPattern",
                    "args": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 142,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService } from './rita.service';\n\nexport type MeterType = 'iambic' | 'trochaic' | 'anapestic' | 'dactylic' | 'irregular';\n\nexport interface MeterAnalysis {\n  type: MeterType;\n  consistency: number;\n  pattern: string;\n  description: string;\n  examples: string[];\n}\n\nexport interface RhythmSuggestion {\n  line: number;\n  current: string;\n  issue: string;\n  suggestion: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class MeterAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  detectMeter(lines: string[]): MeterAnalysis {\n    const stressPatterns = lines\n      .map((line) => this.rita.analyzeLine(line).stresses)\n      .filter((s) => s && s.length > 0);\n\n    if (stressPatterns.length === 0) {\n      return this.getIrregularMeter();\n    }\n\n    const meterCounts = {\n      iambic: 0,\n      trochaic: 0,\n      anapestic: 0,\n      dactylic: 0,\n    };\n\n    stressPatterns.forEach((pattern) => {\n      const stresses = pattern.split('/').map((s) => parseInt(s));\n      const type = this.classifyStressPattern(stresses);\n      if (type !== 'irregular') {\n        meterCounts[type]++;\n      }\n    });\n\n    const total = stressPatterns.length;\n    const dominant = Object.entries(meterCounts).sort(([, a], [, b]) => b - a)[0];\n\n    if (!dominant) {\n      return this.getIrregularMeter();\n    }\n\n    const [type, count] = dominant as [MeterType, number];\n    const consistency = (count / total) * 100;\n\n    if (consistency < 40) {\n      return this.getIrregularMeter();\n    }\n\n    return {\n      type,\n      consistency,\n      pattern: this.getMeterPattern(type),\n      description: this.getMeterDescription(type),\n      examples: this.getMeterExamples(type),\n    };\n  }\n\n  private classifyStressPattern(stresses: number[]): MeterType | 'irregular' {\n    if (stresses.length < 2) return 'irregular';\n\n    const pairs: string[] = [];\n    for (let i = 0; i < stresses.length - 1; i++) {\n      pairs.push(`${stresses[i]}${stresses[i + 1]}`);\n    }\n\n    const pairCounts = {\n      '01': 0,\n      '10': 0,\n      '001': 0,\n      '100': 0,\n    };\n\n    pairs.forEach((pair) => {\n      if (pair === '01') pairCounts['01']++;\n      if (pair === '10') pairCounts['10']++;\n    });\n\n    for (let i = 0; i < stresses.length - 2; i++) {\n      const triplet = `${stresses[i]}${stresses[i + 1]}${stresses[i + 2]}`;\n      if (triplet === '001') pairCounts['001']++;\n      if (triplet === '100') pairCounts['100']++;\n    }\n\n    const max = Math.max(...Object.values(pairCounts));\n    if (max === 0) return 'irregular';\n\n    if (pairCounts['01'] === max) return 'iambic';\n    if (pairCounts['10'] === max) return 'trochaic';\n    if (pairCounts['001'] === max) return 'anapestic';\n    if (pairCounts['100'] === max) return 'dactylic';\n\n    return 'irregular';\n  }\n\n  generateRhythmSuggestions(lines: string[], targetMeter?: MeterType): RhythmSuggestion[] {\n    const suggestions: RhythmSuggestion[] = [];\n    const detectedMeter = this.detectMeter(lines);\n    const target = targetMeter || detectedMeter.type;\n\n    if (target === 'irregular') {\n      return suggestions;\n    }\n\n    lines.forEach((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      if (!analysis.stresses) return;\n\n      const stresses = analysis.stresses.split('/').map((s) => parseInt(s));\n      const lineType = this.classifyStressPattern(stresses);\n\n      if (lineType !== target) {\n        suggestions.push({\n          line: index + 1,\n          current: analysis.stresses,\n          issue: `This line follows a ${lineType} pattern instead of ${target}`,\n          suggestion: `Try restructuring to match the ${target} rhythm (${this.getMeterPattern(\n            target\n          )})`,\n        });\n      }\n    });\n\n    return suggestions;\n  }\n\n  private getMeterPattern(type: MeterType): string {\n    const patterns: Record<MeterType, string> = {\n      iambic: 'da-DUM (0/1)',\n      trochaic: 'DUM-da (1/0)',\n      anapestic: 'da-da-DUM (0/0/1)',\n      dactylic: 'DUM-da-da (1/0/0)',\n      irregular: 'mixed or free verse',\n    };\n    return patterns[type];\n  }\n\n  private getMeterDescription(type: MeterType): string {\n    const descriptions: Record<MeterType, string> = {\n      iambic: 'Most common in English poetry. Sounds natural and flowing.',\n      trochaic: \"Strong, emphatic rhythm. Common in children's verse.\",\n      anapestic: 'Galloping, energetic rhythm. Creates sense of movement.',\n      dactylic: 'Falling rhythm. Rare in English, common in ancient Greek.',\n      irregular: 'No consistent metrical pattern. Free verse or mixed meters.',\n    };\n    return descriptions[type];\n  }\n\n  private getMeterExamples(type: MeterType): string[] {\n    const examples: Record<MeterType, string[]> = {\n      iambic: [\n        \"Shall I compare thee to a summer's day?\",\n        'The curfew tolls the knell of parting day',\n      ],\n      trochaic: ['Tell me not in mournful numbers', 'Tiger, tiger, burning bright'],\n      anapestic: ['Twas the night before Christmas', 'And the sound of a voice that is still'],\n      dactylic: ['This is the forest primeval', 'Cannon to right of them'],\n      irregular: ['Free verse has no set pattern', 'Modern poetry often breaks rules'],\n    };\n    return examples[type];\n  }\n\n  private getIrregularMeter(): MeterAnalysis {\n    return {\n      type: 'irregular',\n      consistency: 0,\n      pattern: 'mixed or free verse',\n      description:\n        'No consistent metrical pattern detected. This could be free verse or mixed meters.',\n      examples: [],\n    };\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "PoemQualityService",
            "id": "injectable-PoemQualityService-7ce486a65750df1898e54ad355d397e9260f98fe45ae68caa60242e267f5634701e7c08a6a7f0953319376c9e4cf54f03e3ba75dc7c2cb9a7365b440b75ed93d",
            "file": "src/app/services/poetry/poem-quality.service.ts",
            "properties": [
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 24,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "assessQuality",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "QualityMetrics",
                    "typeParameters": [],
                    "line": 26,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "assignGrade",
                    "args": [
                        {
                            "name": "score",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "",
                    "typeParameters": [],
                    "line": 146,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "score",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculatePhoneticRichness",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 56,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculateRhetoricalDevices",
                    "args": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 101,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculateRhythmConsistency",
                    "args": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 86,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculateSyllableAccuracy",
                    "args": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 49,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculateVocabularyDiversity",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 73,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "computeOverallScore",
                    "args": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 132,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "countSensoryWords",
                    "args": [
                        {
                            "name": "words",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 226,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "words",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "identifyStrengths",
                    "args": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 157,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "stressSimilarity",
                    "args": [
                        {
                            "name": "pattern1",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "pattern2",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 213,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "pattern1",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "pattern2",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "suggestImprovements",
                    "args": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 185,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { RitaService } from './rita.service';\nimport type { EnhancedPoetryResult } from './poetry-analyzer.service';\n\nexport interface QualityMetrics {\n  score: number;\n  breakdown: {\n    syllableAccuracy: number;\n    phoneticsRichness: number;\n    vocabularyDiversity: number;\n    rhythmConsistency: number;\n    rhetoricalDevices: number;\n  };\n  strengths: string[];\n  improvements: string[];\n  grade: 'A+' | 'A' | 'B+' | 'B' | 'C+' | 'C' | 'D' | 'F';\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoemQualityService {\n  private readonly rita = inject(RitaService);\n\n  assessQuality(lines: string[], pattern: number[], result: EnhancedPoetryResult): QualityMetrics {\n    const metrics = {\n      syllableAccuracy: this.calculateSyllableAccuracy(result, pattern),\n      phoneticsRichness: this.calculatePhoneticRichness(lines),\n      vocabularyDiversity: this.calculateVocabularyDiversity(lines),\n      rhythmConsistency: this.calculateRhythmConsistency(result),\n      rhetoricalDevices: this.calculateRhetoricalDevices(result),\n    };\n\n    const score = this.computeOverallScore(metrics);\n    const grade = this.assignGrade(score);\n    const strengths = this.identifyStrengths(metrics);\n    const improvements = this.suggestImprovements(metrics);\n\n    return {\n      score,\n      breakdown: metrics,\n      strengths,\n      improvements,\n      grade,\n    };\n  }\n\n  private calculateSyllableAccuracy(result: EnhancedPoetryResult, pattern: number[]): number {\n    if (result.lines.length !== pattern.length) return 0;\n\n    const matches = result.lines.filter((line) => line.match).length;\n    return (matches / pattern.length) * 100;\n  }\n\n  private calculatePhoneticRichness(lines: string[]): number {\n    const text = lines.join(' ');\n    const words = RiTa.tokens(text);\n\n    if (words.length === 0) return 0;\n\n    const uniquePhonemes = new Set<string>();\n    words.forEach((word) => {\n      const phones = RiTa.phones(word);\n      if (phones) {\n        phones.split('-').forEach((p) => uniquePhonemes.add(p));\n      }\n    });\n\n    return Math.min(100, (uniquePhonemes.size / 15) * 100);\n  }\n\n  private calculateVocabularyDiversity(lines: string[]): number {\n    const text = lines.join(' ');\n    const tokens = RiTa.tokenize(text);\n    const words = tokens.filter((t) => !RiTa.isPunct(t));\n\n    if (words.length === 0) return 0;\n\n    const unique = new Set(words.map((w) => w.toLowerCase()));\n    const ttr = unique.size / words.length;\n\n    return Math.min(100, (ttr / 0.6) * 100);\n  }\n\n  private calculateRhythmConsistency(result: EnhancedPoetryResult): number {\n    const stressPatterns = result.lines\n      .map((l) => l.stresses)\n      .filter((s): s is string => s !== undefined && s.length > 0);\n\n    if (stressPatterns.length < 2) return 50;\n\n    const firstPattern = stressPatterns[0];\n    const similarCount = stressPatterns.filter(\n      (p) => this.stressSimilarity(firstPattern, p) > 0.6\n    ).length;\n\n    return (similarCount / stressPatterns.length) * 100;\n  }\n\n  private calculateRhetoricalDevices(result: EnhancedPoetryResult): number {\n    let score = 0;\n\n    if (result.overallAlliterations.length > 0) {\n      score += Math.min(20, result.overallAlliterations.length * 5);\n    }\n\n    if (result.rhymeScheme && result.rhymeScheme !== 'A'.repeat(result.lines.length)) {\n      score += 30;\n    }\n\n    const concordance = RiTa.concordance(result.lines.map((l) => l.text).join(' '));\n    const repeatedWords = Object.values(concordance).filter((count) => count > 1).length;\n    if (repeatedWords > 0) {\n      score += Math.min(20, repeatedWords * 4);\n    }\n\n    const allWords = result.lines.flatMap((l) => l.words);\n    const uniquePOS = new Set(allWords.map((w) => w.pos));\n    if (uniquePOS.size >= 4) {\n      score += 15;\n    }\n\n    const sensoryWords = this.countSensoryWords(allWords.map((w) => w.word));\n    if (sensoryWords >= 3) {\n      score += 15;\n    }\n\n    return Math.min(100, score);\n  }\n\n  private computeOverallScore(metrics: QualityMetrics['breakdown']): number {\n    const weights = {\n      syllableAccuracy: 0.35,\n      phoneticsRichness: 0.15,\n      vocabularyDiversity: 0.2,\n      rhythmConsistency: 0.15,\n      rhetoricalDevices: 0.15,\n    };\n\n    return Object.entries(weights).reduce((total, [key, weight]) => {\n      return total + metrics[key as keyof typeof metrics] * weight;\n    }, 0);\n  }\n\n  private assignGrade(score: number): QualityMetrics['grade'] {\n    if (score >= 95) return 'A+';\n    if (score >= 90) return 'A';\n    if (score >= 85) return 'B+';\n    if (score >= 80) return 'B';\n    if (score >= 75) return 'C+';\n    if (score >= 70) return 'C';\n    if (score >= 60) return 'D';\n    return 'F';\n  }\n\n  private identifyStrengths(metrics: QualityMetrics['breakdown']): string[] {\n    const strengths: string[] = [];\n\n    if (metrics.syllableAccuracy === 100) {\n      strengths.push('Perfect syllable matching');\n    } else if (metrics.syllableAccuracy >= 80) {\n      strengths.push('Good syllable accuracy');\n    }\n\n    if (metrics.phoneticsRichness > 80) {\n      strengths.push('Rich phonetic variety');\n    }\n\n    if (metrics.vocabularyDiversity > 75) {\n      strengths.push('Diverse vocabulary');\n    }\n\n    if (metrics.rhythmConsistency > 80) {\n      strengths.push('Consistent rhythm');\n    }\n\n    if (metrics.rhetoricalDevices > 70) {\n      strengths.push('Strong use of literary devices');\n    }\n\n    return strengths.length > 0 ? strengths : ['Good foundation - keep practicing!'];\n  }\n\n  private suggestImprovements(metrics: QualityMetrics['breakdown']): string[] {\n    const improvements: string[] = [];\n\n    if (metrics.syllableAccuracy < 100) {\n      improvements.push('Adjust syllable counts to match the pattern');\n    }\n\n    if (metrics.phoneticsRichness < 60) {\n      improvements.push('Use more varied sounds and phonemes');\n    }\n\n    if (metrics.vocabularyDiversity < 50) {\n      improvements.push('Avoid repeating the same words');\n    }\n\n    if (metrics.rhythmConsistency < 60) {\n      improvements.push('Create more consistent stress patterns');\n    }\n\n    if (metrics.rhetoricalDevices < 50) {\n      improvements.push('Add alliteration, rhyme, or other literary devices');\n    }\n\n    return improvements.length > 0\n      ? improvements\n      : ['Excellent work! Consider experimenting with more complex forms.'];\n  }\n\n  private stressSimilarity(pattern1: string, pattern2: string): number {\n    const arr1 = pattern1.split('/');\n    const arr2 = pattern2.split('/');\n    const maxLen = Math.max(arr1.length, arr2.length);\n\n    let matches = 0;\n    for (let i = 0; i < maxLen; i++) {\n      if (arr1[i] === arr2[i]) matches++;\n    }\n\n    return matches / maxLen;\n  }\n\n  private countSensoryWords(words: string[]): number {\n    const sensoryPatterns = [\n      /bright|dark|color|hue|shade/i,\n      /loud|quiet|sound|music|voice|echo/i,\n      /soft|hard|smooth|rough|warm|cold/i,\n      /sweet|bitter|fragrant|scent|smell/i,\n      /taste|flavor|savory|delicious/i,\n    ];\n\n    return words.filter((word) => sensoryPatterns.some((pattern) => pattern.test(word))).length;\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "PoetryAnalysisService",
            "id": "injectable-PoetryAnalysisService-87839deece079bc7847173139a67015b54b1d00fdeef757ab3e95c0a0bdf68b78cba002925ff807dfb5be309a363c259bd762ca785914d525a6a44d20747e0bd",
            "file": "src/app/services/poetry/poetry-analysis.service.ts",
            "properties": [
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "analyzePoemStructure",
                    "args": [
                        {
                            "name": "rawLines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "PoetryStructure",
                    "typeParameters": [],
                    "line": 19,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "rawLines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculateSyllableAccuracy",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 71,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectMeterPattern",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 85,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "validateLineSyllables",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "expectedSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "literal type",
                    "typeParameters": [],
                    "line": 60,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "expectedSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService } from './rita.service';\nimport { POETRY_FORMS } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface PoetryStructure {\n  lines: LineAnalysis[];\n  totalLines: { expected: number; actual: number };\n  ok: boolean;\n  summary: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  analyzePoemStructure(rawLines: string[], formKey: string): PoetryStructure {\n    const form = POETRY_FORMS[formKey];\n    if (!form) {\n      throw new Error(`Unknown form \"${formKey}\"`);\n    }\n\n    const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n    const lineAnalyses: LineAnalysis[] = lines.map((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      const expected = form.pattern[index] ?? 0;\n\n      return {\n        text: line,\n        count: analysis.syllables,\n        expected,\n        match: analysis.syllables === expected,\n        syllables: analysis.breakdown,\n        stresses: analysis.stresses,\n      };\n    });\n\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n    const mismatches = lineAnalyses.filter((l) => !l.match).length;\n    const summary = ok\n      ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n          '-'\n        )} pattern`\n      : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n    return {\n      lines: lineAnalyses,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      ok,\n      summary,\n    };\n  }\n\n  validateLineSyllables(\n    line: string,\n    expectedSyllables: number\n  ): { valid: boolean; actual: number } {\n    const analysis = this.rita.analyzeLine(line);\n    return {\n      valid: analysis.syllables === expectedSyllables,\n      actual: analysis.syllables,\n    };\n  }\n\n  calculateSyllableAccuracy(lines: string[], pattern: number[]): number {\n    if (lines.length !== pattern.length) return 0;\n\n    let matches = 0;\n    lines.forEach((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      if (analysis.syllables === pattern[index]) {\n        matches++;\n      }\n    });\n\n    return (matches / pattern.length) * 100;\n  }\n\n  detectMeterPattern(lines: string[]): string[] {\n    const patterns: string[] = [];\n    const stressPatterns = lines\n      .map((line) => {\n        const analysis = this.rita.analyzeLine(line);\n        return analysis.stresses;\n      })\n      .filter((s) => s && s.length > 0);\n\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent meter: ${firstPattern}`);\n      }\n    }\n\n    return patterns;\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "PoetryAnalyzerService",
            "id": "injectable-PoetryAnalyzerService-cc01c88b56c2eb0b88baa736de26edf66653299b14fecfbb0dc7434c68b3977c7f382c4e601296066b01dfe98a03a03a66ecf008c0598e91718873cd4c5aefdb",
            "file": "src/app/services/poetry/poetry-analyzer.service.ts",
            "properties": [
                {
                    "name": "analysis",
                    "defaultValue": "inject(PoetryAnalysisService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 69,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "isLoading",
                    "defaultValue": "signal(false)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 77,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "meterService",
                    "defaultValue": "inject(MeterAnalysisService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 74,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "patterns",
                    "defaultValue": "inject(PoetryPatternsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 71,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "poemText",
                    "defaultValue": "signal<string>('')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 83,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "quality",
                    "defaultValue": "inject(PoemQualityService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 73,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "qualityMetrics",
                    "defaultValue": "signal<QualityMetrics | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 81,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "result",
                    "defaultValue": "signal<EnhancedPoetryResult | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 78,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "rhymes",
                    "defaultValue": "inject(RhymeAnalysisService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 72,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "rhythmSuggestions",
                    "defaultValue": "signal<RhythmSuggestion[]>([])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 84,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 75,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "selectedForm",
                    "defaultValue": "signal<string>('haiku')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 82,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "selectedWord",
                    "defaultValue": "signal<string | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 79,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "suggestions",
                    "defaultValue": "inject(PoetrySuggestionsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 70,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "wordAlternatives",
                    "defaultValue": "signal<WordSuggestionData | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 80,
                    "modifierKind": [
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "analyze",
                    "args": [
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "rawLines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<EnhancedPoetryResult>",
                    "typeParameters": [],
                    "line": 86,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "rawLines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "assessQuality",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 275,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "clear",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 300,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "createResultForQualityAssessment",
                    "args": [
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "lineAnalyses",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "EnhancedPoetryResult",
                    "typeParameters": [],
                    "line": 460,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "lineAnalyses",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectPatterns",
                    "args": [
                        {
                            "name": "lines",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 309,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateEnhancedSuggestions",
                    "args": [
                        {
                            "name": "lineAnalyses",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "meterAnalysis",
                            "type": "MeterAnalysis",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 383,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "lineAnalyses",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "meterAnalysis",
                            "type": "MeterAnalysis",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateMeterPatterns",
                    "args": [
                        {
                            "name": "meter",
                            "type": "MeterAnalysis",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 367,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "meter",
                            "type": "MeterAnalysis",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getPreviousWord",
                    "args": [
                        {
                            "name": "words",
                            "type": "literal type[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "currentWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string | undefined",
                    "typeParameters": [],
                    "line": 455,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "words",
                            "type": "literal type[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "currentWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getQuickStats",
                    "args": [],
                    "optional": false,
                    "returnType": "literal type",
                    "typeParameters": [],
                    "line": 491,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "isCompletePoem",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 482,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "loadExample",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 265,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "replaceWord",
                    "args": [
                        {
                            "name": "oldWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "newWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 286,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "oldWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "newWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "selectWord",
                    "args": [
                        {
                            "name": "word",
                            "type": "string | null",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 228,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string | null",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "selectWordEnhanced",
                    "args": [
                        {
                            "name": "word",
                            "type": "string | null",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 186,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string | null",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject, signal } from '@angular/core';\nimport { PoetryAnalysisService } from './poetry-analysis.service';\nimport { PoetrySuggestionsService } from './poetry-suggestions.service';\nimport { PoetryPatternsService } from './poetry-patterns.service';\nimport { RhymeAnalysisService } from './rhyme-analysis.service';\nimport { PoemQualityService, type QualityMetrics } from './poem-quality.service';\nimport {\n  MeterAnalysisService,\n  type MeterAnalysis,\n  type RhythmSuggestion,\n} from './meter-analysis.service';\nimport {\n  RitaService,\n  type GrammaticalAnalysis,\n  type AlliterationMatch,\n  type AlternativeWord,\n} from './rita.service';\nimport { POETRY_FORMS, POETRY_EXAMPLES } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface EnhancedLineAnalysis extends LineAnalysis {\n  words: {\n    word: string;\n    syllables: number;\n    pos: string;\n    phones: string;\n    grammar?: GrammaticalAnalysis;\n  }[];\n  alliterations?: AlliterationMatch[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n}\n\nexport interface EnhancedPoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: EnhancedLineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n  overallAlliterations: AlliterationMatch[];\n  detectedPatterns: string[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n  meterAnalysis?: MeterAnalysis;\n}\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalyzerService {\n  private readonly analysis = inject(PoetryAnalysisService);\n  private readonly suggestions = inject(PoetrySuggestionsService);\n  private readonly patterns = inject(PoetryPatternsService);\n  private readonly rhymes = inject(RhymeAnalysisService);\n  private readonly quality = inject(PoemQualityService);\n  private readonly meterService = inject(MeterAnalysisService);\n  private readonly rita = inject(RitaService);\n\n  readonly isLoading = signal(false);\n  readonly result = signal<EnhancedPoetryResult | null>(null);\n  readonly selectedWord = signal<string | null>(null);\n  readonly wordAlternatives = signal<WordSuggestionData | null>(null);\n  readonly qualityMetrics = signal<QualityMetrics | null>(null);\n  readonly selectedForm = signal<string>('haiku');\n  readonly poemText = signal<string>('');\n  readonly rhythmSuggestions = signal<RhythmSuggestion[]>([]);\n\n  async analyze(formKey: string, rawLines: string[]): Promise<EnhancedPoetryResult> {\n    this.isLoading.set(true);\n\n    try {\n      const form = POETRY_FORMS[formKey];\n      if (!form) {\n        throw new Error(`Unknown form \"${formKey}\"`);\n      }\n\n      const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n      // Análisis dinámico basado en el poema actual\n      const typos = await this.rita.detectTypos(lines);\n      const meterAnalysis = this.meterService.detectMeter(lines);\n      const rhythmSuggestions = this.meterService.generateRhythmSuggestions(\n        lines,\n        meterAnalysis.type\n      );\n      this.rhythmSuggestions.set(rhythmSuggestions);\n\n      const lineAnalyses: EnhancedLineAnalysis[] = await Promise.all(\n        lines.map(async (line, index) => {\n          const analysis = this.rita.analyzeLine(line);\n          const words = this.rita.analyzeWords(line);\n          const alliterations = this.rita.detectAlliterations(line);\n          const expected = form.pattern[index] ?? 0;\n\n          const wordsWithGrammar = words.map((word) => ({\n            ...word,\n            grammar: this.rita.analyzeGrammar(word.word),\n          }));\n\n          return {\n            text: line,\n            count: analysis.syllables,\n            expected,\n            match: analysis.syllables === expected,\n            syllables: analysis.breakdown,\n            stresses: analysis.stresses,\n            words: wordsWithGrammar,\n            alliterations: alliterations.length > 0 ? alliterations : undefined,\n            typos: typos.filter((t) => t.line === index),\n          };\n        })\n      );\n\n      // Calcular calidad basada en el poema actual\n      const quality = this.quality.assessQuality(\n        lines,\n        form.pattern,\n        this.createResultForQualityAssessment(formKey, lineAnalyses)\n      );\n\n      const overallAlliterations = this.rhymes.detectCrossLineAlliterations(lines);\n      const detectedPatterns = [\n        ...this.detectPatterns(lineAnalyses),\n        ...this.generateMeterPatterns(meterAnalysis),\n      ];\n\n      const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n      const mismatches = lineAnalyses.filter((l) => !l.match).length;\n      const summary = ok\n        ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n            '-'\n          )} pattern`\n        : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n      const suggestions = this.generateEnhancedSuggestions(\n        lineAnalyses,\n        form.pattern,\n        meterAnalysis\n      );\n      const rhymeScheme = lines.length > 1 ? this.rita.analyzeRhymeScheme(lines) : undefined;\n\n      const result: EnhancedPoetryResult = {\n        ok,\n        form: formKey,\n        totalLines: {\n          expected: form.pattern.length,\n          actual: lineAnalyses.length,\n        },\n        lines: lineAnalyses,\n        summary,\n        rhymeScheme,\n        suggestions,\n        overallAlliterations,\n        detectedPatterns,\n        typos: typos.length > 0 ? typos : undefined,\n        meterAnalysis,\n      };\n\n      this.result.set(result);\n      this.qualityMetrics.set(quality);\n      return result;\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  async selectWordEnhanced(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) return;\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.suggestions.getWordAlternativesEnhanced(\n              word,\n              neededSyllables,\n              {\n                pos: wordAnalysis.pos,\n                lineIndex: result.lines.indexOf(line),\n                isLineEnd: line.words[line.words.length - 1]?.word === word,\n                previousWord: this.getPreviousWord(line.words, word),\n              }\n            );\n\n            this.wordAlternatives.set(alternatives);\n          } catch (error) {\n            console.warn('Error getting enhanced alternatives:', error);\n            await this.selectWord(word);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  async selectWord(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) {\n      return;\n    }\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.rita.suggestAlternatives(word, neededSyllables, 8);\n            this.wordAlternatives.set({\n              original: word,\n              currentSyllables: wordAnalysis.syllables,\n              targetSyllables: neededSyllables,\n              alternatives,\n            });\n          } catch (error) {\n            console.warn('Error getting word alternatives:', error);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  loadExample(): void {\n    const formId = this.selectedForm();\n    const example = POETRY_EXAMPLES[formId];\n    if (example) {\n      this.poemText.set(example.join('\\n'));\n      // Analizar automáticamente el ejemplo cargado\n      this.analyze(formId, example);\n    }\n  }\n\n  assessQuality(): void {\n    const result = this.result();\n    if (!result) return;\n\n    const lines = result.lines.map((l) => l.text);\n    const pattern = POETRY_FORMS[result.form].pattern;\n\n    const metrics = this.quality.assessQuality(lines, pattern, result);\n    this.qualityMetrics.set(metrics);\n  }\n\n  replaceWord(oldWord: string, newWord: string): void {\n    const result = this.result();\n    if (!result) return;\n\n    const updatedLines = result.lines.map((line) => {\n      const updatedText = line.text.replace(new RegExp(`\\\\b${oldWord}\\\\b`, 'gi'), newWord);\n      return updatedText;\n    });\n\n    this.poemText.set(updatedLines.join('\\n'));\n    this.analyze(result.form, updatedLines);\n    this.selectWordEnhanced(null);\n  }\n\n  clear(): void {\n    this.result.set(null);\n    this.selectedWord.set(null);\n    this.wordAlternatives.set(null);\n    this.qualityMetrics.set(null);\n    this.rhythmSuggestions.set([]);\n    this.poemText.set('');\n  }\n\n  private detectPatterns(lines: EnhancedLineAnalysis[]): string[] {\n    const patterns: string[] = [];\n\n    // Detectar patrones basados en el análisis real\n    const stressPatterns = lines.map((l) => l.stresses).filter((s) => s);\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent stress pattern: ${firstPattern}`);\n      }\n    }\n\n    // Detectar aliteraciones en el poema actual\n    const linesWithAlliteration = lines.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length > 0) {\n      patterns.push(\n        `${linesWithAlliteration.length} line${\n          linesWithAlliteration.length > 1 ? 's' : ''\n        } contain alliteration`\n      );\n    }\n\n    // Análisis de vocabulario del poema actual\n    const allWords = lines.flatMap((l) => l.words);\n    const nouns = allWords.filter((w) => w.pos.startsWith('nn')).length;\n    const verbs = allWords.filter((w) => w.pos.startsWith('vb')).length;\n    const adjectives = allWords.filter((w) => w.pos.startsWith('jj')).length;\n    const adverbs = allWords.filter((w) => w.pos.startsWith('rb')).length;\n\n    if (nouns > verbs * 2) {\n      patterns.push('Noun-heavy composition (descriptive style)');\n    } else if (verbs > nouns * 1.5) {\n      patterns.push('Verb-heavy composition (active style)');\n    }\n\n    if (adjectives > allWords.length * 0.2) {\n      patterns.push('High use of adjectives (vivid imagery)');\n    }\n\n    if (adverbs > allWords.length * 0.15) {\n      patterns.push('Adverb-rich language (detailed action)');\n    }\n\n    // Análisis de longitud de palabras\n    const avgWordLength =\n      allWords.reduce((sum, w) => sum + w.word.length, 0) / (allWords.length || 1);\n    if (avgWordLength > 6) {\n      patterns.push('Complex vocabulary (long words)');\n    } else if (avgWordLength < 4) {\n      patterns.push('Simple vocabulary (short words)');\n    }\n\n    return patterns;\n  }\n\n  private generateMeterPatterns(meter: MeterAnalysis): string[] {\n    const patterns: string[] = [];\n\n    if (meter.consistency > 70) {\n      patterns.push(`Strong ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    } else if (meter.consistency > 40) {\n      patterns.push(`Emerging ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    }\n\n    if (meter.type !== 'irregular') {\n      patterns.push(`Meter: ${meter.pattern}`);\n    }\n\n    return patterns;\n  }\n\n  private generateEnhancedSuggestions(\n    lineAnalyses: EnhancedLineAnalysis[],\n    pattern: number[],\n    meterAnalysis: MeterAnalysis\n  ): string[] {\n    const suggestions: string[] = [];\n\n    // Sugerencias basadas en la estructura del poema actual\n    if (lineAnalyses.length < pattern.length) {\n      const missing = pattern.length - lineAnalyses.length;\n      suggestions.push(`Add ${missing} more line${missing > 1 ? 's' : ''} to complete the pattern`);\n    } else if (lineAnalyses.length > pattern.length) {\n      const extra = lineAnalyses.length - pattern.length;\n      suggestions.push(`Remove ${extra} line${extra > 1 ? 's' : ''} to match the pattern`);\n    }\n\n    // Sugerencias rítmicas basadas en el análisis métrico\n    if (meterAnalysis.consistency < 60) {\n      suggestions.push(\n        `Improve rhythm consistency: ${meterAnalysis.type} meter detected but inconsistent`\n      );\n    }\n\n    if (meterAnalysis.type === 'irregular' && lineAnalyses.length > 2) {\n      suggestions.push('Consider using a regular meter pattern for better poetic flow');\n    }\n\n    // Sugerencias específicas por línea\n    lineAnalyses.forEach((line, index) => {\n      if (!line.match && index < pattern.length) {\n        const lineSuggestions = this.rita.generateSuggestions(line.text, pattern[index]);\n        suggestions.push(`Line ${index + 1}: ${lineSuggestions[0]}`);\n\n        const diff = pattern[index] - line.count;\n        if (diff > 0) {\n          const shortWords = line.words.filter((w) => w.syllables === 1);\n          if (shortWords.length > 0) {\n            suggestions.push(`  → Try replacing \"${shortWords[0].word}\" with a longer synonym`);\n          }\n        } else if (diff < 0) {\n          const longWords = line.words\n            .filter((w) => w.syllables > 2)\n            .sort((a, b) => b.syllables - a.syllables);\n          if (longWords.length > 0) {\n            suggestions.push(\n              `  → Try replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter word`\n            );\n          }\n        }\n      }\n    });\n\n    // Sugerencias de dispositivos literarios\n    const linesWithAlliteration = lineAnalyses.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length === 0 && lineAnalyses.length > 2) {\n      suggestions.push('Consider adding alliteration for poetic effect');\n    }\n\n    const hasRhyme = lineAnalyses.some((line) =>\n      line.words.some(\n        (word) => (word.pos && word.pos.startsWith('nn')) || word.pos.startsWith('vb')\n      )\n    );\n    if (!hasRhyme && lineAnalyses.length > 1) {\n      suggestions.push('Try incorporating rhyme for musical quality');\n    }\n\n    return suggestions.slice(0, 6);\n  }\n\n  private getPreviousWord(words: { word: string }[], currentWord: string): string | undefined {\n    const currentIndex = words.findIndex((w) => w.word.toLowerCase() === currentWord.toLowerCase());\n    return currentIndex > 0 ? words[currentIndex - 1].word : undefined;\n  }\n\n  private createResultForQualityAssessment(\n    formKey: string,\n    lineAnalyses: EnhancedLineAnalysis[]\n  ): EnhancedPoetryResult {\n    const form = POETRY_FORMS[formKey];\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n    return {\n      ok,\n      form: formKey,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      lines: lineAnalyses,\n      summary: '',\n      suggestions: [],\n      overallAlliterations: [],\n      detectedPatterns: [],\n    };\n  }\n\n  isCompletePoem(): boolean {\n    const result = this.result();\n    if (!result) return false;\n\n    return (\n      result.lines.length === result.totalLines.expected && result.lines.every((line) => line.match)\n    );\n  }\n\n  getQuickStats(): {\n    totalSyllables: number;\n    avgSyllablesPerLine: number;\n    vocabularyRichness: number;\n  } {\n    const result = this.result();\n    if (!result || result.lines.length === 0) {\n      return { totalSyllables: 0, avgSyllablesPerLine: 0, vocabularyRichness: 0 };\n    }\n\n    const totalSyllables = result.lines.reduce((sum, line) => sum + line.count, 0);\n    const avgSyllablesPerLine = totalSyllables / result.lines.length;\n\n    const allWords = result.lines.flatMap((line) => line.words.map((w) => w.word.toLowerCase()));\n    const uniqueWords = new Set(allWords);\n    const vocabularyRichness = (uniqueWords.size / allWords.length) * 100;\n\n    return {\n      totalSyllables,\n      avgSyllablesPerLine: Math.round(avgSyllablesPerLine * 10) / 10,\n      vocabularyRichness: Math.round(vocabularyRichness * 10) / 10,\n    };\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "PoetryPatternsService",
            "id": "injectable-PoetryPatternsService-80b0cf2d8c512fa3d287dcf6c2c96e860136e9c66d1f6e82cb0d45daeff632996b97a6abb3d5c058c7715e20051557c5974bec052e4c26a8d90bee1cedbfa98b",
            "file": "src/app/services/poetry/poetry-patterns.service.ts",
            "properties": [
                {
                    "name": "forms",
                    "defaultValue": "POETRY_FORMS",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "detectPossibleForms",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 27,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getAllForms",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 18,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getFormInfo",
                    "args": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 14,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getFormOptions",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 40,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getFormPattern",
                    "args": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number[]",
                    "typeParameters": [],
                    "line": 10,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "validateFormCompatibility",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 22,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable } from '@angular/core';\nimport { POETRY_FORMS } from '../../data/poetry-forms.data';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryPatternsService {\n  private readonly forms = POETRY_FORMS;\n\n  getFormPattern(formId: string): number[] {\n    return this.forms[formId]?.pattern || [];\n  }\n\n  getFormInfo(formId: string) {\n    return this.forms[formId];\n  }\n\n  getAllForms() {\n    return Object.values(this.forms);\n  }\n\n  validateFormCompatibility(lines: string[], formId: string): boolean {\n    const pattern = this.getFormPattern(formId);\n    return lines.length === pattern.length;\n  }\n\n  detectPossibleForms(lines: string[]): string[] {\n    const possibleForms: string[] = [];\n    const lineCount = lines.length;\n\n    Object.entries(this.forms).forEach(([formId, form]) => {\n      if (form.lines === lineCount) {\n        possibleForms.push(formId);\n      }\n    });\n\n    return possibleForms;\n  }\n\n  getFormOptions() {\n    return Object.values(this.forms).map((form) => ({\n      value: form.id,\n      label: form.name,\n      description: form.pattern.join('-'),\n    }));\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "PoetrySuggestionsService",
            "id": "injectable-PoetrySuggestionsService-24eb12fada130bc88b863f4d93cc015155ad8963e6b439cd89626c34ffadb8c508817746d6d4f5f7e11b910ca3bb30339b231a1a9016833254b2677222c8462e",
            "file": "src/app/services/poetry/poetry-suggestions.service.ts",
            "properties": [
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "deduplicateAndRank",
                    "args": [
                        {
                            "name": "alternatives",
                            "type": "AlternativeWord[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "originalWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "context",
                            "type": "SuggestionContext",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "AlternativeWord[]",
                    "typeParameters": [],
                    "line": 79,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "alternatives",
                            "type": "AlternativeWord[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "originalWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "context",
                            "type": "SuggestionContext",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateLineSuggestions",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 118,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getWordAlternatives",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<WordSuggestionData>",
                    "typeParameters": [],
                    "line": 114,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getWordAlternativesEnhanced",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "context",
                            "type": "SuggestionContext",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "{}"
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<WordSuggestionData>",
                    "typeParameters": [],
                    "line": 24,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "context",
                            "type": "SuggestionContext",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "{}",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "searchBySyllables",
                    "args": [
                        {
                            "name": "syllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<AlternativeWord[]>",
                    "typeParameters": [],
                    "line": 61,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "syllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService, type AlternativeWord } from './rita.service';\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\nexport interface SuggestionContext {\n  pos?: string;\n  lineIndex?: number;\n  isLineEnd?: boolean;\n  previousWord?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetrySuggestionsService {\n  private readonly rita = inject(RitaService);\n\n  async getWordAlternativesEnhanced(\n    word: string,\n    targetSyllables: number,\n    context: SuggestionContext = {}\n  ): Promise<WordSuggestionData> {\n    const currentSyllables = this.rita.analyzeLine(word).syllables;\n\n    // Búsqueda simple y efectiva - CORREGIR parámetros\n    const [exactMatches, rhymes, phonetic] = await Promise.all([\n      this.searchBySyllables(targetSyllables), // ❌ Eliminar context.pos\n      context.isLineEnd\n        ? this.rita.findRhymes(word, targetSyllables).then((r) => r.perfectRhymes)\n        : Promise.resolve([]),\n      this.rita.suggestAlternatives(word, targetSyllables, 6),\n    ]);\n\n    const allAlternatives = [\n      ...exactMatches,\n      ...rhymes.map((w) => ({\n        word: w, // ✅ w es string, no AlternativeWord\n        syllables: targetSyllables,\n        reason: 'rhyme-match' as const,\n        pos: this.rita.analyzeGrammar(w).pos,\n      })),\n      ...phonetic,\n    ];\n\n    const unique = this.deduplicateAndRank(allAlternatives, word, context);\n\n    return {\n      original: word,\n      currentSyllables,\n      targetSyllables,\n      alternatives: unique.slice(0, 10),\n    };\n  }\n\n  private async searchBySyllables(syllables: number): Promise<AlternativeWord[]> {\n    // ❌ Eliminar pos parameter\n    try {\n      // Búsqueda simple por primera letra y sílabas\n      const results = await this.rita.suggestAlternatives('a', syllables, 8);\n\n      // CORREGIR: results ya son AlternativeWord[], no strings\n      return results.map((altWord) => ({\n        // ✅ altWord es AlternativeWord\n        ...altWord,\n        reason: 'exact-match' as const,\n      }));\n    } catch (error) {\n      console.warn('Search by syllables failed:', error);\n      return [];\n    }\n  }\n\n  private deduplicateAndRank(\n    alternatives: AlternativeWord[],\n    originalWord: string,\n    context: SuggestionContext\n  ): AlternativeWord[] {\n    const seen = new Set<string>();\n    const unique = alternatives.filter((alt) => {\n      const key = alt.word.toLowerCase();\n      if (seen.has(key) || key === originalWord.toLowerCase()) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n\n    return unique.sort((a, b) => {\n      if (a.reason === 'exact-match' && b.reason !== 'exact-match') return -1;\n      if (b.reason === 'exact-match' && a.reason !== 'exact-match') return 1;\n\n      if (context.isLineEnd) {\n        if (a.reason === 'rhyme-match' && b.reason !== 'rhyme-match') return -1;\n        if (b.reason === 'rhyme-match' && a.reason !== 'rhyme-match') return 1;\n      }\n\n      if (context.pos) {\n        const aMatchesPOS = a.pos === context.pos;\n        const bMatchesPOS = b.pos === context.pos;\n        if (aMatchesPOS && !bMatchesPOS) return -1;\n        if (bMatchesPOS && !aMatchesPOS) return 1;\n      }\n\n      return 0;\n    });\n  }\n\n  async getWordAlternatives(word: string, targetSyllables: number): Promise<WordSuggestionData> {\n    return this.getWordAlternativesEnhanced(word, targetSyllables);\n  }\n\n  generateLineSuggestions(line: string, targetSyllables: number): string[] {\n    return this.rita.generateSuggestions(line, targetSyllables);\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "RhymeAnalysisService",
            "id": "injectable-RhymeAnalysisService-41d23a934805c1e0266376535441a4f68f9177e738b5b3e6b11525f00a5d9a79108b602cc51de2ccb1b0f714769ed493952a29943cf3d4829715050ceb17ced6",
            "file": "src/app/services/poetry/rhyme-analysis.service.ts",
            "properties": [
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "analyzeRhymeScheme",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 10,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectCrossLineAlliterations",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "AlliterationMatch[]",
                    "typeParameters": [],
                    "line": 14,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectRhymePattern",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "literal type",
                    "typeParameters": [],
                    "line": 58,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService, type AlliterationMatch } from './rita.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RhymeAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  analyzeRhymeScheme(lines: string[]): string {\n    return this.rita.analyzeRhymeScheme(lines);\n  }\n\n  detectCrossLineAlliterations(lines: string[]): AlliterationMatch[] {\n    const allWords: { word: string; lineIndex: number; wordIndex: number }[] = [];\n\n    lines.forEach((line, lineIndex) => {\n      const words = line.split(/\\s+/).filter((w) => /[a-zA-Z]/.test(w));\n      words.forEach((word, wordIndex) => {\n        allWords.push({ word, lineIndex, wordIndex });\n      });\n    });\n\n    const crossLineAlliterations: AlliterationMatch[] = [];\n    const processed = new Set<number>();\n\n    for (let i = 0; i < allWords.length - 1; i++) {\n      if (processed.has(i)) continue;\n\n      const matchingWords: string[] = [allWords[i].word];\n      const positions: number[] = [i];\n\n      for (let j = i + 1; j < allWords.length && j < i + 10; j++) {\n        try {\n          if (this.rita.isRhyme(allWords[i].word, allWords[j].word)) {\n            matchingWords.push(allWords[j].word);\n            positions.push(j);\n            processed.add(j);\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      if (matchingWords.length > 2) {\n        crossLineAlliterations.push({\n          words: matchingWords,\n          positions,\n          sound: matchingWords[0][0],\n        });\n        processed.add(i);\n      }\n    }\n\n    return crossLineAlliterations;\n  }\n\n  detectRhymePattern(lines: string[]): { scheme: string; consistency: number } {\n    const scheme = this.analyzeRhymeScheme(lines);\n    const uniqueRhymes = new Set(scheme.split(''));\n    const consistency = uniqueRhymes.size / scheme.length;\n\n    return { scheme, consistency };\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "RitaService",
            "id": "injectable-RitaService-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "properties": [
                {
                    "name": "cache",
                    "defaultValue": "new Map<string, SyllableAnalysis>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 73,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "utils",
                    "defaultValue": "inject(UtilsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 74,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "analyzeGrammar",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "GrammaticalAnalysis",
                    "typeParameters": [],
                    "line": 397,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "analyzeLine",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "SyllableAnalysis",
                    "typeParameters": [],
                    "line": 76,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "analyzeRhymeScheme",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 329,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "analyzeWords",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "WordAnalysis[]",
                    "typeParameters": [],
                    "line": 126,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "clearCache",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 466,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "detectAlliterations",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "AlliterationMatch[]",
                    "typeParameters": [],
                    "line": 238,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectTypos",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<literal type[]>",
                    "typeParameters": [],
                    "line": 427,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "findRhymes",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<RhymeMatch>",
                    "typeParameters": [],
                    "line": 274,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateSuggestions",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 356,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getLastWord",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 461,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isRhyme",
                    "args": [
                        {
                            "name": "word1",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "word2",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 321,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "word1",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "word2",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "suggestAlternatives",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "maxResults",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "10"
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<AlternativeWord[]>",
                    "typeParameters": [],
                    "line": 146,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "maxResults",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "10",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "ThemeService",
            "id": "injectable-ThemeService-eb0a14693c99d5a747e1b15c8801151fe40229ec9c63b60b26b5aaae24252d941375e426f3836e3816b01f27e79a6fead9ac2666a47f86b491549df40bb3a721",
            "file": "src/app/services/core/theme.service.ts",
            "properties": [
                {
                    "name": "currentTheme",
                    "defaultValue": "signal<Theme>(this.getInitialTheme())",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 11,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "THEME_KEY",
                    "defaultValue": "'app-theme'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 9,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "applyTheme",
                    "args": [
                        {
                            "name": "theme",
                            "type": "Theme",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 32,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "theme",
                            "type": "Theme",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getInitialTheme",
                    "args": [],
                    "optional": false,
                    "returnType": "Theme",
                    "typeParameters": [],
                    "line": 19,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "setTheme",
                    "args": [
                        {
                            "name": "theme",
                            "type": "Theme",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 41,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "theme",
                            "type": "Theme",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "toggleTheme",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 37,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, signal, effect } from '@angular/core';\n\nexport type Theme = 'light' | 'dark';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class ThemeService {\n  private readonly THEME_KEY = 'app-theme';\n\n  readonly currentTheme = signal<Theme>(this.getInitialTheme());\n\n  constructor() {\n    effect(() => {\n      this.applyTheme(this.currentTheme());\n    });\n  }\n\n  private getInitialTheme(): Theme {\n    const stored = localStorage.getItem(this.THEME_KEY) as Theme | null;\n    if (stored === 'light' || stored === 'dark') {\n      return stored;\n    }\n\n    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {\n      return 'dark';\n    }\n\n    return 'light';\n  }\n\n  private applyTheme(theme: Theme): void {\n    document.documentElement.setAttribute('data-theme', theme);\n    localStorage.setItem(this.THEME_KEY, theme);\n  }\n\n  toggleTheme(): void {\n    this.currentTheme.update((current) => (current === 'light' ? 'dark' : 'light'));\n  }\n\n  setTheme(theme: Theme): void {\n    this.currentTheme.set(theme);\n  }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 11
            },
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "ToastService",
            "id": "injectable-ToastService-205f8fc4fe55ff61e7a3cf41dd3a9d73f11125462cf7913be0245820b502a81c21aa52c8693e3125c6a9cacd729836a9ad71c7771ba8cb8c9178a57c63c1e422",
            "file": "src/app/services/core/toast.service.ts",
            "properties": [
                {
                    "name": "toasts",
                    "defaultValue": "signal<Toast[]>([])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 14,
                    "modifierKind": [
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "error",
                    "args": [
                        {
                            "name": "title",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 35,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "title",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "info",
                    "args": [
                        {
                            "name": "title",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 39,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "title",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "remove",
                    "args": [
                        {
                            "name": "id",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 27,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "show",
                    "args": [
                        {
                            "name": "toast",
                            "type": "Omit<Toast | id>",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 16,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "toast",
                            "type": "Omit<Toast | id>",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "success",
                    "args": [
                        {
                            "name": "title",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 31,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "title",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "warning",
                    "args": [
                        {
                            "name": "title",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 43,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "title",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "duration",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, signal } from '@angular/core';\n\nexport interface Toast {\n  id: string;\n  title: string;\n  message?: string;\n  type: 'info' | 'success' | 'warning' | 'error';\n  duration?: number;\n}\n\n@Injectable({ providedIn: 'root' })\nexport class ToastService {\n  readonly toasts = signal<Toast[]>([]);\n\n  show(toast: Omit<Toast, 'id'>): void {\n    const id = crypto.randomUUID();\n    const duration = toast.duration ?? 3000;\n\n    this.toasts.update((toasts) => [...toasts, { ...toast, id }]);\n\n    if (duration > 0) {\n      setTimeout(() => this.remove(id), duration);\n    }\n  }\n\n  remove(id: string): void {\n    this.toasts.update((toasts) => toasts.filter((t) => t.id !== id));\n  }\n\n  success(title: string, message?: string, duration?: number): void {\n    this.show({ title, message, type: 'success', duration });\n  }\n\n  error(title: string, message?: string, duration?: number): void {\n    this.show({ title, message, type: 'error', duration });\n  }\n\n  info(title: string, message?: string, duration?: number): void {\n    this.show({ title, message, type: 'info', duration });\n  }\n\n  warning(title: string, message?: string, duration?: number): void {\n    this.show({ title, message, type: 'warning', duration });\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "UtilsService",
            "id": "injectable-UtilsService-681d428fc9fe44e56308b4d6ad7183dc70ebae14a79607632f27185b4ab1fc6734639772c01886b67f3b1cfac558e1f29153235dffac59872bc233a3f91ee762",
            "file": "src/app/services/core/utils.service.ts",
            "properties": [
                {
                    "name": "posLabels",
                    "defaultValue": "{\n    // Nouns\n    nn: 'noun',\n    nns: 'noun (plural)',\n    nnp: 'proper noun',\n    nnps: 'proper noun (plural)',\n\n    // Verbs\n    vb: 'verb',\n    vbd: 'verb (past)',\n    vbg: 'verb (gerund)',\n    vbn: 'verb (past participle)',\n    vbp: 'verb (present)',\n    vbz: 'verb (3rd person)',\n\n    // Adjectives\n    jj: 'adjective',\n    jjr: 'adjective (comparative)',\n    jjs: 'adjective (superlative)',\n\n    // Adverbs\n    rb: 'adverb',\n    rbr: 'adverb (comparative)',\n    rbs: 'adverb (superlative)',\n\n    // Determiners\n    dt: 'determiner',\n    wdt: 'wh-determiner',\n    pdt: 'predeterminer',\n\n    // Prepositions\n    in: 'preposition',\n\n    // Conjunctions\n    cc: 'conjunction',\n\n    // Pronouns\n    prp: 'pronoun',\n    prp$: 'possessive pronoun',\n    wp: 'wh-pronoun',\n    wp$: 'possessive wh-pronoun',\n\n    // Interjections\n    uh: 'interjection',\n\n    // Particles\n    rp: 'particle',\n\n    // Other\n    cd: 'cardinal number',\n    ex: 'existential there',\n    fw: 'foreign word',\n    ls: 'list marker',\n    md: 'modal',\n    pos: 'possessive ending',\n    sym: 'symbol',\n    to: 'to',\n    punc: 'punctuation',\n  }",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Record<string | string>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "getAllPosLabels",
                    "args": [],
                    "optional": false,
                    "returnType": "Record<string, string>",
                    "typeParameters": [],
                    "line": 71,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getPosLabel",
                    "args": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 67,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class UtilsService {\n  private readonly posLabels: Record<string, string> = {\n    // Nouns\n    nn: 'noun',\n    nns: 'noun (plural)',\n    nnp: 'proper noun',\n    nnps: 'proper noun (plural)',\n\n    // Verbs\n    vb: 'verb',\n    vbd: 'verb (past)',\n    vbg: 'verb (gerund)',\n    vbn: 'verb (past participle)',\n    vbp: 'verb (present)',\n    vbz: 'verb (3rd person)',\n\n    // Adjectives\n    jj: 'adjective',\n    jjr: 'adjective (comparative)',\n    jjs: 'adjective (superlative)',\n\n    // Adverbs\n    rb: 'adverb',\n    rbr: 'adverb (comparative)',\n    rbs: 'adverb (superlative)',\n\n    // Determiners\n    dt: 'determiner',\n    wdt: 'wh-determiner',\n    pdt: 'predeterminer',\n\n    // Prepositions\n    in: 'preposition',\n\n    // Conjunctions\n    cc: 'conjunction',\n\n    // Pronouns\n    prp: 'pronoun',\n    prp$: 'possessive pronoun',\n    wp: 'wh-pronoun',\n    wp$: 'possessive wh-pronoun',\n\n    // Interjections\n    uh: 'interjection',\n\n    // Particles\n    rp: 'particle',\n\n    // Other\n    cd: 'cardinal number',\n    ex: 'existential there',\n    fw: 'foreign word',\n    ls: 'list marker',\n    md: 'modal',\n    pos: 'possessive ending',\n    sym: 'symbol',\n    to: 'to',\n    punc: 'punctuation',\n  };\n\n  getPosLabel(pos: string): string {\n    return this.posLabels[pos.toLowerCase()] || pos;\n  }\n\n  getAllPosLabels(): Record<string, string> {\n    return { ...this.posLabels };\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        }
    ],
    "guards": [],
    "interceptors": [],
    "classes": [],
    "directives": [],
    "components": [
        {
            "name": "AccordionComponent",
            "id": "component-AccordionComponent-445bbb3611363790961e8dd46d8670559cb580dfa625ff8e5753fdfd74d4a0dd0733a38ffb833669a2075dc10f754f5d434e8a5cbd9f810ff3d873dcad6e5bf0",
            "file": "src/app/components/ui/accordion/accordion.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-accordion",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./accordion.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "expanded",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 10,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 11,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "title",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 9,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "toggle",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 13,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-accordion',\n  standalone: true,\n  templateUrl: './accordion.component.html',\n})\nexport class AccordionComponent {\n  @Input() title = '';\n  @Input() expanded = false;\n  @Input() icon?: string;\n\n  toggle(): void {\n    this.expanded = !this.expanded;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<div class=\"metro-accordion\">\n  <button\n    type=\"button\"\n    class=\"metro-accordion-header\"\n    (click)=\"toggle()\"\n    [attr.aria-expanded]=\"expanded\"\n  >\n    <div class=\"accordion-title-section\">\n      @if (icon) {\n        <span [class]=\"icon + ' accordion-icon'\"></span>\n      }\n      <span class=\"accordion-title\">{{ title }}</span>\n    </div>\n    \n    @if (expanded) {\n      <span class=\"icon-[iconoir--nav-arrow-up] accordion-chevron\"></span>\n    } @else {\n      <span class=\"icon-[iconoir--nav-arrow-down] accordion-chevron\"></span>\n    }\n  </button>\n  \n  @if (expanded) {\n    <div class=\"metro-accordion-content\">\n      <ng-content />\n    </div>\n  }\n</div>"
        },
        {
            "name": "AnalysisPanelComponent",
            "id": "component-AnalysisPanelComponent-2b245ee2f221fd7660980b99bb7705281f89720740969f8b6fd377319e7ad0ee82c03f5c08db2e9dc1956112fb67663e8a4208df091cf46939a3b11e7b5197c9",
            "file": "src/app/components/ui/analysis-panel/analysis-panel.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-analysis-panel",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./analysis-panel.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "compact",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 21,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "metrics",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 20,
                    "type": "AnalysisMetric[]",
                    "decorators": []
                },
                {
                    "name": "title",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 19,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "getMetricVariant",
                    "args": [
                        {
                            "name": "metric",
                            "type": "AnalysisMetric",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 23,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "metric",
                            "type": "AnalysisMetric",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getProgressWidth",
                    "args": [
                        {
                            "name": "metric",
                            "type": "AnalysisMetric",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 27,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "metric",
                            "type": "AnalysisMetric",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CardComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CardComponent } from '../card/card.component';\n\nexport interface AnalysisMetric {\n  label: string;\n  value: number | string;\n  maxValue?: number;\n  variant?: 'default' | 'success' | 'warning' | 'error';\n  icon?: string;\n}\n\n@Component({\n  selector: 'app-analysis-panel',\n  standalone: true,\n  imports: [CardComponent],\n  templateUrl: './analysis-panel.component.html',\n})\nexport class AnalysisPanelComponent {\n  @Input() title = '';\n  @Input() metrics: AnalysisMetric[] = [];\n  @Input() compact = false;\n\n  getMetricVariant(metric: AnalysisMetric): string {\n    return `metric-${metric.variant || 'default'}`;\n  }\n\n  getProgressWidth(metric: AnalysisMetric): string {\n    if (metric.maxValue && typeof metric.value === 'number') {\n      const percentage = (metric.value / metric.maxValue) * 100;\n      return `${Math.min(percentage, 100)}%`;\n    }\n    return '0%';\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card [padding]=\"compact ? 'small' : 'medium'\">\n  <div class=\"analysis-panel\">\n    <h3 class=\"panel-title\">{{ title }}</h3>\n    \n    <div class=\"metrics-grid\">\n      @for (metric of metrics; track metric.label) {\n        <div class=\"metric-item\">\n          <div class=\"metric-header\">\n            @if (metric.icon) {\n              <span [class]=\"metric.icon + ' metric-icon'\"></span>\n            }\n            <span class=\"metric-label\">{{ metric.label }}</span>\n            <span class=\"metric-value\">{{ metric.value }}</span>\n          </div>\n          \n          @if (metric.maxValue && typeof metric.value === 'number') {\n            <div class=\"metric-progress\">\n              <div \n                class=\"metric-progress-bar\"\n                [class]=\"getMetricVariant(metric)\"\n                [style.width]=\"getProgressWidth(metric)\"\n              ></div>\n            </div>\n          }\n        </div>\n      }\n    </div>\n  </div>\n</app-card>"
        },
        {
            "name": "App",
            "id": "component-App-20af9a21b33d0f482f24984a71a25adb75f37272056bf0109d26364070250341c83a150af55555c98b471690af1ee56c2ec7394918ae0036551341060cfe3fe9",
            "file": "src/app/app.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-root",
            "styleUrls": [],
            "styles": [],
            "template": "<app-toast-container />\n<app-poetry-page />\n",
            "templateUrl": [],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "PoetryPageComponent",
                    "type": "component"
                },
                {
                    "name": "ToastContainerComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component } from '@angular/core';\nimport { PoetryPageComponent } from './components/layout/poetry-page/poetry-page.component';\nimport { ToastContainerComponent } from './components/metro/toast-container/toast-container.component';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [PoetryPageComponent, ToastContainerComponent],\n  template: `\n    <app-toast-container />\n    <app-poetry-page />\n  `,\n})\nexport class App {}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": []
        },
        {
            "name": "AppBarComponent",
            "id": "component-AppBarComponent-e2b9c1c22b3661e41ffb4d97c5f3f2661396ff2f7a1d5f44a0fb7f0d1c26a8dffab14706f2858074a38dc4a9387a9f50a316802752f408c20e23b8e8daa58fe2",
            "file": "src/app/components/metro/appbar/appbar.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-appbar",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./appbar.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "actions",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 19,
                    "type": "AppBarAction[]",
                    "decorators": []
                },
                {
                    "name": "hidden",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 20,
                    "type": "boolean",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "actionClick",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 21,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "onActionClick",
                    "args": [
                        {
                            "name": "actionId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "disabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 23,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "actionId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "disabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nexport interface AppBarAction {\n  id: string;\n  icon: string;\n  label: string;\n  disabled?: boolean;\n}\n\n@Component({\n  selector: 'app-appbar',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './appbar.component.html',\n})\nexport class AppBarComponent {\n  @Input() actions: AppBarAction[] = [];\n  @Input() hidden = false;\n  @Output() actionClick = new EventEmitter<string>();\n\n  onActionClick(actionId: string, disabled?: boolean): void {\n    if (!disabled) {\n      this.actionClick.emit(actionId);\n    }\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<!-- appbar.component.html -->\n<div \n  class=\"metro-appbar\"\n  [class.appbar-hidden]=\"hidden\"\n>\n  <div class=\"appbar-start\">\n    <ng-content select=\"[slot='start']\" />\n  </div>\n\n  <div class=\"appbar-center\">\n    @for (action of actions; track action.id) {\n      <button\n        type=\"button\"\n        class=\"metro-command-button\"\n        [disabled]=\"action.disabled\"\n        (click)=\"onActionClick(action.id, action.disabled)\"\n      >\n        <span [class]=\"action.icon + ' command-icon'\"></span>\n        <span class=\"command-label\">{{ action.label }}</span>\n      </button>\n    }\n  </div>\n\n  <div class=\"appbar-end\">\n    <ng-content select=\"[slot='end']\" />\n  </div>\n</div>"
        },
        {
            "name": "BadgeComponent",
            "id": "component-BadgeComponent-f2f34ee1e09d2a39b10636d8b030818597c54c5c0d1370aa3a3f018e4c561f2bae574245bedc1f7752007b5a38cb4a15815ce0cd399de85b75db1defffc2a5fc",
            "file": "src/app/components/ui/badge/badge.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-badge",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./badge.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 11,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "size",
                    "defaultValue": "'medium'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 10,
                    "type": "\"small\" | \"medium\"",
                    "decorators": []
                },
                {
                    "name": "variant",
                    "defaultValue": "'default'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 9,
                    "type": "\"default\" | \"info\" | \"success\" | \"warning\" | \"error\"",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-badge',\n  standalone: true,\n  templateUrl: './badge.component.html',\n})\nexport class BadgeComponent {\n  @Input() variant: 'default' | 'info' | 'success' | 'warning' | 'error' = 'default';\n  @Input() size: 'small' | 'medium' = 'medium';\n  @Input() icon?: string;\n\n  get badgeClasses(): string {\n    return `badge-${this.variant} badge-${this.size}`;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "accessors": {
                "badgeClasses": {
                    "name": "badgeClasses",
                    "getSignature": {
                        "name": "badgeClasses",
                        "type": "string",
                        "returnType": "string",
                        "line": 13
                    }
                }
            },
            "templateData": "<span [class]=\"badgeClasses\">\n  @if (icon) {\n    <span [class]=\"icon\"></span>\n  }\n  <ng-content />\n</span>"
        },
        {
            "name": "ButtonComponent",
            "id": "component-ButtonComponent-1038697c02f5d2e6b3d474c47190ad32dada1bff889730491450094713a066cbef2b7929a59f5cca48c6bfd43a917cfef4bc2a36ce5fbf78ee21df4e4ad225e8",
            "file": "src/app/components/ui/button/button.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-button",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./button.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "disabled",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 13,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 12,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "label",
                    "defaultValue": "'Button'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 11,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "size",
                    "defaultValue": "'medium'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 10,
                    "type": "\"small\" | \"medium\" | \"large\"",
                    "decorators": []
                },
                {
                    "name": "variant",
                    "defaultValue": "'primary'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 9,
                    "type": "\"primary\" | \"secondary\" | \"outline\"",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "clicked",
                    "defaultValue": "new EventEmitter<Event>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 14,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'app-button',\n  standalone: true,\n  templateUrl: './button.component.html',\n})\nexport class ButtonComponent {\n  @Input() variant: 'primary' | 'secondary' | 'outline' = 'primary';\n  @Input() size: 'small' | 'medium' | 'large' = 'medium';\n  @Input() label = 'Button';\n  @Input() icon?: string;\n  @Input() disabled = false;\n  @Output() clicked = new EventEmitter<Event>();\n\n  get buttonClasses(): string {\n    const sizeClasses = {\n      small: 'btn-small',\n      medium: 'btn-medium',\n      large: 'btn-large',\n    };\n\n    const variantClasses = {\n      primary: 'btn-primary',\n      secondary: 'btn-secondary',\n      outline: 'btn-outline',\n    };\n\n    return `btn-base ${sizeClasses[this.size]} ${variantClasses[this.variant]}`;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "accessors": {
                "buttonClasses": {
                    "name": "buttonClasses",
                    "getSignature": {
                        "name": "buttonClasses",
                        "type": "string",
                        "returnType": "string",
                        "line": 16
                    }
                }
            },
            "templateData": "<button\n  type=\"button\"\n  (click)=\"!disabled && clicked.emit($event)\"\n  [class]=\"buttonClasses\"\n  [disabled]=\"disabled\"\n>\n  @if (icon) {\n    <span [class]=\"icon\"></span>\n  }\n  {{ label }}\n</button>\n"
        },
        {
            "name": "CardComponent",
            "id": "component-CardComponent-27824ee1b72b2fa55dedcdc921e8fbb3d83c9866b34f3a4887eb045a87e9a633c5ed5fe1867da44c85f54ed02cba5ff890694de7c9ff6bf05ea6789502cce200",
            "file": "src/app/components/ui/card/card.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-card",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./card.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "clickable",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 11,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "padding",
                    "defaultValue": "'medium'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 10,
                    "type": "\"none\" | \"small\" | \"medium\" | \"large\"",
                    "decorators": []
                },
                {
                    "name": "variant",
                    "defaultValue": "'default'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 9,
                    "type": "\"default\" | \"elevated\"",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-card',\n  standalone: true,\n  templateUrl: './card.component.html',\n})\nexport class CardComponent {\n  @Input() variant: 'default' | 'elevated' = 'default';\n  @Input() padding: 'none' | 'small' | 'medium' | 'large' = 'medium';\n  @Input() clickable = false;\n\n  get cardClasses(): string {\n    const classes = [`card-${this.variant}`, `card-padding-${this.padding}`];\n\n    if (this.clickable) {\n      classes.push('clickable');\n    }\n\n    return classes.join(' ');\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "accessors": {
                "cardClasses": {
                    "name": "cardClasses",
                    "getSignature": {
                        "name": "cardClasses",
                        "type": "string",
                        "returnType": "string",
                        "line": 13
                    }
                }
            },
            "templateData": "<div \n  [class]=\"cardClasses\"\n  [class.clickable]=\"clickable\"\n>\n  <ng-content />\n</div>"
        },
        {
            "name": "FooterComponent",
            "id": "component-FooterComponent-dc904eb9c0678816656fae0614782af9663c3fe8dab871a7522e3bf9ea5dc38ca0e0c74934b46765be5a81ee1fc31a41093d7af807c7e22caeb09fcd7a7900e1",
            "file": "src/app/components/layout/footer/footer.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-footer",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./footer.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "currentYear",
                    "defaultValue": "new Date().getFullYear()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 9
                }
            ],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-footer',\n  standalone: true,\n  templateUrl: './footer.component.html',\n})\nexport class FooterComponent {\n  currentYear = new Date().getFullYear();\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<footer class=\"metro-footer\">\n  <div class=\"footer-content\">\n    <div class=\"footer-brand\">\n      <span class=\"icon-[iconoir--flower] footer-icon\"></span>\n      <span class=\"footer-title\">harawihark</span>\n    </div>\n    \n    <div class=\"footer-info\">\n      <p class=\"footer-description\">\n        Advanced syllable-meter checker with suggestions\n      </p>\n      <div class=\"footer-links\">\n        <a \n          href=\"https://github.com/benitoanagua/HarawiHark\" \n          target=\"_blank\" \n          rel=\"noopener noreferrer\"\n          class=\"footer-link\"\n          aria-label=\"GitHub Repository\"\n        >\n          <span class=\"icon-[iconoir--github]\"></span>\n          GitHub\n        </a>\n        <span class=\"footer-copyright\">\n          &copy; {{ currentYear }} harawihark\n        </span>\n      </div>\n    </div>\n  </div>\n</footer>"
        },
        {
            "name": "HeaderComponent",
            "id": "component-HeaderComponent-d874e0315642e1f9cf1164790332067d4cac711343ed5201d19b3e704edbb88e55deba7cb1289024c873c87265db2b3297c47d99b8e34de2b75e706e5f45cfee",
            "file": "src/app/components/layout/header/header.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-header",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./header.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "ThemeToggleComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component } from '@angular/core';\nimport { ThemeToggleComponent } from '../../theme-toggle/theme-toggle.component';\n\n@Component({\n  selector: 'app-header',\n  standalone: true,\n  imports: [ThemeToggleComponent],\n  templateUrl: './header.component.html',\n})\nexport class HeaderComponent {}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<header class=\"metro-header\">\n  <div class=\"header-content\">\n    <!-- Logo y nombre del sitio -->\n    <div class=\"logo-section\">\n      <div class=\"logo-wrapper\">\n        <span class=\"icon-[iconoir--flower] text-2xl text-primary\"></span>\n        <h1 class=\"logo-title\">harawihark</h1>\n      </div>\n    </div>\n\n    <!-- Navegación -->\n    <div class=\"nav-section\">\n      <!-- Enlace GitHub -->\n      <a \n        href=\"https://github.com/benitoanagua/HarawiHark\" \n        target=\"_blank\" \n        rel=\"noopener noreferrer\"\n        class=\"github-link\"\n        aria-label=\"GitHub Repository\"\n      >\n        <span class=\"icon-[iconoir--github] text-xl\"></span>\n      </a>\n      \n      <!-- Theme Toggle -->\n      <app-theme-toggle />\n    </div>\n  </div>\n</header>"
        },
        {
            "name": "InputComponent",
            "id": "component-InputComponent-fb4a73b3a4f3ed8acf809fe1e6c9ab3eda66abaea03f162608c6190e9b0db00073d6af15352c56ef85ae5388677d03000560fdd867353d464d185efef933d70f",
            "file": "src/app/components/ui/input/input.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [
                {
                    "name": ")"
                }
            ],
            "selector": "app-input",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./input.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "disabled",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 21,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "error",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 20,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "id",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 23,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "label",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 18,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "placeholder",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 19,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "rows",
                    "defaultValue": "6",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 22,
                    "type": "number",
                    "decorators": []
                },
                {
                    "name": "type",
                    "defaultValue": "'text'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 17,
                    "type": "\"text\" | \"textarea\"",
                    "decorators": []
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 26,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "inputBlur",
                    "defaultValue": "new EventEmitter<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 37,
                    "type": "EventEmitter"
                },
                {
                    "name": "inputChange",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 36,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "_value",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 34
                },
                {
                    "name": "onChange",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 39,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "onTouched",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 42,
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "onBlur",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 69,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onInput",
                    "args": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 62,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnChange",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "string",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ]
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 50,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "string",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnTouched",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": []
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 54,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setDisabledState",
                    "args": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 58,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "writeValue",
                    "args": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 46,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter, forwardRef } from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\n\n@Component({\n  selector: 'app-input',\n  standalone: true,\n  templateUrl: './input.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => InputComponent),\n      multi: true,\n    },\n  ],\n})\nexport class InputComponent implements ControlValueAccessor {\n  @Input() type: 'text' | 'textarea' = 'text';\n  @Input() label = '';\n  @Input() placeholder = '';\n  @Input() error = '';\n  @Input() disabled = false;\n  @Input() rows = 6;\n  @Input() id = '';\n\n  @Input()\n  get value(): string {\n    return this._value;\n  }\n  set value(val: string) {\n    this._value = val || '';\n    this.onChange(this._value);\n  }\n\n  _value = '';\n\n  @Output() inputChange = new EventEmitter<string>();\n  @Output() inputBlur = new EventEmitter<void>();\n\n  private onChange: (value: string) => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private onTouched: () => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n\n  writeValue(value: string): void {\n    this._value = value || '';\n  }\n\n  registerOnChange(fn: (value: string) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  onInput(event: Event): void {\n    const target = event.target as HTMLInputElement | HTMLTextAreaElement;\n    this._value = target.value;\n    this.onChange(this._value);\n    this.inputChange.emit(this._value);\n  }\n\n  onBlur(): void {\n    this.onTouched();\n    this.inputBlur.emit();\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "implements": [
                "ControlValueAccessor"
            ],
            "accessors": {
                "value": {
                    "name": "value",
                    "setSignature": {
                        "name": "value",
                        "type": "void",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "args": [
                            {
                                "name": "val",
                                "type": "string",
                                "deprecated": false,
                                "deprecationMessage": ""
                            }
                        ],
                        "returnType": "void",
                        "line": 29,
                        "jsdoctags": [
                            {
                                "name": "val",
                                "type": "string",
                                "deprecated": false,
                                "deprecationMessage": "",
                                "tagName": {
                                    "text": "param"
                                }
                            }
                        ]
                    },
                    "getSignature": {
                        "name": "value",
                        "type": "string",
                        "returnType": "string",
                        "line": 26
                    }
                }
            },
            "templateData": "<div class=\"input-wrapper\">\n  @if (label) {\n    <label class=\"input-label\" [for]=\"id\">{{ label }}</label>\n  }\n\n  @if (type === 'textarea') {\n    <textarea\n      class=\"input-base input-textarea\"\n      [class.input-error]=\"error\"\n      [placeholder]=\"placeholder\"\n      [disabled]=\"disabled\"\n      [rows]=\"rows\"\n      [value]=\"_value\"\n      [id]=\"id\"\n      (input)=\"onInput($event)\"\n      (blur)=\"onBlur()\"\n    ></textarea>\n  } @else {\n    <input\n      class=\"input-base input-text\"\n      [class.input-error]=\"error\"\n      [type]=\"type\"\n      [placeholder]=\"placeholder\"\n      [disabled]=\"disabled\"\n      [value]=\"_value\"\n      [id]=\"id\"\n      (input)=\"onInput($event)\"\n      (blur)=\"onBlur()\"\n    />\n  }\n\n  @if (error) {\n    <span class=\"input-error-text\">{{ error }}</span>\n  }\n</div>\n"
        },
        {
            "name": "ListItemComponent",
            "id": "component-ListItemComponent-1c23a442acb047d09d16f71fb7de3427948d9630af4cc822c26320514a920f01b1bc4ac023ee03c30824105764e06390699bdc0e2851dd56adb6f0907880c73a",
            "file": "src/app/components/metro/list-item/list-item.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-list-item",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./list-item.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "badge",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 15,
                    "type": "string | number",
                    "decorators": []
                },
                {
                    "name": "disabled",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 18,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 14,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "meta",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 16,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "showChevron",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 17,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "subtitle",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 13,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "title",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 12,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "itemClick",
                    "defaultValue": "new EventEmitter<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 19,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "onClick",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 21,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-list-item',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './list-item.component.html',\n})\nexport class ListItemComponent {\n  @Input() title = '';\n  @Input() subtitle?: string;\n  @Input() icon?: string;\n  @Input() badge?: string | number;\n  @Input() meta?: string;\n  @Input() showChevron = true;\n  @Input() disabled = false;\n  @Output() itemClick = new EventEmitter<void>();\n\n  onClick(): void {\n    if (!this.disabled) {\n      this.itemClick.emit();\n    }\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<!-- list-item.component.html -->\n<button\n  type=\"button\"\n  class=\"metro-list-item\"\n  [disabled]=\"disabled\"\n  (click)=\"onClick()\"\n>\n  @if (icon) {\n    <div class=\"metro-list-item-leading\">\n      <span [class]=\"icon + ' metro-list-item-icon'\"></span>\n    </div>\n  }\n\n  <div class=\"metro-list-item-content\">\n    <span class=\"metro-list-item-title\">{{ title }}</span>\n    @if (subtitle) {\n      <span class=\"metro-list-item-subtitle\">{{ subtitle }}</span>\n    }\n  </div>\n\n  <div class=\"metro-list-item-trailing\">\n    @if (badge) {\n      <span class=\"metro-list-item-badge\">{{ badge }}</span>\n    }\n    @if (meta) {\n      <span class=\"metro-list-item-meta\">{{ meta }}</span>\n    }\n    @if (showChevron) {\n      <span class=\"icon-[iconoir--nav-arrow-right] metro-list-item-chevron\"></span>\n    }\n  </div>\n</button>"
        },
        {
            "name": "MeterAnalysisSectionComponent",
            "id": "component-MeterAnalysisSectionComponent-dc1f7dd0d9e7e996426d8d2ae0bdb01f8bfdde8a3f4ad5c8b4bf01bfba886804fba4b8f649b88b838faf4ca4d0625b632b8c108b886c4b5c92a66e6104f5bbd6",
            "file": "src/app/components/poetry/meter-analysis-section/meter-analysis-section.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-meter-analysis-section",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./meter-analysis-section.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "required": true,
                    "name": "result",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "optional": false,
                    "line": 13,
                    "type": "EnhancedPoetryResult",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                },
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "BadgeComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CardComponent, BadgeComponent } from '../../ui';\nimport { EnhancedPoetryResult } from '../../../services/';\n\n@Component({\n  selector: 'app-meter-analysis-section',\n  standalone: true,\n  imports: [CommonModule, CardComponent, BadgeComponent],\n  templateUrl: './meter-analysis-section.component.html',\n})\nexport class MeterAnalysisSectionComponent {\n  @Input({ required: true }) result!: EnhancedPoetryResult;\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card padding=\"large\">\n  <div class=\"meter-analysis-container\">\n    <h3 class=\"section-title\">rhythm & meter analysis</h3>\n    \n    @if (result.meterAnalysis; as meter) {\n      <div class=\"meter-info\">\n        <div class=\"meter-header\">\n          <app-badge \n            [variant]=\"meter.consistency > 70 ? 'success' : meter.consistency > 40 ? 'warning' : 'error'\"\n            size=\"medium\"\n            icon=\"icon-[iconoir--music-note]\"\n          >\n            {{ meter.type }} meter\n          </app-badge>\n          <span class=\"consistency-score\">\n            {{ meter.consistency.toFixed(0) }}% consistent\n          </span>\n        </div>\n        \n        <p class=\"meter-pattern\">{{ meter.pattern }}</p>\n        <p class=\"meter-description\">{{ meter.description }}</p>\n        \n        @if (meter.examples.length > 0) {\n          <div class=\"meter-examples\">\n            <h4>examples of {{ meter.type }} meter:</h4>\n            <ul class=\"examples-list\">\n              @for (example of meter.examples; track $index) {\n                <li class=\"example-item\">{{ example }}</li>\n              }\n            </ul>\n          </div>\n        }\n      </div>\n    } @else {\n      <div class=\"no-meter-analysis\">\n        <span class=\"icon-[iconoir--music-note-solid] no-meter-icon\"></span>\n        <p class=\"no-meter-text\">No consistent meter pattern detected</p>\n      </div>\n    }\n  </div>\n</app-card>"
        },
        {
            "name": "MultilineInputComponent",
            "id": "component-MultilineInputComponent-37d48f33eba6c5623d25c8f76e5e975918d9aedf3a02260f8aea6fd0400a4cf0e5b27179cd2a277af437f90a7a908c660fa6c2993a0cfacc7ac99b75a262e23e",
            "file": "src/app/components/ui/multiline-input/multiline-input.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [
                {
                    "name": ")"
                }
            ],
            "selector": "app-multiline-input",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./multiline-input.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "disabled",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 53,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "error",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 52,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "expectedPattern",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 58,
                    "type": "number[]",
                    "decorators": []
                },
                {
                    "name": "fontSizeClass",
                    "defaultValue": "'text-base'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 59,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "id",
                    "defaultValue": "'multiline-input'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 55,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "label",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 50,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "placeholder",
                    "defaultValue": "'Write your poem line by line...'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 51,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "rows",
                    "defaultValue": "12",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 54,
                    "type": "number",
                    "decorators": []
                },
                {
                    "name": "showLineNumbers",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 56,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "showLineValidation",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 57,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 73,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "inputBlur",
                    "defaultValue": "new EventEmitter<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 82,
                    "type": "EventEmitter"
                },
                {
                    "name": "lineFocus",
                    "defaultValue": "new EventEmitter<{ index: number; text: string }>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 83,
                    "type": "EventEmitter"
                },
                {
                    "name": "lineValidationChange",
                    "defaultValue": "new EventEmitter<LineData[]>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 84,
                    "type": "EventEmitter"
                },
                {
                    "name": "valueChange",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 81,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "focusedLineIndex",
                    "defaultValue": "signal<number | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 64,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "lines",
                    "defaultValue": "signal<LineData[]>([])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 63,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "linesContainer",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "ElementRef<HTMLDivElement>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 48,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'linesContainer'"
                        }
                    ],
                    "modifierKind": [
                        171
                    ]
                },
                {
                    "name": "onChange",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 86,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "onTouched",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 87,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "poemText",
                    "defaultValue": "computed(() =>\n    this.lines()\n      .map((l) => l.text)\n      .join('\\n')\n  )",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 66,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 61,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "clear",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 276,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "emitChanges",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 255,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "focus",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 282,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "focusLine",
                    "args": [
                        {
                            "name": "index",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 190,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "index",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getSyllableSegments",
                    "args": [
                        {
                            "name": "line",
                            "type": "LineData",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "SyllableSegment[]",
                    "typeParameters": [],
                    "line": 261,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "LineData",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "handleKeyboardNavigation",
                    "args": [
                        {
                            "name": "event",
                            "type": "KeyboardEvent",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 156,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "decorators": [
                        {
                            "name": "HostListener",
                            "stringifiedArguments": "'keydown', ['$event']"
                        }
                    ],
                    "modifierKind": [
                        171
                    ],
                    "jsdoctags": [
                        {
                            "name": "event",
                            "type": "KeyboardEvent",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "initializeLines",
                    "args": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 93,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "insertTextAtCursor",
                    "args": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 198,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 89,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onLineBlur",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 149,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onLineFocus",
                    "args": [
                        {
                            "name": "index",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 144,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "index",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onLineInput",
                    "args": [
                        {
                            "name": "index",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 130,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "index",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnChange",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "string",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ]
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 118,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "string",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnTouched",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": []
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 122,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setDisabledState",
                    "args": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 126,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "updateLineSyllables",
                    "args": [
                        {
                            "name": "line",
                            "type": "LineData",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 228,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "LineData",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "updateLineValidation",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 243,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "writeValue",
                    "args": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 114,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [
                {
                    "name": "keydown",
                    "args": [
                        {
                            "name": "event",
                            "type": "KeyboardEvent",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "argsDecorator": [
                        "$event"
                    ],
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 156
                }
            ],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {\n  Component,\n  Input,\n  Output,\n  EventEmitter,\n  forwardRef,\n  ElementRef,\n  ViewChild,\n  HostListener,\n  signal,\n  computed,\n  OnInit,\n  inject,\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\nimport { RitaService } from '../../../services/poetry/rita.service';\n\nexport interface LineData {\n  text: string;\n  number: number;\n  focused: boolean;\n  syllables: number;\n  expectedSyllables: number;\n  isCorrect: boolean;\n  isOver: boolean;\n}\n\nexport interface SyllableSegment {\n  index: number;\n  filled: boolean;\n}\n\n@Component({\n  selector: 'app-multiline-input',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './multiline-input.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => MultilineInputComponent),\n      multi: true,\n    },\n  ],\n})\nexport class MultilineInputComponent implements ControlValueAccessor, OnInit {\n  @ViewChild('linesContainer') linesContainer!: ElementRef<HTMLDivElement>;\n\n  @Input() label = '';\n  @Input() placeholder = 'Write your poem line by line...';\n  @Input() error = '';\n  @Input() disabled = false;\n  @Input() rows = 12;\n  @Input() id = 'multiline-input';\n  @Input() showLineNumbers = true;\n  @Input() showLineValidation = false;\n  @Input() expectedPattern: number[] = [];\n  @Input() fontSizeClass = 'text-base'; // Clase por defecto\n\n  private readonly rita = inject(RitaService);\n\n  readonly lines = signal<LineData[]>([]);\n  readonly focusedLineIndex = signal<number | null>(null);\n\n  readonly poemText = computed(() =>\n    this.lines()\n      .map((l) => l.text)\n      .join('\\n')\n  );\n\n  @Input()\n  get value(): string {\n    return this.poemText();\n  }\n  set value(val: string) {\n    this.initializeLines(val || '');\n    this.onChange(this.poemText());\n  }\n\n  @Output() valueChange = new EventEmitter<string>();\n  @Output() inputBlur = new EventEmitter<void>();\n  @Output() lineFocus = new EventEmitter<{ index: number; text: string }>();\n  @Output() lineValidationChange = new EventEmitter<LineData[]>();\n\n  private onChange: (value: string) => void = () => {};\n  private onTouched: () => void = () => {};\n\n  ngOnInit() {\n    this.initializeLines('');\n  }\n\n  private initializeLines(text: string): void {\n    const linesArray = text.split('\\n');\n    const total = this.rows; // Número fijo de líneas\n    const result: LineData[] = [];\n\n    for (let i = 0; i < total; i++) {\n      const expectedSyllables = this.expectedPattern[i] || 0;\n      result.push({\n        text: linesArray[i] || '',\n        number: i + 1,\n        focused: false,\n        syllables: 0,\n        expectedSyllables,\n        isCorrect: false,\n        isOver: false,\n      });\n    }\n    this.lines.set(result);\n    this.updateLineValidation();\n  }\n\n  writeValue(value: string): void {\n    this.initializeLines(value || '');\n  }\n\n  registerOnChange(fn: (value: string) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  onLineInput(index: number, text: string): void {\n    const updated = [...this.lines()];\n    updated[index].text = text;\n\n    // Actualizar validación de sílabas usando RiTa\n    if (this.showLineValidation) {\n      this.updateLineSyllables(updated[index]);\n    }\n\n    this.lines.set(updated);\n    this.emitChanges();\n    this.updateLineValidation();\n  }\n\n  onLineFocus(index: number): void {\n    this.focusedLineIndex.set(index);\n    this.lineFocus.emit({ index, text: this.lines()[index].text });\n  }\n\n  onLineBlur(): void {\n    this.focusedLineIndex.set(null);\n    this.onTouched();\n    this.inputBlur.emit();\n  }\n\n  @HostListener('keydown', ['$event'])\n  handleKeyboardNavigation(event: KeyboardEvent): void {\n    const current = this.focusedLineIndex();\n    if (current === null) return;\n\n    const lines = this.lines();\n\n    switch (event.key) {\n      case 'ArrowUp':\n        event.preventDefault();\n        if (current > 0) this.focusLine(current - 1);\n        break;\n\n      case 'ArrowDown':\n        event.preventDefault();\n        if (current < lines.length - 1) this.focusLine(current + 1);\n        break;\n\n      case 'Enter':\n        if (!event.shiftKey) {\n          event.preventDefault();\n          // No agregar nuevas líneas automáticamente\n          if (current < lines.length - 1) {\n            this.focusLine(current + 1);\n          }\n        }\n        break;\n\n      case 'Tab':\n        event.preventDefault();\n        this.insertTextAtCursor('  ');\n        break;\n    }\n  }\n\n  private focusLine(index: number): void {\n    const input = document.getElementById(`${this.id}-line-${index}`) as HTMLInputElement;\n    if (!input) return;\n\n    input.focus();\n    this.focusedLineIndex.set(index);\n  }\n\n  private insertTextAtCursor(text: string): void {\n    const current = this.focusedLineIndex();\n    if (current === null) return;\n\n    const input = document.getElementById(`${this.id}-line-${current}`) as HTMLInputElement;\n    if (!input) return;\n\n    const start = input.selectionStart || 0;\n    const end = input.selectionEnd || 0;\n    const currentText = this.lines()[current].text;\n\n    const newText = currentText.substring(0, start) + text + currentText.substring(end);\n\n    const updated = [...this.lines()];\n    updated[current].text = newText;\n\n    if (this.showLineValidation) {\n      this.updateLineSyllables(updated[current]);\n    }\n\n    this.lines.set(updated);\n    this.emitChanges();\n    this.updateLineValidation();\n\n    setTimeout(() => {\n      input.focus();\n      input.setSelectionRange(start + text.length, start + text.length);\n    });\n  }\n\n  private updateLineSyllables(line: LineData): void {\n    if (!line.text.trim()) {\n      line.syllables = 0;\n      line.isCorrect = false;\n      line.isOver = false;\n      return;\n    }\n\n    // Usar RiTa para análisis real de sílabas\n    const analysis = this.rita.analyzeLine(line.text);\n    line.syllables = analysis.syllables;\n    line.isCorrect = line.syllables === line.expectedSyllables;\n    line.isOver = line.syllables > line.expectedSyllables;\n  }\n\n  private updateLineValidation(): void {\n    if (this.showLineValidation) {\n      const lines = this.lines();\n      lines.forEach((line) => {\n        if (line.text.trim()) {\n          this.updateLineSyllables(line);\n        }\n      });\n      this.lineValidationChange.emit(lines);\n    }\n  }\n\n  private emitChanges(): void {\n    this.onChange(this.poemText());\n    this.valueChange.emit(this.poemText());\n  }\n\n  // Método para generar segmentos de sílabas\n  getSyllableSegments(line: LineData): SyllableSegment[] {\n    const segments: SyllableSegment[] = [];\n    const expected = line.expectedSyllables;\n    const current = line.syllables;\n\n    for (let i = 0; i < expected; i++) {\n      segments.push({\n        index: i,\n        filled: i < current,\n      });\n    }\n\n    return segments;\n  }\n\n  clear(): void {\n    this.initializeLines('');\n    this.emitChanges();\n    this.focusLine(0);\n  }\n\n  focus(): void {\n    this.focusLine(0);\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "implements": [
                "ControlValueAccessor",
                "OnInit"
            ],
            "accessors": {
                "value": {
                    "name": "value",
                    "setSignature": {
                        "name": "value",
                        "type": "void",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "args": [
                            {
                                "name": "val",
                                "type": "string",
                                "deprecated": false,
                                "deprecationMessage": ""
                            }
                        ],
                        "returnType": "void",
                        "line": 76,
                        "jsdoctags": [
                            {
                                "name": "val",
                                "type": "string",
                                "deprecated": false,
                                "deprecationMessage": "",
                                "tagName": {
                                    "text": "param"
                                }
                            }
                        ]
                    },
                    "getSignature": {
                        "name": "value",
                        "type": "string",
                        "returnType": "string",
                        "line": 73
                    }
                }
            },
            "templateData": "<div class=\"multiline-input-wrapper\">\n  <div class=\"notebook-editor\" [class.disabled]=\"disabled\" [class]=\"fontSizeClass\">\n    <!-- Contenedor de líneas - ocupa todo el espacio -->\n    <div #linesContainer class=\"lines-container\">\n      @for (line of lines(); track line.number; let index = $index) {\n        <div class=\"line-row\" \n             [class.focused]=\"focusedLineIndex() === index\">\n          \n          <!-- Número de línea -->\n          @if (showLineNumbers) {\n            <div class=\"line-number\">{{ line.number }}</div>\n          }\n\n          <div class=\"line-input-container\">\n            <!-- Input de texto con clase responsiva -->\n            <input\n              [id]=\"id + '-line-' + index\"\n              type=\"text\"\n              class=\"line-input\"\n              [placeholder]=\"index === 0 ? placeholder : 'Continue writing...'\"\n              [value]=\"line.text\"\n              [disabled]=\"disabled\"\n              (input)=\"onLineInput(index, $any($event.target).value)\"\n              (focus)=\"onLineFocus(index)\"\n              (blur)=\"onLineBlur()\"\n              autocomplete=\"off\"\n              spellcheck=\"false\"\n              [class]=\"fontSizeClass\"\n            />\n\n            <!-- Validación visual sutil con barras de sílabas -->\n            @if (showLineValidation && line.expectedSyllables > 0) {\n              <div class=\"syllable-validation\">\n                <div class=\"syllable-bars\">\n                  @for (segment of getSyllableSegments(line); track $index) {\n                    <div class=\"syllable-bar\" \n                         [class.filled]=\"segment.filled\"\n                         [class.empty]=\"!segment.filled\"\n                         [class.perfect]=\"line.isCorrect\"\n                         [class.over]=\"line.isOver\">\n                    </div>\n                  }\n                </div>\n                <div class=\"syllable-count\" [class]=\"fontSizeClass\">\n                  {{ line.syllables }}/{{ line.expectedSyllables }}\n                </div>\n              </div>\n            }\n          </div>\n        </div>\n      }\n    </div>\n  </div>\n\n  @if (error) {\n    <span class=\"input-error-text\">{{ error }}</span>\n  }\n</div>"
        },
        {
            "name": "PanoramaComponent",
            "id": "component-PanoramaComponent-a1689931c14e935a7481b4adaa02a5edff65eca0a7ab2e641c04ffe1bb373885104f71cba98d07777c9ede7cd4f309dc9f9c452586819008afacf75b1d4ef5ee",
            "file": "src/app/components/metro/panorama/panorama.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-panorama",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./panorama.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-panorama',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './panorama.component.html',\n})\nexport class PanoramaComponent {}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<div class=\"panorama-container\">\n  <ng-content />\n</div>"
        },
        {
            "name": "PivotComponent",
            "id": "component-PivotComponent-abfe3bd76968416e3e585932504a29deab143cbe42168579def4858ffb8ad907f8caec6ed31cf18d91b80838fe19c44217aa33eeb57eab9e0dc27c36be543685",
            "file": "src/app/components/metro/pivot/pivot.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-pivot",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./pivot.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "items",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 18,
                    "type": "PivotItem[]",
                    "decorators": []
                },
                {
                    "name": "selectedId",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 19,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "selectedChange",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 20,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "select",
                    "args": [
                        {
                            "name": "id",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 22,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nexport interface PivotItem {\n  id: string;\n  label: string;\n  disabled?: boolean;\n}\n\n@Component({\n  selector: 'app-pivot',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './pivot.component.html',\n})\nexport class PivotComponent {\n  @Input() items: PivotItem[] = [];\n  @Input() selectedId = '';\n  @Output() selectedChange = new EventEmitter<string>();\n\n  select(id: string): void {\n    if (this.selectedId !== id) {\n      this.selectedId = id;\n      this.selectedChange.emit(id);\n    }\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<!-- pivot.component.html -->\n<nav class=\"metro-pivot\" role=\"tablist\">\n  @for (item of items; track item.id) {\n    <button\n      type=\"button\"\n      role=\"tab\"\n      [class.metro-pivot-active]=\"selectedId === item.id\"\n      [disabled]=\"item.disabled\"\n      [attr.aria-selected]=\"selectedId === item.id\"\n      (click)=\"select(item.id)\"\n      class=\"metro-pivot-item\"\n    >\n      {{ item.label }}\n    </button>\n  }\n</nav>"
        },
        {
            "name": "PoemEditorComponent",
            "id": "component-PoemEditorComponent-d19e158adea379695585b25311477e31ff0cf30e9b8721a0ca667d2c68f4022326f6c960d722466c7aa9dc3de6df462c758b28d13c796c089421c3966ffaa8fc",
            "file": "src/app/components/poetry/poem-editor/poem-editor.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-poem-editor",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./poem-editor.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "analyzer",
                    "defaultValue": "inject(PoetryAnalyzerService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "currentForm",
                    "defaultValue": "computed(() => this.patterns.getFormInfo(this.selectedForm()))",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 23,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "currentPattern",
                    "defaultValue": "computed(() => {\n    const form = this.currentForm();\n    return form ? form.pattern : [];\n  })",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 26,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "editorHeight",
                    "defaultValue": "signal('100%')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 65,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "expectedLines",
                    "defaultValue": "computed(() => {\n    const form = this.currentForm();\n    return form ? form.lines : 3;\n  })",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 32,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "expectedSyllables",
                    "defaultValue": "computed(() => {\n    const form = this.currentForm();\n    return form ? form.pattern.reduce((sum: number, n: number) => sum + n, 0) : 0;\n  })",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 53,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "formOptions",
                    "defaultValue": "POETRY_FORM_OPTIONS",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 19,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "lineCount",
                    "defaultValue": "computed(() => this.lines().length)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 45,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "lines",
                    "defaultValue": "computed(() =>\n    this.poemText()\n      .split('\\n')\n      .slice(0, this.expectedLines()) // Solo considerar las líneas esperadas\n      .filter((line) => line.trim().length > 0)\n  )",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 38,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "Math",
                    "defaultValue": "Math",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "patterns",
                    "defaultValue": "inject(PoetryPatternsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "poemText",
                    "defaultValue": "signal('')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 21,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "selectedForm",
                    "defaultValue": "signal('haiku')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 20,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "syllableProgress",
                    "defaultValue": "computed(() => {\n    const total = this.totalSyllables();\n    const expected = this.expectedSyllables();\n    return expected > 0 ? (total / expected) * 100 : 0;\n  })",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 58,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "totalSyllables",
                    "defaultValue": "computed(() => {\n    return this.lines().reduce((total, line) => {\n      return total + this.analyzer['rita'].analyzeLine(line).syllables;\n    }, 0);\n  })",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 47,
                    "modifierKind": [
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "adjustEditorHeight",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 145,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "analyze",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 132,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "clear",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 127,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getCurrentPlaceholder",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 160,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getResponsiveFontClass",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 155,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "isReadyForAnalysis",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 140,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "loadExample",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 115,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onFormChange",
                    "args": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 89,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onTextChange",
                    "args": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 108,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "updateEditorForForm",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 94,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                },
                {
                    "name": "SelectComponent",
                    "type": "component"
                },
                {
                    "name": "ButtonComponent",
                    "type": "component"
                },
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "MultilineInputComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, signal, computed, inject, effect } from '@angular/core';\nimport { SelectComponent, ButtonComponent, CardComponent } from '../../ui';\nimport { MultilineInputComponent } from '../../ui/multiline-input/multiline-input.component';\nimport { POETRY_FORM_OPTIONS, POETRY_EXAMPLES } from '../../../data/poetry-forms.data';\nimport { PoetryAnalyzerService, PoetryPatternsService } from '../../../services';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-poem-editor',\n  standalone: true,\n  imports: [CommonModule, SelectComponent, ButtonComponent, CardComponent, MultilineInputComponent],\n  templateUrl: './poem-editor.component.html',\n})\nexport class PoemEditorComponent {\n  private readonly analyzer = inject(PoetryAnalyzerService);\n  private readonly patterns = inject(PoetryPatternsService);\n\n  readonly Math = Math;\n  readonly formOptions = POETRY_FORM_OPTIONS;\n  readonly selectedForm = signal('haiku');\n  readonly poemText = signal('');\n\n  readonly currentForm = computed(() => this.patterns.getFormInfo(this.selectedForm()));\n\n  // Pattern para el multiline input - número fijo de líneas\n  readonly currentPattern = computed(() => {\n    const form = this.currentForm();\n    return form ? form.pattern : [];\n  });\n\n  // Número fijo de líneas según la forma poética\n  readonly expectedLines = computed(() => {\n    const form = this.currentForm();\n    return form ? form.lines : 3;\n  });\n\n  // Stats en tiempo real\n  readonly lines = computed(() =>\n    this.poemText()\n      .split('\\n')\n      .slice(0, this.expectedLines()) // Solo considerar las líneas esperadas\n      .filter((line) => line.trim().length > 0)\n  );\n\n  readonly lineCount = computed(() => this.lines().length);\n\n  readonly totalSyllables = computed(() => {\n    return this.lines().reduce((total, line) => {\n      return total + this.analyzer['rita'].analyzeLine(line).syllables;\n    }, 0);\n  });\n\n  readonly expectedSyllables = computed(() => {\n    const form = this.currentForm();\n    return form ? form.pattern.reduce((sum: number, n: number) => sum + n, 0) : 0;\n  });\n\n  readonly syllableProgress = computed(() => {\n    const total = this.totalSyllables();\n    const expected = this.expectedSyllables();\n    return expected > 0 ? (total / expected) * 100 : 0;\n  });\n\n  // Estado para controlar la altura del editor\n  readonly editorHeight = signal('100%');\n\n  constructor() {\n    // Efecto: Sincronizar cuando cambia la forma poética\n    effect(() => {\n      const formId = this.selectedForm();\n      this.analyzer.selectedForm.set(formId);\n      // Actualizar placeholder y contenido cuando cambia el formulario\n      this.updateEditorForForm();\n    });\n\n    // Efecto: Sincronizar texto con analyzer\n    effect(() => {\n      const text = this.poemText();\n      this.analyzer.poemText.set(text);\n    });\n\n    // Efecto: Ajustar altura cuando cambia el formulario\n    effect(() => {\n      const form = this.currentForm();\n      this.adjustEditorHeight();\n    });\n  }\n\n  onFormChange(formId: string): void {\n    this.selectedForm.set(formId);\n    // El efecto automáticamente actualizará el editor\n  }\n\n  private updateEditorForForm(): void {\n    // Actualizar el placeholder y resetear el texto si está vacío\n    const currentText = this.poemText();\n    if (!currentText.trim()) {\n      // Si el editor está vacío, cargar ejemplo automáticamente\n      this.loadExample();\n    }\n\n    // Forzar recálculo de altura después del cambio\n    setTimeout(() => {\n      this.adjustEditorHeight();\n    }, 100);\n  }\n\n  onTextChange(text: string): void {\n    // Mantener solo el número esperado de líneas\n    const lines = text.split('\\n');\n    const trimmedText = lines.slice(0, this.expectedLines()).join('\\n');\n    this.poemText.set(trimmedText);\n  }\n\n  loadExample(): void {\n    const formId = this.selectedForm();\n    const example = POETRY_EXAMPLES[formId];\n\n    if (example) {\n      this.poemText.set(example.join('\\n'));\n    } else {\n      // Si no hay ejemplo, limpiar el editor\n      this.poemText.set('');\n    }\n  }\n\n  clear(): void {\n    this.poemText.set('');\n    this.analyzer.clear();\n  }\n\n  analyze(): void {\n    const lines = this.lines();\n    if (lines.length === 0) return;\n\n    this.analyzer.analyze(this.selectedForm(), lines);\n  }\n\n  // Método para verificar si está listo para análisis\n  isReadyForAnalysis(): boolean {\n    return this.lineCount() > 0;\n  }\n\n  // Método para ajustar la altura del editor\n  private adjustEditorHeight(): void {\n    // Calcular altura basada en el número de líneas esperadas\n    const lines = this.expectedLines();\n    const baseHeight = 52; // altura base por línea\n    const calculatedHeight = Math.max(240, lines * baseHeight); // altura mínima de 240px\n\n    this.editorHeight.set(`${calculatedHeight}px`);\n  }\n\n  // Método para obtener la clase de tamaño de fuente responsiva\n  getResponsiveFontClass(): string {\n    return 'responsive-font';\n  }\n\n  // Método para obtener el placeholder actualizado\n  getCurrentPlaceholder(): string {\n    const form = this.currentForm();\n    return form ? `Write your ${form.name} here...` : 'Write your poem here...';\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 65
            },
            "extends": [],
            "templateData": "<app-card padding=\"large\" class=\"editor-card\">\n  <div class=\"editor-container\">\n    \n    <!-- Header minimalista -->\n    <header class=\"editor-header\">\n      <h1 class=\"editor-title\">poetry editor</h1>\n      <div class=\"form-selector\">\n        <app-select\n          id=\"poetry-form\"\n          [options]=\"formOptions\"\n          [value]=\"selectedForm()\"\n          (selectChange)=\"onFormChange($event)\"\n        />\n      </div>\n    </header>\n\n    <!-- Stats panel muy sutil -->\n    <div class=\"stats-panel-minimal\">\n      <div class=\"stat-minimal\">\n        <span class=\"stat-minimal-value\">{{ lineCount() }}</span>\n        <span class=\"stat-minimal-label\">lines</span>\n      </div>\n      <div class=\"stat-minimal\">\n        <span class=\"stat-minimal-value\">{{ totalSyllables() }}</span>\n        <span class=\"stat-minimal-label\">syllables</span>\n      </div>\n      <div class=\"stat-minimal\">\n        <span class=\"stat-minimal-value\">{{ Math.min(syllableProgress(), 100).toFixed(0) }}%</span>\n        <span class=\"stat-minimal-label\">complete</span>\n      </div>\n    </div>\n\n    <!-- Editor Multiline - Altura dinámica y 100% ancho -->\n    <section class=\"editor-section\" [style.height]=\"editorHeight()\">\n      <app-multiline-input\n        id=\"poem-editor\"\n        [placeholder]=\"getCurrentPlaceholder()\"\n        [rows]=\"expectedLines()\"\n        [value]=\"poemText()\"\n        [showLineNumbers]=\"true\"\n        [showLineValidation]=\"true\"\n        [expectedPattern]=\"currentPattern()\"\n        (valueChange)=\"onTextChange($event)\"\n        [class]=\"getResponsiveFontClass()\"\n      />\n    </section>\n\n    <!-- Actions footer - Siempre visible y sincronizado -->\n    <footer class=\"editor-actions\">\n      <app-button\n        variant=\"primary\"\n        size=\"medium\"\n        label=\"analyze\"\n        icon=\"icon-[iconoir--search]\"\n        [disabled]=\"!isReadyForAnalysis()\"\n        (clicked)=\"analyze()\"\n      />\n\n      <app-button\n        variant=\"outline\"\n        size=\"medium\"\n        label=\"example\"\n        icon=\"icon-[iconoir--page]\"\n        (clicked)=\"loadExample()\"\n      />\n\n      <app-button\n        variant=\"outline\"\n        size=\"medium\"\n        label=\"clear\"\n        icon=\"icon-[iconoir--cancel]\"\n        (clicked)=\"clear()\"\n      />\n    </footer>\n\n  </div>\n</app-card>"
        },
        {
            "name": "PoemQualityComponent",
            "id": "component-PoemQualityComponent-d88b6ba961f1e640d5d5647b16b3a5b650c6365443fc7affbb3d933c3582eaf91889dad47d7243f5584bacbeda11a8373f83a8f0e786146346fa35ee919ff73b",
            "file": "src/app/components/poetry/poem-quality/poem-quality.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-poem-quality",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./poem-quality.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "required": true,
                    "name": "metrics",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "optional": false,
                    "line": 13,
                    "type": "QualityMetrics",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "getGradeVariant",
                    "args": [
                        {
                            "name": "grade",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "\"success\" | \"info\" | \"warning\" | \"error\"",
                    "typeParameters": [],
                    "line": 29,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "grade",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getMetricColor",
                    "args": [
                        {
                            "name": "value",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 22,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getMetricEntries",
                    "args": [],
                    "optional": false,
                    "returnType": "literal type[]",
                    "typeParameters": [],
                    "line": 15,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                },
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "BadgeComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { QualityMetrics } from '../../../services';\nimport { CardComponent, BadgeComponent } from '../../ui';\n\n@Component({\n  selector: 'app-poem-quality',\n  standalone: true,\n  imports: [CommonModule, CardComponent, BadgeComponent],\n  templateUrl: './poem-quality.component.html',\n})\nexport class PoemQualityComponent {\n  @Input({ required: true }) metrics!: QualityMetrics;\n\n  getMetricEntries(): { name: string; value: number }[] {\n    return Object.entries(this.metrics.breakdown).map(([key, value]) => ({\n      name: key.replace(/([A-Z])/g, ' $1').toLowerCase(),\n      value,\n    }));\n  }\n\n  getMetricColor(value: number): string {\n    if (value >= 80) return 'metric-excellent';\n    if (value >= 70) return 'metric-good';\n    if (value >= 60) return 'metric-fair';\n    return 'metric-poor';\n  }\n\n  getGradeVariant(grade: string): 'success' | 'info' | 'warning' | 'error' {\n    switch (grade) {\n      case 'A+':\n      case 'A':\n        return 'success';\n      case 'B+':\n      case 'B':\n        return 'info';\n      case 'C+':\n      case 'C':\n        return 'warning';\n      default:\n        return 'error';\n    }\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card padding=\"large\" *ngIf=\"metrics\">\n  <div class=\"quality-container\">\n    <!-- Header con puntuación -->\n    <div class=\"quality-header\">\n      <div class=\"score-section\">\n        <h3 class=\"quality-title\">quality assessment</h3>\n        <div class=\"score-display\">\n          <span class=\"score-number\">{{ metrics.score.toFixed(1) }}</span>\n          <span class=\"score-max\">/100</span>\n          <app-badge [variant]=\"getGradeVariant(metrics.grade)\" size=\"medium\" class=\"grade-badge\">\n            {{ metrics.grade }}\n          </app-badge>\n        </div>\n      </div>\n    </div>\n\n    <!-- Breakdown de métricas -->\n    <div class=\"metrics-breakdown\">\n      <h4 class=\"breakdown-title\">detailed breakdown</h4>\n      <div class=\"metrics-grid\">\n        <div class=\"metric-item\" *ngFor=\"let metric of getMetricEntries()\">\n          <div class=\"metric-header\">\n            <span class=\"metric-name\">{{ metric.name }}</span>\n            <span class=\"metric-score\">{{ metric.value.toFixed(1) }}%</span>\n          </div>\n          <div class=\"metric-bar\">\n            <div\n              class=\"metric-fill\"\n              [style.width.%]=\"metric.value\"\n              [class]=\"getMetricColor(metric.value)\"\n            ></div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Fortalezas y mejoras -->\n    <div class=\"feedback-section\">\n      <div class=\"strengths\">\n        <h4 class=\"feedback-title\">\n          <span class=\"icon-[iconoir--check] feedback-icon\"></span>\n          strengths\n        </h4>\n        <ul class=\"feedback-list\">\n          <li *ngFor=\"let strength of metrics.strengths\">{{ strength }}</li>\n        </ul>\n      </div>\n\n      <div class=\"improvements\">\n        <h4 class=\"feedback-title\">\n          <span class=\"icon-[iconoir--light-bulb] feedback-icon\"></span>\n          suggestions\n        </h4>\n        <ul class=\"feedback-list\">\n          <li *ngFor=\"let improvement of metrics.improvements\">{{ improvement }}</li>\n        </ul>\n      </div>\n    </div>\n  </div>\n</app-card>\n"
        },
        {
            "name": "PoemResultsComponent",
            "id": "component-PoemResultsComponent-8743665d798047c6c05742ef0850bb4dfca8f0ca0ec7c139a8c5b388e0debcd42fbb8592751ff6c764915e257cad6f6349ba92cb94e01add473422274a3a06b8",
            "file": "src/app/components/poetry/poem-results/poem-results.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-poem-results",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./poem-results.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "required": true,
                    "name": "result",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "optional": false,
                    "line": 14,
                    "type": "EnhancedPoetryResult",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "wordSelected",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 15,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "utils",
                    "defaultValue": "inject(UtilsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 12,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "getPosLabel",
                    "args": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 21,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onWordClick",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 17,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "BadgeComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter, inject } from '@angular/core';\nimport { CardComponent, BadgeComponent } from '../../ui';\nimport { EnhancedPoetryResult, UtilsService } from '../../../services';\n\n@Component({\n  selector: 'app-poem-results',\n  standalone: true,\n  imports: [CardComponent, BadgeComponent],\n  templateUrl: './poem-results.component.html',\n})\nexport class PoemResultsComponent {\n  private readonly utils = inject(UtilsService);\n\n  @Input({ required: true }) result!: EnhancedPoetryResult;\n  @Output() wordSelected = new EventEmitter<string>();\n\n  onWordClick(word: string): void {\n    this.wordSelected.emit(word);\n  }\n\n  getPosLabel(pos: string): string {\n    return this.utils.getPosLabel(pos);\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card padding=\"large\">\n  <div class=\"results-container\">\n    <!-- Status Header -->\n    <div class=\"status-header mb-metro-md\">\n      <app-badge\n        [variant]=\"result.ok ? 'success' : 'warning'\"\n        size=\"medium\"\n        [icon]=\"result.ok ? 'icon-[iconoir--check]' : 'icon-[iconoir--warning-triangle]'\"\n      >\n        {{ result.ok ? 'Perfect match' : 'Pattern mismatch' }}\n      </app-badge>\n      <p class=\"status-summary mt-metro-xs text-sm opacity-80\">{{ result.summary }}</p>\n    </div>\n\n    <!-- Detected Patterns Section -->\n    @if (result.detectedPatterns && result.detectedPatterns.length > 0) {\n    <div class=\"patterns-section\">\n      <h3 class=\"section-title\">detected patterns</h3>\n      <div class=\"patterns-list\">\n        @for (pattern of result.detectedPatterns; track $index) {\n        <div class=\"pattern-item\">\n          <span class=\"icon-[iconoir--sparks] pattern-icon\"></span>\n          <span class=\"pattern-text\">{{ pattern }}</span>\n        </div>\n        }\n      </div>\n    </div>\n    }\n\n    <!-- Alliteration Section -->\n    @if (result.overallAlliterations && result.overallAlliterations.length > 0) {\n    <div class=\"alliteration-section\">\n      <h3 class=\"section-title\">alliterations detected</h3>\n      <div class=\"alliteration-list\">\n        @for (alliteration of result.overallAlliterations; track $index) {\n        <div class=\"alliteration-item\">\n          <app-badge variant=\"info\" size=\"small\" icon=\"icon-[iconoir--sound-high]\">\n            {{ alliteration.sound }}\n          </app-badge>\n          <span class=\"alliteration-words\">\n            {{ alliteration.words.join(' • ') }}\n          </span>\n        </div>\n        }\n      </div>\n    </div>\n    }\n\n    <!-- Line Analysis -->\n    <div class=\"line-analysis-section\">\n      <h3 class=\"section-title\">line-by-line analysis</h3>\n\n      <div class=\"lines-container\">\n        @for (line of result.lines; track $index) {\n        <div class=\"line-card\">\n          <!-- Line Header -->\n          <div class=\"line-header\">\n            <span class=\"line-number\"> line {{ $index + 1 }} </span>\n            <app-badge\n              [variant]=\"line.match ? 'success' : 'error'\"\n              size=\"small\"\n              [icon]=\"line.match ? 'icon-[iconoir--check]' : 'icon-[iconoir--cancel]'\"\n            >\n              {{ line.count }}/{{ line.expected }} syllables\n            </app-badge>\n          </div>\n\n          <!-- Line Text with Clickable Words -->\n          <p class=\"line-text\">\n            @for (word of line.words; track $index) {\n            <span\n              class=\"word-token\"\n              [class.word-clickable]=\"!line.match\"\n              [attr.role]=\"!line.match ? 'button' : null\"\n              [attr.tabindex]=\"!line.match ? 0 : null\"\n              (click)=\"!line.match && onWordClick(word.word)\"\n              (keyup.enter)=\"!line.match && onWordClick(word.word)\"\n              (keyup.space)=\"!line.match && onWordClick(word.word)\"\n              [title]=\"getPosLabel(word.pos) + ' • ' + word.syllables + ' syllable(s)'\"\n            >\n              {{ word.word }}\n            </span>\n            }\n          </p>\n\n          <!-- Alliterations in Line -->\n          @if (line.alliterations && line.alliterations.length > 0) {\n          <div class=\"line-alliterations\">\n            @for (alliteration of line.alliterations; track $index) {\n            <app-badge variant=\"info\" size=\"small\" icon=\"icon-[iconoir--sound-high]\">\n              alliteration: {{ alliteration.words.join(', ') }}\n            </app-badge>\n            }\n          </div>\n          }\n\n          <!-- Syllable Breakdown -->\n          @if (line.syllables && line.syllables.length > 0) {\n          <div class=\"syllable-breakdown\">\n            <span class=\"breakdown-label\">syllables:</span>\n            <div class=\"syllable-chips\">\n              @for (syllable of line.syllables; track $index) {\n              <span class=\"syllable-chip\">{{ syllable }}</span>\n              }\n            </div>\n          </div>\n          }\n\n          <!-- Stress Pattern -->\n          @if (line.stresses) {\n          <div class=\"stress-pattern\">\n            <span class=\"breakdown-label\">stress:</span>\n            <span class=\"stress-value\">{{ line.stresses }}</span>\n          </div>\n          }\n\n          <!-- Word Details -->\n          <details class=\"word-details\">\n            <summary class=\"word-details-summary\">view word analysis</summary>\n            <div class=\"word-details-content\">\n              @for (word of line.words; track $index) {\n              <div class=\"word-detail-item\">\n                <span class=\"word-detail-word\">{{ word.word }}</span>\n                <div class=\"word-detail-meta\">\n                  <span class=\"word-detail-syllables\">\n                    {{ word.syllables }} syllable{{ word.syllables !== 1 ? 's' : '' }}\n                  </span>\n                  <span class=\"word-detail-pos\">{{ getPosLabel(word.pos) }}</span>\n                  @if (word.phones) {\n                  <span class=\"word-detail-phones\">{{ word.phones }}</span>\n                  }\n                </div>\n              </div>\n              }\n            </div>\n          </details>\n        </div>\n        }\n      </div>\n    </div>\n\n    <!-- Rhyme Scheme -->\n    @if (result.rhymeScheme) {\n    <div class=\"rhyme-section\">\n      <h4 class=\"section-title\">rhyme scheme</h4>\n      <div class=\"rhyme-scheme\">\n        <span class=\"rhyme-value\">{{ result.rhymeScheme }}</span>\n      </div>\n    </div>\n    }\n\n    <!-- Suggestions -->\n    @if (result.suggestions && result.suggestions.length > 0) {\n    <div class=\"suggestions-section\">\n      <h4 class=\"section-title\">suggestions for improvement</h4>\n      <ul class=\"suggestions-list\">\n        @for (suggestion of result.suggestions; track $index) {\n        <li class=\"suggestion-item\">\n          <span class=\"icon-[iconoir--light-bulb] suggestion-icon\"></span>\n          <span>{{ suggestion }}</span>\n        </li>\n        }\n      </ul>\n    </div>\n    }\n  </div>\n</app-card>"
        },
        {
            "name": "PoetryPageComponent",
            "id": "component-PoetryPageComponent-a98d9547f360a6ef9c39ccc62df10a1c78e3383bc92a2139fd82ecc51cfd3524b243a120a61f3e87d4e2a16729c3d63a4fc267700f3206462411f760c2329fb7",
            "file": "src/app/components/layout/poetry-page/poetry-page.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-poetry-page",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./poetry-page.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "analysisTabs",
                    "defaultValue": "signal<PivotItem[]>([\n    { id: 'structure', label: 'structure' },\n    { id: 'rhythm', label: 'rhythm' },\n    { id: 'quality', label: 'quality' },\n    { id: 'stats', label: 'stats' },\n  ])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 59,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "analyzer",
                    "defaultValue": "inject(PoetryAnalyzerService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 49,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "appBarActions",
                    "defaultValue": "[\n    { id: 'analyze', icon: 'icon-[iconoir--search]', label: 'analyze' },\n    { id: 'example', icon: 'icon-[iconoir--page]', label: 'example' },\n    { id: 'clear', icon: 'icon-[iconoir--cancel]', label: 'clear' },\n  ]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "AppBarAction[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 67,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "currentSection",
                    "defaultValue": "signal<'editor' | 'results'>('editor')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 55,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "currentStage",
                    "defaultValue": "signal<'syllables' | 'rhythm' | 'patterns' | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 53,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "hasResults",
                    "defaultValue": "computed(() => this.analyzer.result() !== null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 73,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "isAnalyzing",
                    "defaultValue": "computed(() => this.loadingState() !== 'idle')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 74,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "loadingState",
                    "defaultValue": "signal<'idle' | 'analyzing' | 'loading-example' | 'assessing'>('idle')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 52,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "recentlyAnalyzed",
                    "defaultValue": "signal(false)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 56,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "selectedAnalysisTab",
                    "defaultValue": "signal('structure')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 65,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "toastService",
                    "defaultValue": "inject(ToastService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 50,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "analyzeWithStages",
                    "args": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 125,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "confirmClear",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 120,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "delay",
                    "args": [
                        {
                            "name": "ms",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 153,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "ms",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getFormPattern",
                    "args": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 294,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getQuickStats",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 286,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "handleAnalyze",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 173,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "handleClear",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 209,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "handleLoadExample",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 187,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "loadFormExample",
                    "args": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 281,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "navigateToSection",
                    "args": [
                        {
                            "name": "sectionId",
                            "type": "\"editor\" | \"results\"",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 102,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "sectionId",
                            "type": "\"editor\" | \"results\"",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "navigateWithHighlight",
                    "args": [
                        {
                            "name": "sectionId",
                            "type": "\"editor\" | \"results\"",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 112,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "sectionId",
                            "type": "\"editor\" | \"results\"",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onAnalysisTabChange",
                    "args": [
                        {
                            "name": "tabId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 230,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "tabId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onAnalyze",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 226,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onAppBarAction",
                    "args": [
                        {
                            "name": "actionId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 157,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "actionId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onAssessQuality",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 264,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onCloseSuggestions",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 244,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onExportPoem",
                    "args": [],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 248,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ]
                },
                {
                    "name": "onQuickNav",
                    "args": [
                        {
                            "name": "section",
                            "type": "\"editor\" | \"results\"",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 308,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "section",
                            "type": "\"editor\" | \"results\"",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onReplaceWord",
                    "args": [
                        {
                            "name": "newWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 238,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "newWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onShowMeterAnalysis",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 276,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onWordSelected",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 234,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setupScrollDetection",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 82,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                },
                {
                    "name": "PanoramaComponent",
                    "type": "component"
                },
                {
                    "name": "PivotComponent",
                    "type": "component"
                },
                {
                    "name": "AppBarComponent",
                    "type": "component"
                },
                {
                    "name": "ProgressComponent",
                    "type": "component"
                },
                {
                    "name": "ToastContainerComponent",
                    "type": "component"
                },
                {
                    "name": "PoemEditorComponent",
                    "type": "component"
                },
                {
                    "name": "PoemResultsComponent",
                    "type": "component"
                },
                {
                    "name": "PoemQualityComponent",
                    "type": "component"
                },
                {
                    "name": "WordSuggestionsComponent",
                    "type": "component"
                },
                {
                    "name": "QuickStatsPanelComponent",
                    "type": "component"
                },
                {
                    "name": "MeterAnalysisSectionComponent",
                    "type": "component"
                },
                {
                    "name": "ButtonComponent",
                    "type": "component"
                },
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "HeaderComponent",
                    "type": "component"
                },
                {
                    "name": "FooterComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, inject, signal, computed } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport {\n  PanoramaComponent,\n  PivotComponent,\n  type PivotItem,\n  AppBarComponent,\n  type AppBarAction,\n  ProgressComponent,\n  ToastContainerComponent,\n} from '../../metro';\nimport {\n  PoemEditorComponent,\n  PoemResultsComponent,\n  PoemQualityComponent,\n  WordSuggestionsComponent,\n  QuickStatsPanelComponent,\n  MeterAnalysisSectionComponent,\n} from '../../poetry';\nimport { ButtonComponent, CardComponent } from '../../ui';\nimport { HeaderComponent, FooterComponent } from '../../layout';\nimport { PoetryAnalyzerService, ToastService } from '../../../services';\n\n@Component({\n  selector: 'app-poetry-page',\n  standalone: true,\n  imports: [\n    CommonModule,\n    PanoramaComponent,\n    PivotComponent,\n    AppBarComponent,\n    ProgressComponent,\n    ToastContainerComponent,\n    PoemEditorComponent,\n    PoemResultsComponent,\n    PoemQualityComponent,\n    WordSuggestionsComponent,\n    QuickStatsPanelComponent,\n    MeterAnalysisSectionComponent,\n    ButtonComponent,\n    CardComponent,\n    HeaderComponent,\n    FooterComponent,\n  ],\n  templateUrl: './poetry-page.component.html',\n})\nexport class PoetryPageComponent {\n  readonly analyzer = inject(PoetryAnalyzerService);\n  private readonly toastService = inject(ToastService);\n\n  readonly loadingState = signal<'idle' | 'analyzing' | 'loading-example' | 'assessing'>('idle');\n  readonly currentStage = signal<'syllables' | 'rhythm' | 'patterns' | null>(null);\n\n  readonly currentSection = signal<'editor' | 'results'>('editor');\n  readonly recentlyAnalyzed = signal(false);\n\n  // Analysis Tabs\n  readonly analysisTabs = signal<PivotItem[]>([\n    { id: 'structure', label: 'structure' },\n    { id: 'rhythm', label: 'rhythm' },\n    { id: 'quality', label: 'quality' },\n    { id: 'stats', label: 'stats' },\n  ]);\n  readonly selectedAnalysisTab = signal('structure');\n\n  readonly appBarActions: AppBarAction[] = [\n    { id: 'analyze', icon: 'icon-[iconoir--search]', label: 'analyze' },\n    { id: 'example', icon: 'icon-[iconoir--page]', label: 'example' },\n    { id: 'clear', icon: 'icon-[iconoir--cancel]', label: 'clear' },\n  ];\n\n  readonly hasResults = computed(() => this.analyzer.result() !== null);\n  readonly isAnalyzing = computed(() => this.loadingState() !== 'idle');\n\n  constructor() {\n    if (typeof window !== 'undefined') {\n      this.setupScrollDetection();\n    }\n  }\n\n  private setupScrollDetection(): void {\n    const observer = new IntersectionObserver(\n      (entries) => {\n        entries.forEach((entry) => {\n          if (entry.isIntersecting) {\n            const section = entry.target.getAttribute('data-section') as 'editor' | 'results';\n            if (section) {\n              this.currentSection.set(section);\n            }\n          }\n        });\n      },\n      { threshold: 0.3 }\n    );\n\n    setTimeout(() => {\n      document.querySelectorAll('[data-section]').forEach((el) => observer.observe(el));\n    }, 100);\n  }\n\n  private navigateToSection(sectionId: 'editor' | 'results'): void {\n    const section = document.querySelector(`[data-section=\"${sectionId}\"]`);\n    if (section) {\n      section.scrollIntoView({\n        behavior: 'smooth',\n        block: 'start',\n      });\n    }\n  }\n\n  private navigateWithHighlight(sectionId: 'editor' | 'results'): void {\n    this.recentlyAnalyzed.set(true);\n    setTimeout(() => {\n      this.navigateToSection(sectionId);\n      setTimeout(() => this.recentlyAnalyzed.set(false), 2000);\n    }, 100);\n  }\n\n  private confirmClear(): boolean {\n    if (typeof window === 'undefined') return false;\n    return window.confirm('Clear all content? This cannot be undone.');\n  }\n\n  private async analyzeWithStages(formId: string, lines: string[]): Promise<void> {\n    this.loadingState.set('analyzing');\n\n    // Etapa 1: Syllables\n    this.currentStage.set('syllables');\n    this.toastService.info('Stage 1/3', 'Counting syllables...');\n    await this.delay(600);\n\n    // Etapa 2: Rhythm\n    this.currentStage.set('rhythm');\n    this.toastService.info('Stage 2/3', 'Analyzing rhythm...');\n    await this.delay(600);\n\n    // Etapa 3: Patterns\n    this.currentStage.set('patterns');\n    this.toastService.info('Stage 3/3', 'Detecting patterns...');\n    await this.delay(400);\n\n    // Ejecutar análisis real\n    await this.analyzer.analyze(formId, lines);\n\n    // Completar\n    this.currentStage.set(null);\n    this.loadingState.set('idle');\n    this.toastService.success('Analysis Complete', 'Check results below');\n    this.navigateWithHighlight('results');\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  onAppBarAction(actionId: string): void {\n    switch (actionId) {\n      case 'analyze':\n        this.handleAnalyze();\n        break;\n\n      case 'example':\n        this.handleLoadExample();\n        break;\n\n      case 'clear':\n        this.handleClear();\n        break;\n    }\n  }\n\n  private handleAnalyze(): void {\n    const text = this.analyzer.poemText();\n    const lines = text.split('\\n').filter((line) => line.trim().length > 0);\n\n    if (lines.length === 0) {\n      this.toastService.warning('Empty Poem', 'Write something first');\n      this.navigateToSection('editor');\n      return;\n    }\n\n    const formId = this.analyzer.selectedForm();\n    this.analyzeWithStages(formId, lines);\n  }\n\n  private handleLoadExample(): void {\n    this.loadingState.set('loading-example');\n    const formId = this.analyzer.selectedForm();\n\n    // Cargar ejemplo\n    this.analyzer.loadExample();\n\n    // Auto-analizar después de cargar\n    setTimeout(() => {\n      const lines = this.analyzer\n        .poemText()\n        .split('\\n')\n        .filter((line) => line.trim().length > 0);\n\n      if (lines.length > 0) {\n        this.analyzeWithStages(formId, lines);\n      }\n    }, 300);\n\n    this.toastService.success('Example Loaded', 'Analyzing automatically...');\n  }\n\n  private handleClear(): void {\n    const hasContent = this.analyzer.poemText().length > 0 || this.hasResults();\n\n    if (hasContent) {\n      if (this.confirmClear()) {\n        this.analyzer.clear();\n        this.loadingState.set('idle');\n        this.currentStage.set(null);\n        this.toastService.info('Cleared', 'Editor and results cleared');\n        this.navigateToSection('editor');\n      }\n    } else {\n      this.toastService.info('Already Empty', 'Nothing to clear');\n    }\n  }\n\n  // Análisis manual desde botón (no AppBar)\n  onAnalyze(): void {\n    this.handleAnalyze();\n  }\n\n  onAnalysisTabChange(tabId: string): void {\n    this.selectedAnalysisTab.set(tabId);\n  }\n\n  onWordSelected(word: string): void {\n    this.analyzer.selectWordEnhanced(word);\n  }\n\n  onReplaceWord(newWord: string): void {\n    const original = this.analyzer.wordAlternatives()?.original || '';\n    this.analyzer.replaceWord(original, newWord);\n    this.toastService.success('Word Replaced', `\"${original}\" → \"${newWord}\"`);\n  }\n\n  onCloseSuggestions(): void {\n    this.analyzer.selectWordEnhanced(null);\n  }\n\n  async onExportPoem(): Promise<void> {\n    const result = this.analyzer.result();\n    if (!result) return;\n\n    const poemText = result.lines.map((line) => line.text).join('\\n');\n    const formInfo = this.analyzer.selectedForm();\n    const exportText = `${formInfo.toUpperCase()} POEM\\n\\n${poemText}\\n\\n— Created with HarawiHark`;\n\n    try {\n      await navigator.clipboard.writeText(exportText);\n      this.toastService.success('Exported', 'Poem copied to clipboard');\n    } catch {\n      this.toastService.error('Export Failed', 'Could not copy to clipboard');\n    }\n  }\n\n  onAssessQuality(): void {\n    this.loadingState.set('assessing');\n    this.toastService.info('Quality Assessment', 'Analyzing poem quality...');\n\n    setTimeout(() => {\n      this.analyzer.assessQuality();\n      this.selectedAnalysisTab.set('quality');\n      this.loadingState.set('idle');\n      this.toastService.success('Assessment Complete', 'Quality metrics ready');\n    }, 800);\n  }\n\n  onShowMeterAnalysis(): void {\n    this.selectedAnalysisTab.set('rhythm');\n    this.toastService.info('Rhythm Analysis', 'Showing meter analysis...');\n  }\n\n  loadFormExample(formId: string): void {\n    this.analyzer.selectedForm.set(formId);\n    this.handleLoadExample();\n  }\n\n  getQuickStats() {\n    const stats = this.analyzer.getQuickStats();\n    return {\n      ...stats,\n      patternMatch: this.analyzer.isCompletePoem() ? 'Perfect' : 'Partial',\n    };\n  }\n\n  getFormPattern(formId: string): string {\n    const patterns: Record<string, string> = {\n      haiku: '5-7-5',\n      tanka: '5-7-5-7-7',\n      cinquain: '2-4-6-8-2',\n      limerick: '8-8-5-5-8',\n      redondilla: '8-8-8-8',\n      lanterne: '1-2-3-4-1',\n      diamante: '1-2-3-4-3-2-1',\n      fibonacci: '1-1-2-3-5-8',\n    };\n    return patterns[formId] || '';\n  }\n\n  onQuickNav(section: 'editor' | 'results'): void {\n    this.navigateToSection(section);\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 74
            },
            "extends": [],
            "templateData": "<div class=\"poetry-page\" [class.results-highlight]=\"recentlyAnalyzed()\">\n  <!-- Toast Notifications -->\n  <app-toast-container />\n\n  <!-- Header -->\n  <app-header />\n\n  <!-- Navegación rápida flotante (solo mobile) -->\n  <div class=\"quick-nav-buttons\">\n    <button\n      class=\"nav-pill\"\n      [class.active]=\"currentSection() === 'editor'\"\n      (click)=\"onQuickNav('editor')\"\n      aria-label=\"Go to editor\"\n    >\n      <span class=\"icon-[iconoir--edit-pencil]\"></span>\n      <span>editor</span>\n    </button>\n\n    <button\n      class=\"nav-pill\"\n      [class.active]=\"currentSection() === 'results'\"\n      [disabled]=\"!hasResults()\"\n      (click)=\"onQuickNav('results')\"\n      aria-label=\"Go to results\"\n    >\n      <span class=\"icon-[iconoir--page-search]\"></span>\n      <span>results</span>\n    </button>\n  </div>\n\n  <!-- Panorama: Secciones Principales -->\n  <app-panorama>\n    <!-- SECTION: Editor -->\n    <div data-section=\"editor\">\n      <div class=\"section-content\">\n        <!-- Editor -->\n        <app-poem-editor />\n\n        <!-- Word Suggestions -->\n        @if (analyzer.wordAlternatives(); as alternatives) {\n          <div class=\"suggestions-wrapper\">\n            <app-word-suggestions\n              [data]=\"alternatives\"\n              (replaceWord)=\"onReplaceWord($event)\"\n              (closeSuggestions)=\"onCloseSuggestions()\"\n            />\n          </div>\n        }\n\n        <!-- Info Section -->\n        <div class=\"info-section\">\n          <div class=\"info-content\">\n            <span class=\"icon-[iconoir--light-bulb] info-icon\"></span>\n            <div class=\"info-text\">\n              <h4 class=\"info-title\">how it works</h4>\n              <p class=\"info-description\">\n                Harawihark uses advanced phonetic analysis to count syllables accurately, detect\n                rhyme schemes, and provide intelligent suggestions.\n              </p>\n              <ul class=\"info-features\">\n                <li>\n                  <span class=\"icon-[iconoir--sound-high] feature-icon\"></span>\n                  Real-time syllable counting with RiTa.js\n                </li>\n                <li>\n                  <span class=\"icon-[iconoir--music-note] feature-icon\"></span>\n                  Advanced meter analysis (iambic, trochaic, etc.)\n                </li>\n                <li>\n                  <span class=\"icon-[iconoir--star] feature-icon\"></span>\n                  Quality assessment with detailed metrics\n                </li>\n                <li>\n                  <span class=\"icon-[iconoir--book-stack] feature-icon\"></span>\n                  8 different poetic forms supported\n                </li>\n              </ul>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- SECTION: Results -->\n    <div data-section=\"results\" [class.section-highlight]=\"recentlyAnalyzed()\">\n      <div class=\"section-content\">\n        @if (hasResults()) {\n          <!-- States de loading con etapas -->\n          @if (isAnalyzing()) {\n            <app-card padding=\"large\">\n              <div class=\"analysis-loading\">\n                <div class=\"analysis-stages\">\n                  <div class=\"stage\" [class.active]=\"currentStage() === 'syllables'\">\n                    <span class=\"icon-[iconoir--sound-high] stage-icon\"></span>\n                    <span class=\"stage-label\">counting syllables</span>\n                    @if (currentStage() === 'syllables') {\n                      <app-progress type=\"bar\" />\n                    }\n                  </div>\n\n                  <div class=\"stage\" [class.active]=\"currentStage() === 'rhythm'\">\n                    <span class=\"icon-[iconoir--music-note] stage-icon\"></span>\n                    <span class=\"stage-label\">analyzing rhythm</span>\n                    @if (currentStage() === 'rhythm') {\n                      <app-progress type=\"bar\" />\n                    }\n                  </div>\n\n                  <div class=\"stage\" [class.active]=\"currentStage() === 'patterns'\">\n                    <span class=\"icon-[iconoir--sparks] stage-icon\"></span>\n                    <span class=\"stage-label\">detecting patterns</span>\n                    @if (currentStage() === 'patterns') {\n                      <app-progress type=\"bar\" />\n                    }\n                  </div>\n                </div>\n              </div>\n            </app-card>\n          } @else {\n            <!-- Pivot Tabs -->\n            <app-pivot\n              [items]=\"analysisTabs()\"\n              [selectedId]=\"selectedAnalysisTab()\"\n              (selectedChange)=\"onAnalysisTabChange($event)\"\n            />\n\n            <!-- Analysis Content -->\n            <div class=\"analysis-content\">\n              @switch (selectedAnalysisTab()) {\n                @case ('structure') {\n                  <app-poem-results\n                    [result]=\"analyzer.result()!\"\n                    (wordSelected)=\"onWordSelected($event)\"\n                  />\n                }\n                @case ('rhythm') {\n                  <app-meter-analysis-section [result]=\"analyzer.result()!\" />\n                }\n                @case ('quality') {\n                  @if (analyzer.qualityMetrics()) {\n                    <app-poem-quality [metrics]=\"analyzer.qualityMetrics()!\" />\n                  } @else {\n                    <app-card padding=\"large\">\n                      <div class=\"quality-prompt\">\n                        <span class=\"icon-[iconoir--star] text-4xl mb-4\"></span>\n                        <p class=\"text-base mb-6 text-onSurfaceVariant\">\n                          Click \"Assess Quality\" to see detailed quality metrics\n                        </p>\n                        <app-button\n                          variant=\"primary\"\n                          label=\"assess quality\"\n                          icon=\"icon-[iconoir--star]\"\n                          (clicked)=\"onAssessQuality()\"\n                        />\n                      </div>\n                    </app-card>\n                  }\n                }\n                @case ('stats') {\n                  <app-quick-stats-panel [stats]=\"getQuickStats()\" />\n                }\n              }\n            </div>\n\n            <!-- Analysis Actions -->\n            <div class=\"analysis-actions\">\n              <app-button\n                variant=\"primary\"\n                label=\"assess quality\"\n                icon=\"icon-[iconoir--star]\"\n                (clicked)=\"onAssessQuality()\"\n              />\n              <app-button\n                variant=\"outline\"\n                label=\"analyze rhythm\"\n                icon=\"icon-[iconoir--music-note]\"\n                (clicked)=\"onShowMeterAnalysis()\"\n              />\n              <app-button\n                variant=\"outline\"\n                label=\"export poem\"\n                icon=\"icon-[iconoir--cloud-download]\"\n                (clicked)=\"onExportPoem()\"\n              />\n            </div>\n          }\n        } @else {\n          <!-- Empty State Mejorado -->\n          <app-card padding=\"large\">\n            <div class=\"empty-state-rich\">\n              <span class=\"icon-[iconoir--flower] empty-icon\"></span>\n              <h3 class=\"empty-title\">ready to analyze poetry</h3>\n              <p class=\"empty-description\">\n                Write your poem in the editor or load an example to see analysis\n              </p>\n\n              <div class=\"forms-showcase\">\n                <h4 class=\"forms-title\">try these poetic forms:</h4>\n                <div class=\"forms-grid\">\n                  <button class=\"form-card\" (click)=\"loadFormExample('haiku')\">\n                    <span class=\"form-name\">haiku</span>\n                    <span class=\"form-pattern\">5-7-5</span>\n                  </button>\n\n                  <button class=\"form-card\" (click)=\"loadFormExample('tanka')\">\n                    <span class=\"form-name\">tanka</span>\n                    <span class=\"form-pattern\">5-7-5-7-7</span>\n                  </button>\n\n                  <button class=\"form-card\" (click)=\"loadFormExample('limerick')\">\n                    <span class=\"form-name\">limerick</span>\n                    <span class=\"form-pattern\">8-8-5-5-8</span>\n                  </button>\n\n                  <button class=\"form-card\" (click)=\"loadFormExample('cinquain')\">\n                    <span class=\"form-name\">cinquain</span>\n                    <span class=\"form-pattern\">2-4-6-8-2</span>\n                  </button>\n                </div>\n              </div>\n            </div>\n          </app-card>\n        }\n      </div>\n    </div>\n  </app-panorama>\n\n  <!-- Footer -->\n  <app-footer />\n\n  <!-- AppBar (Solo visible en mobile) -->\n  <app-appbar\n    class=\"lg:hidden\"\n    [actions]=\"appBarActions\"\n    (actionClick)=\"onAppBarAction($event)\"\n  />\n</div>"
        },
        {
            "name": "ProgressComponent",
            "id": "component-ProgressComponent-456b1d8c5f9380c844ad1414b11a3d3b6dc90cfb72d4fc519de9d797330a4286424832f250afd30637e7f6091183752c51bcdfe73dea94aeb0e616e98d2c435f",
            "file": "src/app/components/metro/progress/progress.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-progress",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./progress.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 14,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "type",
                    "defaultValue": "'bar'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 12,
                    "type": "\"bar\" | \"ring\"",
                    "decorators": []
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 13,
                    "type": "number",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-progress',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './progress.component.html',\n})\nexport class ProgressComponent {\n  @Input() type: 'bar' | 'ring' = 'bar';\n  @Input() value?: number;\n  @Input() label?: string;\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<!-- progress.component.html -->\n@if (type === 'bar') {\n  <div class=\"metro-progress-with-label\">\n    @if (label) {\n      <div class=\"metro-progress-label\">\n        <span>{{ label }}</span>\n        @if (value !== undefined) {\n          <span class=\"metro-progress-value\">{{ value }}%</span>\n        }\n      </div>\n    }\n    \n    @if (value !== undefined) {\n      <div class=\"metro-progress\">\n        <div \n          class=\"metro-progress-bar\" \n          [style.width.%]=\"value\"\n        ></div>\n      </div>\n    } @else {\n      <div class=\"metro-progress-indeterminate\"></div>\n    }\n  </div>\n}\n\n@if (type === 'ring') {\n  <div class=\"metro-progress-ring\"></div>\n}"
        },
        {
            "name": "QuickStatsPanelComponent",
            "id": "component-QuickStatsPanelComponent-3f49d7f8281c5927dfb1d212c11ba1d8a512667d01e0a77670a5f5e4d23d74709367137484311992e8105bfe5030b3147ac178d701edea0396acf24cd86cab32",
            "file": "src/app/components/poetry/quick-stats-panel/quick-stats-panel.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-quick-stats-panel",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./quick-stats-panel.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "required": true,
                    "name": "stats",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "optional": false,
                    "line": 18,
                    "type": "QuickStats",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CardComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CardComponent } from '../../ui';\n\nexport interface QuickStats {\n  totalSyllables: number;\n  avgSyllablesPerLine: number;\n  vocabularyRichness: number;\n  patternMatch: string;\n}\n\n@Component({\n  selector: 'app-quick-stats-panel',\n  standalone: true,\n  imports: [CardComponent],\n  templateUrl: './quick-stats-panel.component.html',\n})\nexport class QuickStatsPanelComponent {\n  @Input({ required: true }) stats!: QuickStats;\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card padding=\"medium\">\n  <div class=\"stats-container\">\n    <h3 class=\"stats-title\">quick stats</h3>\n    \n    <div class=\"stats-grid\">\n      <div class=\"stat-item\">\n        <div class=\"stat-icon\">\n          <span class=\"icon-[iconoir--sound-high]\"></span>\n        </div>\n        <div class=\"stat-content\">\n          <span class=\"stat-value\">{{ stats.totalSyllables }}</span>\n          <span class=\"stat-label\">total syllables</span>\n        </div>\n      </div>\n      \n      <div class=\"stat-item\">\n        <div class=\"stat-icon\">\n          <span class=\"icon-[iconoir--layout-left]\"></span>\n        </div>\n        <div class=\"stat-content\">\n          <span class=\"stat-value\">{{ stats.avgSyllablesPerLine }}</span>\n          <span class=\"stat-label\">avg per line</span>\n        </div>\n      </div>\n      \n      <div class=\"stat-item\">\n        <div class=\"stat-icon\">\n          <span class=\"icon-[iconoir--book-stack]\"></span>\n        </div>\n        <div class=\"stat-content\">\n          <span class=\"stat-value\">{{ stats.vocabularyRichness }}%</span>\n          <span class=\"stat-label\">vocabulary richness</span>\n        </div>\n      </div>\n      \n      <div class=\"stat-item\">\n        <div class=\"stat-icon\">\n          <span class=\"icon-[iconoir--check]\"></span>\n        </div>\n        <div class=\"stat-content\">\n          <span class=\"stat-value\">{{ stats.patternMatch }}</span>\n          <span class=\"stat-label\">pattern match</span>\n        </div>\n      </div>\n    </div>\n  </div>\n</app-card>"
        },
        {
            "name": "SelectComponent",
            "id": "component-SelectComponent-3d3b3a668c59b4c80e2beae9f494be39347e4d0b0c447b11b5aa7a9376f4e3b82c1289dffb65c84d1a0aa2f0974374d1df99eeaabcb1fbf2257e6342344964ef",
            "file": "src/app/components/ui/select/select.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [
                {
                    "name": ")"
                }
            ],
            "selector": "app-select",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./select.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "disabled",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 25,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "id",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 26,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "label",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 24,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "options",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 23,
                    "type": "SelectOption[]",
                    "decorators": []
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 29,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "selectChange",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 39,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "_value",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 37
                },
                {
                    "name": "onChange",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 41,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "onTouched",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 44,
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "onBlur",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 71,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onSelectChange",
                    "args": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 64,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnChange",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "string",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ]
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 52,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "string",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnTouched",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": []
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 56,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setDisabledState",
                    "args": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 60,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "writeValue",
                    "args": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 48,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter, forwardRef } from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\n\nexport interface SelectOption {\n  value: string;\n  label: string;\n  description?: string;\n}\n\n@Component({\n  selector: 'app-select',\n  standalone: true,\n  templateUrl: './select.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => SelectComponent),\n      multi: true,\n    },\n  ],\n})\nexport class SelectComponent implements ControlValueAccessor {\n  @Input() options: SelectOption[] = [];\n  @Input() label = '';\n  @Input() disabled = false;\n  @Input() id = '';\n\n  @Input()\n  get value(): string {\n    return this._value;\n  }\n  set value(val: string) {\n    this._value = val || '';\n    this.onChange(this._value);\n  }\n\n  _value = '';\n\n  @Output() selectChange = new EventEmitter<string>();\n\n  private onChange: (value: string) => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private onTouched: () => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n\n  writeValue(value: string): void {\n    this._value = value || '';\n  }\n\n  registerOnChange(fn: (value: string) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  onSelectChange(event: Event): void {\n    const target = event.target as HTMLSelectElement;\n    this._value = target.value;\n    this.onChange(this._value);\n    this.selectChange.emit(this._value);\n  }\n\n  onBlur(): void {\n    this.onTouched();\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "implements": [
                "ControlValueAccessor"
            ],
            "accessors": {
                "value": {
                    "name": "value",
                    "setSignature": {
                        "name": "value",
                        "type": "void",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "args": [
                            {
                                "name": "val",
                                "type": "string",
                                "deprecated": false,
                                "deprecationMessage": ""
                            }
                        ],
                        "returnType": "void",
                        "line": 32,
                        "jsdoctags": [
                            {
                                "name": "val",
                                "type": "string",
                                "deprecated": false,
                                "deprecationMessage": "",
                                "tagName": {
                                    "text": "param"
                                }
                            }
                        ]
                    },
                    "getSignature": {
                        "name": "value",
                        "type": "string",
                        "returnType": "string",
                        "line": 29
                    }
                }
            },
            "templateData": "<div class=\"select-wrapper\">\n  @if (label) {\n    <label class=\"select-label\" [for]=\"id\">{{ label }}</label>\n  }\n\n  <select\n    class=\"select-base\"\n    [id]=\"id\"\n    [disabled]=\"disabled\"\n    [value]=\"_value\"\n    (change)=\"onSelectChange($event)\"\n    (blur)=\"onBlur()\"\n  >\n    <option value=\"\" disabled>select an option</option>\n    @for (option of options; track option.value) {\n      <option [value]=\"option.value\">\n        {{ option.label }}\n        @if (option.description) {\n          - {{ option.description }}\n        }\n      </option>\n    }\n  </select>\n\n  <span class=\"icon-[iconoir--nav-arrow-down] select-icon\"></span>\n</div>\n"
        },
        {
            "name": "ThemeToggleComponent",
            "id": "component-ThemeToggleComponent-612079ca484cbdbffe4bb0317cd8dd9527f7fe976f4d58475dd5581a53e8122339061d89bed37473e7938c6a2b3a7dd8f56a43eb5db7b91bdd9a44f1599333d2",
            "file": "src/app/components/theme-toggle/theme-toggle.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-theme-toggle",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./theme-toggle.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "currentTheme",
                    "defaultValue": "this.themeService.currentTheme",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 13,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "themeService",
                    "defaultValue": "inject(ThemeService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 12,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "onThemeChange",
                    "args": [
                        {
                            "name": "isDark",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 15,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "isDark",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "ToggleComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, inject } from '@angular/core';\nimport { ToggleComponent } from '../metro';\nimport { ThemeService } from '../../services/';\n\n@Component({\n  selector: 'app-theme-toggle',\n  standalone: true,\n  imports: [ToggleComponent],\n  templateUrl: './theme-toggle.component.html',\n})\nexport class ThemeToggleComponent {\n  private readonly themeService = inject(ThemeService);\n  protected readonly currentTheme = this.themeService.currentTheme;\n\n  onThemeChange(isDark: boolean): void {\n    this.themeService.setTheme(isDark ? 'dark' : 'light');\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-toggle \n  [id]=\"'theme-toggle'\" \n  [checked]=\"currentTheme() === 'dark'\" \n  (checkedChange)=\"onThemeChange($event)\"\n  class=\"theme-toggle-wrapper\">\n  <span slot=\"before\" class=\"theme-icon\">\n    @if (currentTheme() === 'light') {\n      <span class=\"icon-[iconoir--sun-light]\"></span>\n    } @else {\n      <span class=\"icon-[iconoir--moon-sat]\"></span>\n    }\n  </span>\n</app-toggle>"
        },
        {
            "name": "ToastContainerComponent",
            "id": "component-ToastContainerComponent-773f7efb38754684bf410cc697f405a37250b22aec2c4e0bf2c81e6d8711cc3bde96e81c6373d9258807e7b5e3f71094d1adf800dab37d81aa5413a0aca979c2",
            "file": "src/app/components/metro/toast-container/toast-container.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-toast-container",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./toast-container.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "toastService",
                    "defaultValue": "inject(ToastService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 13,
                    "modifierKind": [
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "getIcon",
                    "args": [
                        {
                            "name": "type",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 15,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "type",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onClose",
                    "args": [
                        {
                            "name": "id",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 25,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, inject } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ToastService } from '../../../services/core/toast.service';\n\n@Component({\n  selector: 'app-toast-container',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './toast-container.component.html',\n})\nexport class ToastContainerComponent {\n  readonly toastService = inject(ToastService);\n\n  getIcon(type: string): string {\n    const icons = {\n      info: 'icon-[iconoir--info-circle]',\n      success: 'icon-[iconoir--check-circle]',\n      warning: 'icon-[iconoir--warning-triangle]',\n      error: 'icon-[iconoir--cancel]',\n    };\n    return icons[type as keyof typeof icons] || icons.info;\n  }\n\n  onClose(id: string): void {\n    this.toastService.remove(id);\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<!-- toast-container.component.html -->\n<div class=\"metro-toast-container\">\n  @for (toast of toastService.toasts(); track toast.id) {\n    <div \n      class=\"metro-toast\"\n      [class]=\"'metro-toast-' + toast.type\"\n      role=\"alert\"\n    >\n      <span [class]=\"getIcon(toast.type) + ' metro-toast-icon'\"></span>\n      \n      <div class=\"metro-toast-content\">\n        <div class=\"metro-toast-title\">{{ toast.title }}</div>\n        @if (toast.message) {\n          <div class=\"metro-toast-message\">{{ toast.message }}</div>\n        }\n      </div>\n\n      <button\n        type=\"button\"\n        class=\"metro-toast-close\"\n        (click)=\"onClose(toast.id)\"\n        aria-label=\"Close notification\"\n      >\n        <span class=\"icon-[iconoir--cancel]\"></span>\n      </button>\n    </div>\n  }\n</div>"
        },
        {
            "name": "ToggleComponent",
            "id": "component-ToggleComponent-b9439d5dc3d4755ad7b8b2849417db53bea8cb00045726e5eff5f5a18fe103748adb32a18b7c3b65fec06a03199b62c98aba2b9c68d37e2009587625ac7f650c",
            "file": "src/app/components/metro/toggle/toggle.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [
                {
                    "name": ")"
                }
            ],
            "selector": "app-toggle",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./toggle.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "checked",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 23,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "disabled",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 22,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "id",
                    "defaultValue": "`toggle-${crypto.randomUUID()}`",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 20,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 21,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "checkedChange",
                    "defaultValue": "new EventEmitter<boolean>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 24,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "onChange",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 26,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "onTouched",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 29,
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "onToggle",
                    "args": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 33,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnChange",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "boolean",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ]
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 45,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "boolean",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnTouched",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": []
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 49,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setDisabledState",
                    "args": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 53,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "writeValue",
                    "args": [
                        {
                            "name": "value",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 41,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter, forwardRef } from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-toggle',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './toggle.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => ToggleComponent),\n      multi: true,\n    },\n  ],\n})\nexport class ToggleComponent implements ControlValueAccessor {\n  @Input() id = `toggle-${crypto.randomUUID()}`;\n  @Input() label?: string;\n  @Input() disabled = false;\n  @Input() checked = false;\n  @Output() checkedChange = new EventEmitter<boolean>();\n\n  private onChange: (value: boolean) => void = () => {\n    // Método requerido por ControlValueAccessor\n  };\n  private onTouched: () => void = () => {\n    // Método requerido por ControlValueAccessor\n  };\n\n  onToggle(event: Event): void {\n    const target = event.target as HTMLInputElement;\n    this.checked = target.checked;\n    this.onChange(this.checked);\n    this.onTouched();\n    this.checkedChange.emit(this.checked);\n  }\n\n  writeValue(value: boolean): void {\n    this.checked = value;\n  }\n\n  registerOnChange(fn: (value: boolean) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "implements": [
                "ControlValueAccessor"
            ],
            "templateData": "<!-- toggle.component.html -->\n<div class=\"metro-toggle-wrapper\">\n  <input\n    type=\"checkbox\"\n    class=\"metro-toggle-input\"\n    [id]=\"id\"\n    [checked]=\"checked\"\n    [disabled]=\"disabled\"\n    (change)=\"onToggle($event)\"\n  />\n  <label [for]=\"id\" class=\"metro-toggle\">\n    <span class=\"metro-toggle-slider\"></span>\n  </label>\n  @if (label) {\n    <label [for]=\"id\" class=\"metro-toggle-label\">{{ label }}</label>\n  }\n</div>"
        },
        {
            "name": "TooltipComponent",
            "id": "component-TooltipComponent-592c1dbb983d59c443eec14b1ca96e74c56c798f0b264a481c137734bb7f0f06d4735f9ed940cbd49f7ad6678d2ba42f2243ba137c2dce9651f5e0656e08db07",
            "file": "src/app/components/ui/tooltip/tooltip.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-tooltip",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./tooltip.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "position",
                    "defaultValue": "'top'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 10,
                    "type": "\"top\" | \"bottom\" | \"left\" | \"right\"",
                    "decorators": []
                },
                {
                    "name": "text",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 9,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-tooltip',\n  standalone: true,\n  templateUrl: './tooltip.component.html',\n})\nexport class TooltipComponent {\n  @Input() text = '';\n  @Input() position: 'top' | 'bottom' | 'left' | 'right' = 'top';\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<div class=\"metro-tooltip\" [class]=\"'tooltip-' + position\">\n  <ng-content />\n  <div class=\"tooltip-content\">\n    {{ text }}\n  </div>\n</div>"
        },
        {
            "name": "WordSuggestionsComponent",
            "id": "component-WordSuggestionsComponent-976d3bb4e3d82fdcce147b62ea95aaf8ad8297d476d99e4d0c73805ed5732c841f6d2897392c4a5e62cea2c00142f1669e12778164e18728a6401dd66adf40b0",
            "file": "src/app/components/poetry/word-suggestions/word-suggestions.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-word-suggestions",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./word-suggestions.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "required": true,
                    "name": "data",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "optional": false,
                    "line": 14,
                    "type": "WordSuggestionData",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "closeSuggestions",
                    "defaultValue": "new EventEmitter<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 16,
                    "type": "EventEmitter"
                },
                {
                    "name": "replaceWord",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 15,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "utils",
                    "defaultValue": "inject(UtilsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 12,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "getPosLabel",
                    "args": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 36,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getReasonLabel",
                    "args": [
                        {
                            "name": "reason",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 18,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "reason",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getReasonVariant",
                    "args": [
                        {
                            "name": "reason",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "\"success\" | \"info\" | \"default\"",
                    "typeParameters": [],
                    "line": 30,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "reason",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onReplaceWord",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 40,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "BadgeComponent",
                    "type": "component"
                },
                {
                    "name": "ButtonComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter, inject } from '@angular/core';\nimport { CardComponent, BadgeComponent, ButtonComponent } from '../../ui';\nimport { UtilsService, WordSuggestionData } from '../../../services';\n\n@Component({\n  selector: 'app-word-suggestions',\n  standalone: true,\n  imports: [CardComponent, BadgeComponent, ButtonComponent],\n  templateUrl: './word-suggestions.component.html',\n})\nexport class WordSuggestionsComponent {\n  private readonly utils = inject(UtilsService);\n\n  @Input({ required: true }) data!: WordSuggestionData;\n  @Output() replaceWord = new EventEmitter<string>();\n  @Output() closeSuggestions = new EventEmitter<void>();\n\n  getReasonLabel(reason: string): string {\n    const labels: Record<string, string> = {\n      'exact-match': 'exact syllables',\n      'rhyme-match': 'rhymes with original',\n      'sound-match': 'similar sound',\n      'semantic-rhyme': 'semantic rhyme',\n      'spelling-match': 'spelling match',\n      morphological: 'morphological variant',\n    };\n    return labels[reason] || reason;\n  }\n\n  getReasonVariant(reason: string): 'success' | 'info' | 'default' {\n    if (reason === 'exact-match') return 'success';\n    if (reason === 'rhyme-match' || reason === 'semantic-rhyme') return 'info';\n    return 'default';\n  }\n\n  getPosLabel(pos: string): string {\n    return this.utils.getPosLabel(pos);\n  }\n\n  onReplaceWord(word: string): void {\n    this.replaceWord.emit(word);\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card padding=\"large\">\n  <div class=\"suggestions-container\">\n    <!-- Header -->\n    <div class=\"suggestions-header\">\n      <div>\n        <h3 class=\"suggestions-title\">suggestions for \"{{ data.original }}\"</h3>\n        <p class=\"suggestions-subtitle\">\n          needs {{ data.targetSyllables }} syllable{{ data.targetSyllables !== 1 ? 's' : '' }}\n          (currently {{ data.currentSyllables }})\n        </p>\n      </div>\n      <button\n        type=\"button\"\n        class=\"close-button\"\n        (click)=\"closeSuggestions.emit()\"\n        aria-label=\"Close suggestions\"\n      >\n        <span class=\"icon-[iconoir--cancel] close-icon\"></span>\n      </button>\n    </div>\n\n    <!-- Alternatives List -->\n    @if (data.alternatives.length > 0) {\n      <div class=\"alternatives-list\">\n        @for (alt of data.alternatives; track alt.word) {\n          <div class=\"alternative-item\">\n            <div class=\"alternative-content\">\n              <div class=\"alternative-main\">\n                <span class=\"alternative-word\">{{ alt.word }}</span>\n                <app-badge\n                  [variant]=\"getReasonVariant(alt.reason)\"\n                  size=\"small\"\n                >\n                  {{ getReasonLabel(alt.reason) }}\n                </app-badge>\n              </div>\n              <div class=\"alternative-meta\">\n                <span class=\"syllable-count\">\n                  <span class=\"icon-[iconoir--sound-high] syllable-icon\"></span>\n                  {{ alt.syllables }} syllable{{ alt.syllables !== 1 ? 's' : '' }}\n                </span>\n                @if (alt.pos) {\n                  <span class=\"pos-tag\">{{ getPosLabel(alt.pos) }}</span>\n                }\n              </div>\n            </div>\n            <app-button\n              variant=\"outline\"\n              size=\"small\"\n              label=\"use\"\n              icon=\"icon-[iconoir--check]\"\n              (clicked)=\"onReplaceWord(alt.word)\"\n            />\n          </div>\n        }\n      </div>\n    } @else {\n      <div class=\"no-alternatives\">\n        <span class=\"icon-[iconoir--search] no-alternatives-icon\"></span>\n        <p class=\"no-alternatives-text\">\n          No alternatives found with {{ data.targetSyllables }} syllables\n        </p>\n      </div>\n    }\n  </div>\n</app-card>"
        }
    ],
    "modules": [],
    "miscellaneous": {
        "variables": [
            {
                "name": "ALL_CSS_VARS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "[]",
                "defaultValue": "[...THEME_CSS_VARS, ...TERMINAL_CSS_VARS]"
            },
            {
                "name": "appConfig",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/app.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "ApplicationConfig",
                "defaultValue": "{\n  providers: [\n    provideBrowserGlobalErrorListeners(),\n    provideZoneChangeDetection({ eventCoalescing: true }),\n    provideRouter(routes),\n  ],\n}"
            },
            {
                "name": "outputDir",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/cli.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "string",
                "defaultValue": "'src/styles'"
            },
            {
                "name": "POETRY_EXAMPLES",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/data/poetry-forms.data.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Record<string, string[]>",
                "defaultValue": "{\n  haiku: ['an old silent pond', 'a frog jumps into the pond', 'splash! silence again'],\n  tanka: [\n    'the falling flower',\n    'i saw drift back to the branch',\n    'was a butterfly',\n    'dancing in the gentle breeze',\n    \"nature's art in motion\",\n  ],\n  cinquain: [\n    'moon',\n    'silent light',\n    'casting silver shadows',\n    'illuminating the dark night',\n    'peace',\n  ],\n  limerick: [\n    'there once was a coder so bright',\n    'who worked on his app every night',\n    'with angular and code',\n    'he built a fine node',\n    \"and launched it to everyone's delight\",\n  ],\n  redondilla: [\n    'in fields of green and gold so bright',\n    'where flowers dance in morning light',\n    'the world awakens from the night',\n    'and fills my heart with pure delight',\n  ],\n  lanterne: ['moon', 'bright glow', 'silver light', 'shining through night', 'peace'],\n  diamante: [\n    'day',\n    'bright warm',\n    'shining glowing heating',\n    'sunrise sunset twilight darkness',\n    'cooling dimming fading',\n    'cold dark',\n    'night',\n  ],\n  fibonacci: ['I', 'am', 'writing', 'syllables', 'in fibonacci', 'a mathematical poetry sequence'],\n}"
            },
            {
                "name": "POETRY_FORM_OPTIONS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/data/poetry-forms.data.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "Object.values(POETRY_FORMS).map((form) => ({\n  value: form.id,\n  label: form.name,\n  description: form.pattern.join('-'),\n}))"
            },
            {
                "name": "POETRY_FORMS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/data/poetry-forms.data.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Record<string, PoetryForm>",
                "defaultValue": "{\n  haiku: {\n    id: 'haiku',\n    name: 'haiku',\n    pattern: [5, 7, 5],\n    lines: 3,\n    origin: 'japanese',\n    description: 'traditional nature poem with 3 lines',\n  },\n  tanka: {\n    id: 'tanka',\n    name: 'tanka',\n    pattern: [5, 7, 5, 7, 7],\n    lines: 5,\n    origin: 'japanese',\n    description: 'extended court poetry with 5 lines',\n  },\n  cinquain: {\n    id: 'cinquain',\n    name: 'cinquain',\n    pattern: [2, 4, 6, 8, 2],\n    lines: 5,\n    origin: 'american',\n    description: 'didactic poem with ascending/descending pattern',\n  },\n  limerick: {\n    id: 'limerick',\n    name: 'limerick',\n    pattern: [8, 8, 5, 5, 8],\n    lines: 5,\n    origin: 'english',\n    description: 'humorous poem with AABBA rhyme scheme',\n  },\n  redondilla: {\n    id: 'redondilla',\n    name: 'redondilla',\n    pattern: [8, 8, 8, 8],\n    lines: 4,\n    origin: 'spanish',\n    description: 'quatrain with consonant rhyme',\n  },\n  lanterne: {\n    id: 'lanterne',\n    name: 'lanterne',\n    pattern: [1, 2, 3, 4, 1],\n    lines: 5,\n    origin: 'japanese-inspired',\n    description: 'lantern-shaped syllabic poem',\n  },\n  diamante: {\n    id: 'diamante',\n    name: 'diamante',\n    pattern: [1, 2, 3, 4, 3, 2, 1],\n    lines: 7,\n    origin: 'modern',\n    description: 'diamond-shaped contrast poem',\n  },\n  fibonacci: {\n    id: 'fibonacci',\n    name: 'fibonacci',\n    pattern: [1, 1, 2, 3, 5, 8],\n    lines: 6,\n    origin: 'mathematical',\n    description: 'follows fibonacci sequence',\n  },\n}"
            },
            {
                "name": "root",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/cli.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "process.cwd()"
            },
            {
                "name": "routes",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/app.routes.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Routes",
                "defaultValue": "[]"
            },
            {
                "name": "SCHEMES",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "literal type[]",
                "defaultValue": "[\n  { name: 'tonal-spot', variant: SchemeTonalSpot },\n  { name: 'neutral', variant: SchemeNeutral },\n  { name: 'vibrant', variant: SchemeVibrant },\n  { name: 'expressive', variant: SchemeExpressive },\n  { name: 'monochrome', variant: SchemeMonochrome },\n  { name: 'content', variant: SchemeContent },\n  { name: 'fidelity', variant: SchemeFidelity },\n  { name: 'fruit-salad', variant: SchemeFruitSalad },\n  { name: 'rainbow', variant: SchemeRainbow },\n]"
            },
            {
                "name": "SEED_COLOR",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "string",
                "defaultValue": "'#F4C2C2'"
            },
            {
                "name": "SELECTED_SCHEME",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "string",
                "defaultValue": "'fidelity'"
            },
            {
                "name": "TERMINAL_COLORS_CONFIG",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "object",
                "defaultValue": "{\n  red: { hue: 10, chroma: 84, tone: 50 },\n  green: { hue: 145, chroma: 48, tone: 50 },\n  yellow: { hue: 90, chroma: 70, tone: 60 },\n  blue: { hue: 245, chroma: 80, tone: 50 },\n  magenta: { hue: 330, chroma: 68, tone: 50 },\n  cyan: { hue: 200, chroma: 48, tone: 50 },\n}"
            },
            {
                "name": "TERMINAL_CSS_VARS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "[]",
                "defaultValue": "[\n  'red',\n  'redContainer',\n  'onRedContainer',\n  'green',\n  'greenContainer',\n  'onGreenContainer',\n  'yellow',\n  'yellowContainer',\n  'onYellowContainer',\n  'blue',\n  'blueContainer',\n  'onBlueContainer',\n  'magenta',\n  'magentaContainer',\n  'onMagentaContainer',\n  'cyan',\n  'cyanContainer',\n  'onCyanContainer',\n\n  'inverseRed',\n  'inverseRedContainer',\n  'inverseOnRedContainer',\n  'inverseGreen',\n  'inverseGreenContainer',\n  'inverseOnGreenContainer',\n  'inverseYellow',\n  'inverseYellowContainer',\n  'inverseOnYellowContainer',\n  'inverseBlue',\n  'inverseBlueContainer',\n  'inverseOnBlueContainer',\n  'inverseMagenta',\n  'inverseMagentaContainer',\n  'inverseOnMagentaContainer',\n  'inverseCyan',\n  'inverseCyanContainer',\n  'inverseOnCyanContainer',\n]"
            },
            {
                "name": "THEME_CONFIG",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "object",
                "defaultValue": "{\n  seedColor: SEED_COLOR,\n  selectedScheme: SELECTED_SCHEME,\n  availableSchemes: SCHEMES.map((s) => s.name),\n  materialVariables: THEME_CSS_VARS.length,\n  terminalVariables: TERMINAL_CSS_VARS.length,\n  totalVariables: ALL_CSS_VARS.length,\n}"
            },
            {
                "name": "THEME_CSS_VARS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "[]",
                "defaultValue": "[\n  'primary',\n  'onPrimary',\n  'primaryContainer',\n  'onPrimaryContainer',\n  'secondary',\n  'onSecondary',\n  'secondaryContainer',\n  'onSecondaryContainer',\n  'tertiary',\n  'onTertiary',\n  'tertiaryContainer',\n  'onTertiaryContainer',\n  'error',\n  'onError',\n  'errorContainer',\n  'onErrorContainer',\n  'background',\n  'onBackground',\n  'surface',\n  'surfaceDim',\n  'surfaceBright',\n  'surfaceContainerLowest',\n  'surfaceContainerLow',\n  'surfaceContainer',\n  'surfaceContainerHigh',\n  'surfaceContainerHighest',\n  'onSurface',\n  'surfaceVariant',\n  'onSurfaceVariant',\n  'outline',\n  'outlineVariant',\n  'shadow',\n  'scrim',\n  'inverseSurface',\n  'inverseOnSurface',\n  'inversePrimary',\n]"
            }
        ],
        "functions": [
            {
                "name": "capitalizeFirst",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "str",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "string",
                "jsdoctags": [
                    {
                        "name": "str",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "createTerminalColorVariations",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "baseHct",
                        "type": "Hct",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "isDark",
                        "type": "boolean",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "literal type",
                "jsdoctags": [
                    {
                        "name": "baseHct",
                        "type": "Hct",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "isDark",
                        "type": "boolean",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "extractColors",
                "file": "src/lib/material-theme/theme-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "scheme",
                        "type": "DynamicScheme",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "Record<string, string>",
                "jsdoctags": [
                    {
                        "name": "scheme",
                        "type": "DynamicScheme",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "generateTerminalColors",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "seedColor",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "defaultValue": "SEED_COLOR"
                    }
                ],
                "returnType": "literal type",
                "jsdoctags": [
                    {
                        "name": "seedColor",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "defaultValue": "SEED_COLOR",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "generateTerminalCSS",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [],
                "returnType": "string"
            },
            {
                "name": "generateTerminalFiles",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "root",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "outputDir",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "void",
                "jsdoctags": [
                    {
                        "name": "root",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "outputDir",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "generateThemeFiles",
                "file": "src/lib/material-theme/theme-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "root",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "outputDir",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "void",
                "jsdoctags": [
                    {
                        "name": "root",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "outputDir",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "getAvailableSchemes",
                "file": "src/lib/material-theme/theme.config.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [],
                "returnType": "string[]"
            },
            {
                "name": "getColorFromScheme",
                "file": "src/lib/material-theme/theme-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "prop",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "scheme",
                        "type": "DynamicScheme",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "number",
                "jsdoctags": [
                    {
                        "name": "prop",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "scheme",
                        "type": "DynamicScheme",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "getConfigInfo",
                "file": "src/lib/material-theme/theme.config.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [],
                "returnType": "string"
            },
            {
                "name": "getSchemeConstructor",
                "file": "src/lib/material-theme/theme.config.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "schemeName",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "SchemeConstructor",
                "jsdoctags": [
                    {
                        "name": "schemeName",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "harmonizeWithSeed",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "baseColor",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "seedColor",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "number",
                "jsdoctags": [
                    {
                        "name": "baseColor",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "seedColor",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "isValidScheme",
                "file": "src/lib/material-theme/theme.config.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "schemeName",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "boolean",
                "jsdoctags": [
                    {
                        "name": "schemeName",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            }
        ],
        "typealiases": [
            {
                "name": "AllColors",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "MaterialColors | TerminalColors",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 193
            },
            {
                "name": "MaterialColors",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 200
            },
            {
                "name": "MeterType",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "\"iambic\" | \"trochaic\" | \"anapestic\" | \"dactylic\" | \"irregular\"",
                "file": "src/app/services/poetry/meter-analysis.service.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 193
            },
            {
                "name": "SchemeConstructor",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 186
            },
            {
                "name": "TerminalColors",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 199
            },
            {
                "name": "Theme",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "\"light\" | \"dark\"",
                "file": "src/app/services/core/theme.service.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 193
            }
        ],
        "enumerations": [],
        "groupedVariables": {
            "src/lib/material-theme/theme.config.ts": [
                {
                    "name": "ALL_CSS_VARS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "[]",
                    "defaultValue": "[...THEME_CSS_VARS, ...TERMINAL_CSS_VARS]"
                },
                {
                    "name": "SCHEMES",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type[]",
                    "defaultValue": "[\n  { name: 'tonal-spot', variant: SchemeTonalSpot },\n  { name: 'neutral', variant: SchemeNeutral },\n  { name: 'vibrant', variant: SchemeVibrant },\n  { name: 'expressive', variant: SchemeExpressive },\n  { name: 'monochrome', variant: SchemeMonochrome },\n  { name: 'content', variant: SchemeContent },\n  { name: 'fidelity', variant: SchemeFidelity },\n  { name: 'fruit-salad', variant: SchemeFruitSalad },\n  { name: 'rainbow', variant: SchemeRainbow },\n]"
                },
                {
                    "name": "SEED_COLOR",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "defaultValue": "'#F4C2C2'"
                },
                {
                    "name": "SELECTED_SCHEME",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "defaultValue": "'fidelity'"
                },
                {
                    "name": "TERMINAL_COLORS_CONFIG",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "defaultValue": "{\n  red: { hue: 10, chroma: 84, tone: 50 },\n  green: { hue: 145, chroma: 48, tone: 50 },\n  yellow: { hue: 90, chroma: 70, tone: 60 },\n  blue: { hue: 245, chroma: 80, tone: 50 },\n  magenta: { hue: 330, chroma: 68, tone: 50 },\n  cyan: { hue: 200, chroma: 48, tone: 50 },\n}"
                },
                {
                    "name": "TERMINAL_CSS_VARS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "[]",
                    "defaultValue": "[\n  'red',\n  'redContainer',\n  'onRedContainer',\n  'green',\n  'greenContainer',\n  'onGreenContainer',\n  'yellow',\n  'yellowContainer',\n  'onYellowContainer',\n  'blue',\n  'blueContainer',\n  'onBlueContainer',\n  'magenta',\n  'magentaContainer',\n  'onMagentaContainer',\n  'cyan',\n  'cyanContainer',\n  'onCyanContainer',\n\n  'inverseRed',\n  'inverseRedContainer',\n  'inverseOnRedContainer',\n  'inverseGreen',\n  'inverseGreenContainer',\n  'inverseOnGreenContainer',\n  'inverseYellow',\n  'inverseYellowContainer',\n  'inverseOnYellowContainer',\n  'inverseBlue',\n  'inverseBlueContainer',\n  'inverseOnBlueContainer',\n  'inverseMagenta',\n  'inverseMagentaContainer',\n  'inverseOnMagentaContainer',\n  'inverseCyan',\n  'inverseCyanContainer',\n  'inverseOnCyanContainer',\n]"
                },
                {
                    "name": "THEME_CONFIG",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "defaultValue": "{\n  seedColor: SEED_COLOR,\n  selectedScheme: SELECTED_SCHEME,\n  availableSchemes: SCHEMES.map((s) => s.name),\n  materialVariables: THEME_CSS_VARS.length,\n  terminalVariables: TERMINAL_CSS_VARS.length,\n  totalVariables: ALL_CSS_VARS.length,\n}"
                },
                {
                    "name": "THEME_CSS_VARS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "[]",
                    "defaultValue": "[\n  'primary',\n  'onPrimary',\n  'primaryContainer',\n  'onPrimaryContainer',\n  'secondary',\n  'onSecondary',\n  'secondaryContainer',\n  'onSecondaryContainer',\n  'tertiary',\n  'onTertiary',\n  'tertiaryContainer',\n  'onTertiaryContainer',\n  'error',\n  'onError',\n  'errorContainer',\n  'onErrorContainer',\n  'background',\n  'onBackground',\n  'surface',\n  'surfaceDim',\n  'surfaceBright',\n  'surfaceContainerLowest',\n  'surfaceContainerLow',\n  'surfaceContainer',\n  'surfaceContainerHigh',\n  'surfaceContainerHighest',\n  'onSurface',\n  'surfaceVariant',\n  'onSurfaceVariant',\n  'outline',\n  'outlineVariant',\n  'shadow',\n  'scrim',\n  'inverseSurface',\n  'inverseOnSurface',\n  'inversePrimary',\n]"
                }
            ],
            "src/app/app.config.ts": [
                {
                    "name": "appConfig",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/app.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "ApplicationConfig",
                    "defaultValue": "{\n  providers: [\n    provideBrowserGlobalErrorListeners(),\n    provideZoneChangeDetection({ eventCoalescing: true }),\n    provideRouter(routes),\n  ],\n}"
                }
            ],
            "src/lib/material-theme/cli.ts": [
                {
                    "name": "outputDir",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/cli.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "defaultValue": "'src/styles'"
                },
                {
                    "name": "root",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/cli.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "process.cwd()"
                }
            ],
            "src/app/data/poetry-forms.data.ts": [
                {
                    "name": "POETRY_EXAMPLES",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/data/poetry-forms.data.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Record<string, string[]>",
                    "defaultValue": "{\n  haiku: ['an old silent pond', 'a frog jumps into the pond', 'splash! silence again'],\n  tanka: [\n    'the falling flower',\n    'i saw drift back to the branch',\n    'was a butterfly',\n    'dancing in the gentle breeze',\n    \"nature's art in motion\",\n  ],\n  cinquain: [\n    'moon',\n    'silent light',\n    'casting silver shadows',\n    'illuminating the dark night',\n    'peace',\n  ],\n  limerick: [\n    'there once was a coder so bright',\n    'who worked on his app every night',\n    'with angular and code',\n    'he built a fine node',\n    \"and launched it to everyone's delight\",\n  ],\n  redondilla: [\n    'in fields of green and gold so bright',\n    'where flowers dance in morning light',\n    'the world awakens from the night',\n    'and fills my heart with pure delight',\n  ],\n  lanterne: ['moon', 'bright glow', 'silver light', 'shining through night', 'peace'],\n  diamante: [\n    'day',\n    'bright warm',\n    'shining glowing heating',\n    'sunrise sunset twilight darkness',\n    'cooling dimming fading',\n    'cold dark',\n    'night',\n  ],\n  fibonacci: ['I', 'am', 'writing', 'syllables', 'in fibonacci', 'a mathematical poetry sequence'],\n}"
                },
                {
                    "name": "POETRY_FORM_OPTIONS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/data/poetry-forms.data.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "Object.values(POETRY_FORMS).map((form) => ({\n  value: form.id,\n  label: form.name,\n  description: form.pattern.join('-'),\n}))"
                },
                {
                    "name": "POETRY_FORMS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/data/poetry-forms.data.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Record<string, PoetryForm>",
                    "defaultValue": "{\n  haiku: {\n    id: 'haiku',\n    name: 'haiku',\n    pattern: [5, 7, 5],\n    lines: 3,\n    origin: 'japanese',\n    description: 'traditional nature poem with 3 lines',\n  },\n  tanka: {\n    id: 'tanka',\n    name: 'tanka',\n    pattern: [5, 7, 5, 7, 7],\n    lines: 5,\n    origin: 'japanese',\n    description: 'extended court poetry with 5 lines',\n  },\n  cinquain: {\n    id: 'cinquain',\n    name: 'cinquain',\n    pattern: [2, 4, 6, 8, 2],\n    lines: 5,\n    origin: 'american',\n    description: 'didactic poem with ascending/descending pattern',\n  },\n  limerick: {\n    id: 'limerick',\n    name: 'limerick',\n    pattern: [8, 8, 5, 5, 8],\n    lines: 5,\n    origin: 'english',\n    description: 'humorous poem with AABBA rhyme scheme',\n  },\n  redondilla: {\n    id: 'redondilla',\n    name: 'redondilla',\n    pattern: [8, 8, 8, 8],\n    lines: 4,\n    origin: 'spanish',\n    description: 'quatrain with consonant rhyme',\n  },\n  lanterne: {\n    id: 'lanterne',\n    name: 'lanterne',\n    pattern: [1, 2, 3, 4, 1],\n    lines: 5,\n    origin: 'japanese-inspired',\n    description: 'lantern-shaped syllabic poem',\n  },\n  diamante: {\n    id: 'diamante',\n    name: 'diamante',\n    pattern: [1, 2, 3, 4, 3, 2, 1],\n    lines: 7,\n    origin: 'modern',\n    description: 'diamond-shaped contrast poem',\n  },\n  fibonacci: {\n    id: 'fibonacci',\n    name: 'fibonacci',\n    pattern: [1, 1, 2, 3, 5, 8],\n    lines: 6,\n    origin: 'mathematical',\n    description: 'follows fibonacci sequence',\n  },\n}"
                }
            ],
            "src/app/app.routes.ts": [
                {
                    "name": "routes",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/app.routes.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Routes",
                    "defaultValue": "[]"
                }
            ]
        },
        "groupedFunctions": {
            "src/lib/material-theme/terminal-generator.ts": [
                {
                    "name": "capitalizeFirst",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "str",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "string",
                    "jsdoctags": [
                        {
                            "name": "str",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "createTerminalColorVariations",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "baseHct",
                            "type": "Hct",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "isDark",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "literal type",
                    "jsdoctags": [
                        {
                            "name": "baseHct",
                            "type": "Hct",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "isDark",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateTerminalColors",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "seedColor",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "SEED_COLOR"
                        }
                    ],
                    "returnType": "literal type",
                    "jsdoctags": [
                        {
                            "name": "seedColor",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "SEED_COLOR",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateTerminalCSS",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [],
                    "returnType": "string"
                },
                {
                    "name": "generateTerminalFiles",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "root",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "void",
                    "jsdoctags": [
                        {
                            "name": "root",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "harmonizeWithSeed",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "baseColor",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "seedColor",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "number",
                    "jsdoctags": [
                        {
                            "name": "baseColor",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "seedColor",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "src/lib/material-theme/theme-generator.ts": [
                {
                    "name": "extractColors",
                    "file": "src/lib/material-theme/theme-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "scheme",
                            "type": "DynamicScheme",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "Record<string, string>",
                    "jsdoctags": [
                        {
                            "name": "scheme",
                            "type": "DynamicScheme",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateThemeFiles",
                    "file": "src/lib/material-theme/theme-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "root",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "void",
                    "jsdoctags": [
                        {
                            "name": "root",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getColorFromScheme",
                    "file": "src/lib/material-theme/theme-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "prop",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "scheme",
                            "type": "DynamicScheme",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "number",
                    "jsdoctags": [
                        {
                            "name": "prop",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "scheme",
                            "type": "DynamicScheme",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "src/lib/material-theme/theme.config.ts": [
                {
                    "name": "getAvailableSchemes",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [],
                    "returnType": "string[]"
                },
                {
                    "name": "getConfigInfo",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [],
                    "returnType": "string"
                },
                {
                    "name": "getSchemeConstructor",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "schemeName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "SchemeConstructor",
                    "jsdoctags": [
                        {
                            "name": "schemeName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isValidScheme",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "schemeName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "boolean",
                    "jsdoctags": [
                        {
                            "name": "schemeName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ]
        },
        "groupedEnumerations": {},
        "groupedTypeAliases": {
            "src/lib/material-theme/theme.config.ts": [
                {
                    "name": "AllColors",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "MaterialColors | TerminalColors",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 193
                },
                {
                    "name": "MaterialColors",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 200
                },
                {
                    "name": "SchemeConstructor",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 186
                },
                {
                    "name": "TerminalColors",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 199
                }
            ],
            "src/app/services/poetry/meter-analysis.service.ts": [
                {
                    "name": "MeterType",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "\"iambic\" | \"trochaic\" | \"anapestic\" | \"dactylic\" | \"irregular\"",
                    "file": "src/app/services/poetry/meter-analysis.service.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 193
                }
            ],
            "src/app/services/core/theme.service.ts": [
                {
                    "name": "Theme",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "\"light\" | \"dark\"",
                    "file": "src/app/services/core/theme.service.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 193
                }
            ]
        }
    },
    "routes": {
        "name": "<root>",
        "kind": "module",
        "children": []
    },
    "coverage": {
        "count": 0,
        "status": "low",
        "files": [
            {
                "filePath": "src/app/app.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "appConfig",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/app.routes.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "routes",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/app.ts",
                "type": "component",
                "linktype": "component",
                "name": "App",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/components/layout/footer/footer.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "FooterComponent",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/app/components/layout/header/header.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "HeaderComponent",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/components/layout/poetry-page/poetry-page.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PoetryPageComponent",
                "coveragePercent": 0,
                "coverageCount": "0/35",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/appbar/appbar.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "AppBarComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/appbar/appbar.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "AppBarAction",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/list-item/list-item.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ListItemComponent",
                "coveragePercent": 0,
                "coverageCount": "0/10",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/panorama/panorama.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PanoramaComponent",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/pivot/pivot.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PivotComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/pivot/pivot.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "PivotItem",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/progress/progress.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ProgressComponent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/toast-container/toast-container.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ToastContainerComponent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/metro/toggle/toggle.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ToggleComponent",
                "coveragePercent": 0,
                "coverageCount": "0/13",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poetry/meter-analysis-section/meter-analysis-section.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "MeterAnalysisSectionComponent",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poetry/poem-editor/poem-editor.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PoemEditorComponent",
                "coveragePercent": 0,
                "coverageCount": "0/27",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poetry/poem-quality/poem-quality.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PoemQualityComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poetry/poem-results/poem-results.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PoemResultsComponent",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poetry/quick-stats-panel/quick-stats-panel.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "QuickStatsPanelComponent",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poetry/quick-stats-panel/quick-stats-panel.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "QuickStats",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poetry/word-suggestions/word-suggestions.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "WordSuggestionsComponent",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/app/components/theme-toggle/theme-toggle.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ThemeToggleComponent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/accordion/accordion.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "AccordionComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/analysis-panel/analysis-panel.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "AnalysisPanelComponent",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/analysis-panel/analysis-panel.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "AnalysisMetric",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/badge/badge.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "BadgeComponent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/button/button.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ButtonComponent",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/card/card.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "CardComponent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/input/input.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "InputComponent",
                "coveragePercent": 0,
                "coverageCount": "0/20",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/multiline-input/multiline-input.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "MultilineInputComponent",
                "coveragePercent": 0,
                "coverageCount": "0/42",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/multiline-input/multiline-input.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "LineData",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/multiline-input/multiline-input.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "SyllableSegment",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/select/select.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "SelectComponent",
                "coveragePercent": 0,
                "coverageCount": "0/16",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/select/select.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "SelectOption",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/ui/tooltip/tooltip.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "TooltipComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/data/poetry-forms.data.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "POETRY_EXAMPLES",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/data/poetry-forms.data.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "POETRY_FORM_OPTIONS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/data/poetry-forms.data.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "POETRY_FORMS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/models/poetry.model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "LineAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/models/poetry.model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "MeterAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/models/poetry.model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "PoetryForm",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/models/poetry.model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "PoetryResult",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/services/core/theme.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "ThemeService",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/services/core/theme.service.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "Theme",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/services/core/toast.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "ToastService",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/services/core/toast.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "Toast",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/services/core/utils.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "UtilsService",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/meter-analysis.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "MeterAnalysisService",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/meter-analysis.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "MeterAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/meter-analysis.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "RhythmSuggestion",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/meter-analysis.service.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "MeterType",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poem-quality.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "PoemQualityService",
                "coveragePercent": 0,
                "coverageCount": "0/14",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poem-quality.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "QualityMetrics",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analysis.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "PoetryAnalysisService",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analysis.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "PoetryStructure",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analyzer.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "PoetryAnalyzerService",
                "coveragePercent": 0,
                "coverageCount": "0/30",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analyzer.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "EnhancedLineAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analyzer.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "EnhancedPoetryResult",
                "coveragePercent": 0,
                "coverageCount": "0/12",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analyzer.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "WordSuggestionData",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-patterns.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "PoetryPatternsService",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-suggestions.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "PoetrySuggestionsService",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-suggestions.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "SuggestionContext",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-suggestions.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "WordSuggestionData",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rhyme-analysis.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "RhymeAnalysisService",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "RitaService",
                "coveragePercent": 0,
                "coverageCount": "0/15",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "AdvancedSearchOptions",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "AlliterationMatch",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "AlternativeWord",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "GrammaticalAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/11",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "RhymeMatch",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "SyllableAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "WordAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/cli.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "outputDir",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/cli.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "root",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "capitalizeFirst",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "createTerminalColorVariations",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "generateTerminalColors",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "generateTerminalCSS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "generateTerminalFiles",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "harmonizeWithSeed",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "extractColors",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "generateThemeFiles",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "getColorFromScheme",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ThemeColor",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "getAvailableSchemes",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "getConfigInfo",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "getSchemeConstructor",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "isValidScheme",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "ALL_CSS_VARS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "SCHEMES",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "SEED_COLOR",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "SELECTED_SCHEME",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "TERMINAL_COLORS_CONFIG",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "TERMINAL_CSS_VARS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "THEME_CONFIG",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "THEME_CSS_VARS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "AllColors",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "MaterialColors",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "SchemeConstructor",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "TerminalColors",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            }
        ]
    }
}