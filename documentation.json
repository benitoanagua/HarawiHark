{
    "pipes": [],
    "interfaces": [
        {
            "name": "AdvancedSearchOptions",
            "id": "interface-AdvancedSearchOptions-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "contains",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 51
                },
                {
                    "name": "endsWith",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 50
                },
                {
                    "name": "maxLength",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 53
                },
                {
                    "name": "minLength",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 52
                },
                {
                    "name": "pos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 48
                },
                {
                    "name": "startsWith",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 49
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 47
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "AlliterationMatch",
            "id": "interface-AlliterationMatch-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "positions",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 35
                },
                {
                    "name": "sound",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 36
                },
                {
                    "name": "words",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 34
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "AlternativeWord",
            "id": "interface-AlternativeWord-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "pos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 30
                },
                {
                    "name": "reason",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"exact-match\" | \"rhyme-match\" | \"sound-match\" | \"semantic-rhyme\" | \"spelling-match\" | \"morphological\"",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 23
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22
                },
                {
                    "name": "word",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 21
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "AnalysisMetric",
            "id": "interface-AnalysisMetric-f2a42957f3f30f2b7246baa47e7c33b1118eac16884b9e1e6f425c3bae42c6ca989d0625fcf28555f49e38197c6602cc67404c0587adeeac9088413966955290",
            "file": "src/app/components/analysis-panel/analysis-panel.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Component, Input } from '@angular/core';\n\nexport interface AnalysisMetric {\n  label: string;\n  value: number | string;\n  maxValue?: number;\n  variant?: 'default' | 'success' | 'warning' | 'error';\n  icon?: string;\n}\n\n@Component({\n  selector: 'app-analysis-panel',\n  standalone: true,\n  templateUrl: './analysis-panel.component.html',\n})\nexport class AnalysisPanelComponent {\n  @Input() title = '';\n  @Input() metrics: AnalysisMetric[] = [];\n  @Input() compact = false;\n\n  getMetricVariant(metric: AnalysisMetric): string {\n    return `metric-${metric.variant || 'default'}`;\n  }\n\n  getProgressWidth(metric: AnalysisMetric): string {\n    if (metric.maxValue && typeof metric.value === 'number') {\n      const percentage = (metric.value / metric.maxValue) * 100;\n      return `${Math.min(percentage, 100)}%`;\n    }\n    return '0%';\n  }\n}\n",
            "properties": [
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 4
                },
                {
                    "name": "maxValue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number | string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "variant",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"default\" | \"success\" | \"warning\" | \"error\"",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 7
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "EnhancedLineAnalysis",
            "id": "interface-EnhancedLineAnalysis-cc01c88b56c2eb0b88baa736de26edf66653299b14fecfbb0dc7434c68b3977c7f382c4e601296066b01dfe98a03a03a66ecf008c0598e91718873cd4c5aefdb",
            "file": "src/app/services/poetry/poetry-analyzer.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject, signal } from '@angular/core';\nimport { PoetryAnalysisService } from './poetry-analysis.service';\nimport { PoetrySuggestionsService } from './poetry-suggestions.service';\nimport { PoetryPatternsService } from './poetry-patterns.service';\nimport { RhymeAnalysisService } from './rhyme-analysis.service';\nimport { PoemQualityService, type QualityMetrics } from './poem-quality.service';\nimport {\n  MeterAnalysisService,\n  type MeterAnalysis,\n  type RhythmSuggestion,\n} from './meter-analysis.service';\nimport {\n  RitaService,\n  type GrammaticalAnalysis,\n  type AlliterationMatch,\n  type AlternativeWord,\n} from './rita.service';\nimport { POETRY_FORMS, POETRY_EXAMPLES } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface EnhancedLineAnalysis extends LineAnalysis {\n  words: {\n    word: string;\n    syllables: number;\n    pos: string;\n    phones: string;\n    grammar?: GrammaticalAnalysis;\n  }[];\n  alliterations?: AlliterationMatch[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n}\n\nexport interface EnhancedPoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: EnhancedLineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n  overallAlliterations: AlliterationMatch[];\n  detectedPatterns: string[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n  meterAnalysis?: MeterAnalysis;\n}\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalyzerService {\n  private readonly analysis = inject(PoetryAnalysisService);\n  private readonly suggestions = inject(PoetrySuggestionsService);\n  private readonly patterns = inject(PoetryPatternsService);\n  private readonly rhymes = inject(RhymeAnalysisService);\n  private readonly quality = inject(PoemQualityService);\n  private readonly meterService = inject(MeterAnalysisService);\n  private readonly rita = inject(RitaService);\n\n  readonly isLoading = signal(false);\n  readonly result = signal<EnhancedPoetryResult | null>(null);\n  readonly selectedWord = signal<string | null>(null);\n  readonly wordAlternatives = signal<WordSuggestionData | null>(null);\n  readonly qualityMetrics = signal<QualityMetrics | null>(null);\n  readonly selectedForm = signal<string>('haiku');\n  readonly poemText = signal<string>('');\n  readonly rhythmSuggestions = signal<RhythmSuggestion[]>([]);\n\n  async analyze(formKey: string, rawLines: string[]): Promise<EnhancedPoetryResult> {\n    this.isLoading.set(true);\n\n    try {\n      const form = POETRY_FORMS[formKey];\n      if (!form) {\n        throw new Error(`Unknown form \"${formKey}\"`);\n      }\n\n      const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n      // Análisis dinámico basado en el poema actual\n      const typos = await this.rita.detectTypos(lines);\n      const meterAnalysis = this.meterService.detectMeter(lines);\n      const rhythmSuggestions = this.meterService.generateRhythmSuggestions(\n        lines,\n        meterAnalysis.type\n      );\n      this.rhythmSuggestions.set(rhythmSuggestions);\n\n      const lineAnalyses: EnhancedLineAnalysis[] = await Promise.all(\n        lines.map(async (line, index) => {\n          const analysis = this.rita.analyzeLine(line);\n          const words = this.rita.analyzeWords(line);\n          const alliterations = this.rita.detectAlliterations(line);\n          const expected = form.pattern[index] ?? 0;\n\n          const wordsWithGrammar = words.map((word) => ({\n            ...word,\n            grammar: this.rita.analyzeGrammar(word.word),\n          }));\n\n          return {\n            text: line,\n            count: analysis.syllables,\n            expected,\n            match: analysis.syllables === expected,\n            syllables: analysis.breakdown,\n            stresses: analysis.stresses,\n            words: wordsWithGrammar,\n            alliterations: alliterations.length > 0 ? alliterations : undefined,\n            typos: typos.filter((t) => t.line === index),\n          };\n        })\n      );\n\n      // Calcular calidad basada en el poema actual\n      const quality = this.quality.assessQuality(\n        lines,\n        form.pattern,\n        this.createResultForQualityAssessment(formKey, lineAnalyses)\n      );\n\n      const overallAlliterations = this.rhymes.detectCrossLineAlliterations(lines);\n      const detectedPatterns = [\n        ...this.detectPatterns(lineAnalyses),\n        ...this.generateMeterPatterns(meterAnalysis),\n      ];\n\n      const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n      const mismatches = lineAnalyses.filter((l) => !l.match).length;\n      const summary = ok\n        ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n            '-'\n          )} pattern`\n        : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n      const suggestions = this.generateEnhancedSuggestions(\n        lineAnalyses,\n        form.pattern,\n        meterAnalysis\n      );\n      const rhymeScheme = lines.length > 1 ? this.rita.analyzeRhymeScheme(lines) : undefined;\n\n      const result: EnhancedPoetryResult = {\n        ok,\n        form: formKey,\n        totalLines: {\n          expected: form.pattern.length,\n          actual: lineAnalyses.length,\n        },\n        lines: lineAnalyses,\n        summary,\n        rhymeScheme,\n        suggestions,\n        overallAlliterations,\n        detectedPatterns,\n        typos: typos.length > 0 ? typos : undefined,\n        meterAnalysis,\n      };\n\n      this.result.set(result);\n      this.qualityMetrics.set(quality);\n      return result;\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  async selectWordEnhanced(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) return;\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.suggestions.getWordAlternativesEnhanced(\n              word,\n              neededSyllables,\n              {\n                pos: wordAnalysis.pos,\n                lineIndex: result.lines.indexOf(line),\n                isLineEnd: line.words[line.words.length - 1]?.word === word,\n                previousWord: this.getPreviousWord(line.words, word),\n              }\n            );\n\n            this.wordAlternatives.set(alternatives);\n          } catch (error) {\n            console.warn('Error getting enhanced alternatives:', error);\n            await this.selectWord(word);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  async selectWord(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) {\n      return;\n    }\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.rita.suggestAlternatives(word, neededSyllables, 8);\n            this.wordAlternatives.set({\n              original: word,\n              currentSyllables: wordAnalysis.syllables,\n              targetSyllables: neededSyllables,\n              alternatives,\n            });\n          } catch (error) {\n            console.warn('Error getting word alternatives:', error);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  loadExample(): void {\n    const formId = this.selectedForm();\n    const example = POETRY_EXAMPLES[formId];\n    if (example) {\n      this.poemText.set(example.join('\\n'));\n      // Analizar automáticamente el ejemplo cargado\n      this.analyze(formId, example);\n    }\n  }\n\n  assessQuality(): void {\n    const result = this.result();\n    if (!result) return;\n\n    const lines = result.lines.map((l) => l.text);\n    const pattern = POETRY_FORMS[result.form].pattern;\n\n    const metrics = this.quality.assessQuality(lines, pattern, result);\n    this.qualityMetrics.set(metrics);\n  }\n\n  replaceWord(oldWord: string, newWord: string): void {\n    const result = this.result();\n    if (!result) return;\n\n    const updatedLines = result.lines.map((line) => {\n      const updatedText = line.text.replace(new RegExp(`\\\\b${oldWord}\\\\b`, 'gi'), newWord);\n      return updatedText;\n    });\n\n    this.poemText.set(updatedLines.join('\\n'));\n    this.analyze(result.form, updatedLines);\n    this.selectWordEnhanced(null);\n  }\n\n  clear(): void {\n    this.result.set(null);\n    this.selectedWord.set(null);\n    this.wordAlternatives.set(null);\n    this.qualityMetrics.set(null);\n    this.rhythmSuggestions.set([]);\n    this.poemText.set('');\n  }\n\n  private detectPatterns(lines: EnhancedLineAnalysis[]): string[] {\n    const patterns: string[] = [];\n\n    // Detectar patrones basados en el análisis real\n    const stressPatterns = lines.map((l) => l.stresses).filter((s) => s);\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent stress pattern: ${firstPattern}`);\n      }\n    }\n\n    // Detectar aliteraciones en el poema actual\n    const linesWithAlliteration = lines.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length > 0) {\n      patterns.push(\n        `${linesWithAlliteration.length} line${\n          linesWithAlliteration.length > 1 ? 's' : ''\n        } contain alliteration`\n      );\n    }\n\n    // Análisis de vocabulario del poema actual\n    const allWords = lines.flatMap((l) => l.words);\n    const nouns = allWords.filter((w) => w.pos.startsWith('nn')).length;\n    const verbs = allWords.filter((w) => w.pos.startsWith('vb')).length;\n    const adjectives = allWords.filter((w) => w.pos.startsWith('jj')).length;\n    const adverbs = allWords.filter((w) => w.pos.startsWith('rb')).length;\n\n    if (nouns > verbs * 2) {\n      patterns.push('Noun-heavy composition (descriptive style)');\n    } else if (verbs > nouns * 1.5) {\n      patterns.push('Verb-heavy composition (active style)');\n    }\n\n    if (adjectives > allWords.length * 0.2) {\n      patterns.push('High use of adjectives (vivid imagery)');\n    }\n\n    if (adverbs > allWords.length * 0.15) {\n      patterns.push('Adverb-rich language (detailed action)');\n    }\n\n    // Análisis de longitud de palabras\n    const avgWordLength =\n      allWords.reduce((sum, w) => sum + w.word.length, 0) / (allWords.length || 1);\n    if (avgWordLength > 6) {\n      patterns.push('Complex vocabulary (long words)');\n    } else if (avgWordLength < 4) {\n      patterns.push('Simple vocabulary (short words)');\n    }\n\n    return patterns;\n  }\n\n  private generateMeterPatterns(meter: MeterAnalysis): string[] {\n    const patterns: string[] = [];\n\n    if (meter.consistency > 70) {\n      patterns.push(`Strong ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    } else if (meter.consistency > 40) {\n      patterns.push(`Emerging ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    }\n\n    if (meter.type !== 'irregular') {\n      patterns.push(`Meter: ${meter.pattern}`);\n    }\n\n    return patterns;\n  }\n\n  private generateEnhancedSuggestions(\n    lineAnalyses: EnhancedLineAnalysis[],\n    pattern: number[],\n    meterAnalysis: MeterAnalysis\n  ): string[] {\n    const suggestions: string[] = [];\n\n    // Sugerencias basadas en la estructura del poema actual\n    if (lineAnalyses.length < pattern.length) {\n      const missing = pattern.length - lineAnalyses.length;\n      suggestions.push(`Add ${missing} more line${missing > 1 ? 's' : ''} to complete the pattern`);\n    } else if (lineAnalyses.length > pattern.length) {\n      const extra = lineAnalyses.length - pattern.length;\n      suggestions.push(`Remove ${extra} line${extra > 1 ? 's' : ''} to match the pattern`);\n    }\n\n    // Sugerencias rítmicas basadas en el análisis métrico\n    if (meterAnalysis.consistency < 60) {\n      suggestions.push(\n        `Improve rhythm consistency: ${meterAnalysis.type} meter detected but inconsistent`\n      );\n    }\n\n    if (meterAnalysis.type === 'irregular' && lineAnalyses.length > 2) {\n      suggestions.push('Consider using a regular meter pattern for better poetic flow');\n    }\n\n    // Sugerencias específicas por línea\n    lineAnalyses.forEach((line, index) => {\n      if (!line.match && index < pattern.length) {\n        const lineSuggestions = this.rita.generateSuggestions(line.text, pattern[index]);\n        suggestions.push(`Line ${index + 1}: ${lineSuggestions[0]}`);\n\n        const diff = pattern[index] - line.count;\n        if (diff > 0) {\n          const shortWords = line.words.filter((w) => w.syllables === 1);\n          if (shortWords.length > 0) {\n            suggestions.push(`  → Try replacing \"${shortWords[0].word}\" with a longer synonym`);\n          }\n        } else if (diff < 0) {\n          const longWords = line.words\n            .filter((w) => w.syllables > 2)\n            .sort((a, b) => b.syllables - a.syllables);\n          if (longWords.length > 0) {\n            suggestions.push(\n              `  → Try replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter word`\n            );\n          }\n        }\n      }\n    });\n\n    // Sugerencias de dispositivos literarios\n    const linesWithAlliteration = lineAnalyses.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length === 0 && lineAnalyses.length > 2) {\n      suggestions.push('Consider adding alliteration for poetic effect');\n    }\n\n    const hasRhyme = lineAnalyses.some((line) =>\n      line.words.some(\n        (word) => (word.pos && word.pos.startsWith('nn')) || word.pos.startsWith('vb')\n      )\n    );\n    if (!hasRhyme && lineAnalyses.length > 1) {\n      suggestions.push('Try incorporating rhyme for musical quality');\n    }\n\n    return suggestions.slice(0, 6);\n  }\n\n  private getPreviousWord(words: { word: string }[], currentWord: string): string | undefined {\n    const currentIndex = words.findIndex((w) => w.word.toLowerCase() === currentWord.toLowerCase());\n    return currentIndex > 0 ? words[currentIndex - 1].word : undefined;\n  }\n\n  private createResultForQualityAssessment(\n    formKey: string,\n    lineAnalyses: EnhancedLineAnalysis[]\n  ): EnhancedPoetryResult {\n    const form = POETRY_FORMS[formKey];\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n    return {\n      ok,\n      form: formKey,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      lines: lineAnalyses,\n      summary: '',\n      suggestions: [],\n      overallAlliterations: [],\n      detectedPatterns: [],\n    };\n  }\n\n  isCompletePoem(): boolean {\n    const result = this.result();\n    if (!result) return false;\n\n    return (\n      result.lines.length === result.totalLines.expected && result.lines.every((line) => line.match)\n    );\n  }\n\n  getQuickStats(): {\n    totalSyllables: number;\n    avgSyllablesPerLine: number;\n    vocabularyRichness: number;\n  } {\n    const result = this.result();\n    if (!result || result.lines.length === 0) {\n      return { totalSyllables: 0, avgSyllablesPerLine: 0, vocabularyRichness: 0 };\n    }\n\n    const totalSyllables = result.lines.reduce((sum, line) => sum + line.count, 0);\n    const avgSyllablesPerLine = totalSyllables / result.lines.length;\n\n    const allWords = result.lines.flatMap((line) => line.words.map((w) => w.word.toLowerCase()));\n    const uniqueWords = new Set(allWords);\n    const vocabularyRichness = (uniqueWords.size / allWords.length) * 100;\n\n    return {\n      totalSyllables,\n      avgSyllablesPerLine: Math.round(avgSyllablesPerLine * 10) / 10,\n      vocabularyRichness: Math.round(vocabularyRichness * 10) / 10,\n    };\n  }\n}\n",
            "properties": [
                {
                    "name": "alliterations",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "AlliterationMatch[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 29
                },
                {
                    "name": "typos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 30
                },
                {
                    "name": "words",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": [
                "LineAnalysis"
            ]
        },
        {
            "name": "EnhancedPoetryResult",
            "id": "interface-EnhancedPoetryResult-cc01c88b56c2eb0b88baa736de26edf66653299b14fecfbb0dc7434c68b3977c7f382c4e601296066b01dfe98a03a03a66ecf008c0598e91718873cd4c5aefdb",
            "file": "src/app/services/poetry/poetry-analyzer.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject, signal } from '@angular/core';\nimport { PoetryAnalysisService } from './poetry-analysis.service';\nimport { PoetrySuggestionsService } from './poetry-suggestions.service';\nimport { PoetryPatternsService } from './poetry-patterns.service';\nimport { RhymeAnalysisService } from './rhyme-analysis.service';\nimport { PoemQualityService, type QualityMetrics } from './poem-quality.service';\nimport {\n  MeterAnalysisService,\n  type MeterAnalysis,\n  type RhythmSuggestion,\n} from './meter-analysis.service';\nimport {\n  RitaService,\n  type GrammaticalAnalysis,\n  type AlliterationMatch,\n  type AlternativeWord,\n} from './rita.service';\nimport { POETRY_FORMS, POETRY_EXAMPLES } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface EnhancedLineAnalysis extends LineAnalysis {\n  words: {\n    word: string;\n    syllables: number;\n    pos: string;\n    phones: string;\n    grammar?: GrammaticalAnalysis;\n  }[];\n  alliterations?: AlliterationMatch[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n}\n\nexport interface EnhancedPoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: EnhancedLineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n  overallAlliterations: AlliterationMatch[];\n  detectedPatterns: string[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n  meterAnalysis?: MeterAnalysis;\n}\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalyzerService {\n  private readonly analysis = inject(PoetryAnalysisService);\n  private readonly suggestions = inject(PoetrySuggestionsService);\n  private readonly patterns = inject(PoetryPatternsService);\n  private readonly rhymes = inject(RhymeAnalysisService);\n  private readonly quality = inject(PoemQualityService);\n  private readonly meterService = inject(MeterAnalysisService);\n  private readonly rita = inject(RitaService);\n\n  readonly isLoading = signal(false);\n  readonly result = signal<EnhancedPoetryResult | null>(null);\n  readonly selectedWord = signal<string | null>(null);\n  readonly wordAlternatives = signal<WordSuggestionData | null>(null);\n  readonly qualityMetrics = signal<QualityMetrics | null>(null);\n  readonly selectedForm = signal<string>('haiku');\n  readonly poemText = signal<string>('');\n  readonly rhythmSuggestions = signal<RhythmSuggestion[]>([]);\n\n  async analyze(formKey: string, rawLines: string[]): Promise<EnhancedPoetryResult> {\n    this.isLoading.set(true);\n\n    try {\n      const form = POETRY_FORMS[formKey];\n      if (!form) {\n        throw new Error(`Unknown form \"${formKey}\"`);\n      }\n\n      const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n      // Análisis dinámico basado en el poema actual\n      const typos = await this.rita.detectTypos(lines);\n      const meterAnalysis = this.meterService.detectMeter(lines);\n      const rhythmSuggestions = this.meterService.generateRhythmSuggestions(\n        lines,\n        meterAnalysis.type\n      );\n      this.rhythmSuggestions.set(rhythmSuggestions);\n\n      const lineAnalyses: EnhancedLineAnalysis[] = await Promise.all(\n        lines.map(async (line, index) => {\n          const analysis = this.rita.analyzeLine(line);\n          const words = this.rita.analyzeWords(line);\n          const alliterations = this.rita.detectAlliterations(line);\n          const expected = form.pattern[index] ?? 0;\n\n          const wordsWithGrammar = words.map((word) => ({\n            ...word,\n            grammar: this.rita.analyzeGrammar(word.word),\n          }));\n\n          return {\n            text: line,\n            count: analysis.syllables,\n            expected,\n            match: analysis.syllables === expected,\n            syllables: analysis.breakdown,\n            stresses: analysis.stresses,\n            words: wordsWithGrammar,\n            alliterations: alliterations.length > 0 ? alliterations : undefined,\n            typos: typos.filter((t) => t.line === index),\n          };\n        })\n      );\n\n      // Calcular calidad basada en el poema actual\n      const quality = this.quality.assessQuality(\n        lines,\n        form.pattern,\n        this.createResultForQualityAssessment(formKey, lineAnalyses)\n      );\n\n      const overallAlliterations = this.rhymes.detectCrossLineAlliterations(lines);\n      const detectedPatterns = [\n        ...this.detectPatterns(lineAnalyses),\n        ...this.generateMeterPatterns(meterAnalysis),\n      ];\n\n      const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n      const mismatches = lineAnalyses.filter((l) => !l.match).length;\n      const summary = ok\n        ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n            '-'\n          )} pattern`\n        : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n      const suggestions = this.generateEnhancedSuggestions(\n        lineAnalyses,\n        form.pattern,\n        meterAnalysis\n      );\n      const rhymeScheme = lines.length > 1 ? this.rita.analyzeRhymeScheme(lines) : undefined;\n\n      const result: EnhancedPoetryResult = {\n        ok,\n        form: formKey,\n        totalLines: {\n          expected: form.pattern.length,\n          actual: lineAnalyses.length,\n        },\n        lines: lineAnalyses,\n        summary,\n        rhymeScheme,\n        suggestions,\n        overallAlliterations,\n        detectedPatterns,\n        typos: typos.length > 0 ? typos : undefined,\n        meterAnalysis,\n      };\n\n      this.result.set(result);\n      this.qualityMetrics.set(quality);\n      return result;\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  async selectWordEnhanced(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) return;\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.suggestions.getWordAlternativesEnhanced(\n              word,\n              neededSyllables,\n              {\n                pos: wordAnalysis.pos,\n                lineIndex: result.lines.indexOf(line),\n                isLineEnd: line.words[line.words.length - 1]?.word === word,\n                previousWord: this.getPreviousWord(line.words, word),\n              }\n            );\n\n            this.wordAlternatives.set(alternatives);\n          } catch (error) {\n            console.warn('Error getting enhanced alternatives:', error);\n            await this.selectWord(word);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  async selectWord(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) {\n      return;\n    }\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.rita.suggestAlternatives(word, neededSyllables, 8);\n            this.wordAlternatives.set({\n              original: word,\n              currentSyllables: wordAnalysis.syllables,\n              targetSyllables: neededSyllables,\n              alternatives,\n            });\n          } catch (error) {\n            console.warn('Error getting word alternatives:', error);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  loadExample(): void {\n    const formId = this.selectedForm();\n    const example = POETRY_EXAMPLES[formId];\n    if (example) {\n      this.poemText.set(example.join('\\n'));\n      // Analizar automáticamente el ejemplo cargado\n      this.analyze(formId, example);\n    }\n  }\n\n  assessQuality(): void {\n    const result = this.result();\n    if (!result) return;\n\n    const lines = result.lines.map((l) => l.text);\n    const pattern = POETRY_FORMS[result.form].pattern;\n\n    const metrics = this.quality.assessQuality(lines, pattern, result);\n    this.qualityMetrics.set(metrics);\n  }\n\n  replaceWord(oldWord: string, newWord: string): void {\n    const result = this.result();\n    if (!result) return;\n\n    const updatedLines = result.lines.map((line) => {\n      const updatedText = line.text.replace(new RegExp(`\\\\b${oldWord}\\\\b`, 'gi'), newWord);\n      return updatedText;\n    });\n\n    this.poemText.set(updatedLines.join('\\n'));\n    this.analyze(result.form, updatedLines);\n    this.selectWordEnhanced(null);\n  }\n\n  clear(): void {\n    this.result.set(null);\n    this.selectedWord.set(null);\n    this.wordAlternatives.set(null);\n    this.qualityMetrics.set(null);\n    this.rhythmSuggestions.set([]);\n    this.poemText.set('');\n  }\n\n  private detectPatterns(lines: EnhancedLineAnalysis[]): string[] {\n    const patterns: string[] = [];\n\n    // Detectar patrones basados en el análisis real\n    const stressPatterns = lines.map((l) => l.stresses).filter((s) => s);\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent stress pattern: ${firstPattern}`);\n      }\n    }\n\n    // Detectar aliteraciones en el poema actual\n    const linesWithAlliteration = lines.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length > 0) {\n      patterns.push(\n        `${linesWithAlliteration.length} line${\n          linesWithAlliteration.length > 1 ? 's' : ''\n        } contain alliteration`\n      );\n    }\n\n    // Análisis de vocabulario del poema actual\n    const allWords = lines.flatMap((l) => l.words);\n    const nouns = allWords.filter((w) => w.pos.startsWith('nn')).length;\n    const verbs = allWords.filter((w) => w.pos.startsWith('vb')).length;\n    const adjectives = allWords.filter((w) => w.pos.startsWith('jj')).length;\n    const adverbs = allWords.filter((w) => w.pos.startsWith('rb')).length;\n\n    if (nouns > verbs * 2) {\n      patterns.push('Noun-heavy composition (descriptive style)');\n    } else if (verbs > nouns * 1.5) {\n      patterns.push('Verb-heavy composition (active style)');\n    }\n\n    if (adjectives > allWords.length * 0.2) {\n      patterns.push('High use of adjectives (vivid imagery)');\n    }\n\n    if (adverbs > allWords.length * 0.15) {\n      patterns.push('Adverb-rich language (detailed action)');\n    }\n\n    // Análisis de longitud de palabras\n    const avgWordLength =\n      allWords.reduce((sum, w) => sum + w.word.length, 0) / (allWords.length || 1);\n    if (avgWordLength > 6) {\n      patterns.push('Complex vocabulary (long words)');\n    } else if (avgWordLength < 4) {\n      patterns.push('Simple vocabulary (short words)');\n    }\n\n    return patterns;\n  }\n\n  private generateMeterPatterns(meter: MeterAnalysis): string[] {\n    const patterns: string[] = [];\n\n    if (meter.consistency > 70) {\n      patterns.push(`Strong ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    } else if (meter.consistency > 40) {\n      patterns.push(`Emerging ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    }\n\n    if (meter.type !== 'irregular') {\n      patterns.push(`Meter: ${meter.pattern}`);\n    }\n\n    return patterns;\n  }\n\n  private generateEnhancedSuggestions(\n    lineAnalyses: EnhancedLineAnalysis[],\n    pattern: number[],\n    meterAnalysis: MeterAnalysis\n  ): string[] {\n    const suggestions: string[] = [];\n\n    // Sugerencias basadas en la estructura del poema actual\n    if (lineAnalyses.length < pattern.length) {\n      const missing = pattern.length - lineAnalyses.length;\n      suggestions.push(`Add ${missing} more line${missing > 1 ? 's' : ''} to complete the pattern`);\n    } else if (lineAnalyses.length > pattern.length) {\n      const extra = lineAnalyses.length - pattern.length;\n      suggestions.push(`Remove ${extra} line${extra > 1 ? 's' : ''} to match the pattern`);\n    }\n\n    // Sugerencias rítmicas basadas en el análisis métrico\n    if (meterAnalysis.consistency < 60) {\n      suggestions.push(\n        `Improve rhythm consistency: ${meterAnalysis.type} meter detected but inconsistent`\n      );\n    }\n\n    if (meterAnalysis.type === 'irregular' && lineAnalyses.length > 2) {\n      suggestions.push('Consider using a regular meter pattern for better poetic flow');\n    }\n\n    // Sugerencias específicas por línea\n    lineAnalyses.forEach((line, index) => {\n      if (!line.match && index < pattern.length) {\n        const lineSuggestions = this.rita.generateSuggestions(line.text, pattern[index]);\n        suggestions.push(`Line ${index + 1}: ${lineSuggestions[0]}`);\n\n        const diff = pattern[index] - line.count;\n        if (diff > 0) {\n          const shortWords = line.words.filter((w) => w.syllables === 1);\n          if (shortWords.length > 0) {\n            suggestions.push(`  → Try replacing \"${shortWords[0].word}\" with a longer synonym`);\n          }\n        } else if (diff < 0) {\n          const longWords = line.words\n            .filter((w) => w.syllables > 2)\n            .sort((a, b) => b.syllables - a.syllables);\n          if (longWords.length > 0) {\n            suggestions.push(\n              `  → Try replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter word`\n            );\n          }\n        }\n      }\n    });\n\n    // Sugerencias de dispositivos literarios\n    const linesWithAlliteration = lineAnalyses.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length === 0 && lineAnalyses.length > 2) {\n      suggestions.push('Consider adding alliteration for poetic effect');\n    }\n\n    const hasRhyme = lineAnalyses.some((line) =>\n      line.words.some(\n        (word) => (word.pos && word.pos.startsWith('nn')) || word.pos.startsWith('vb')\n      )\n    );\n    if (!hasRhyme && lineAnalyses.length > 1) {\n      suggestions.push('Try incorporating rhyme for musical quality');\n    }\n\n    return suggestions.slice(0, 6);\n  }\n\n  private getPreviousWord(words: { word: string }[], currentWord: string): string | undefined {\n    const currentIndex = words.findIndex((w) => w.word.toLowerCase() === currentWord.toLowerCase());\n    return currentIndex > 0 ? words[currentIndex - 1].word : undefined;\n  }\n\n  private createResultForQualityAssessment(\n    formKey: string,\n    lineAnalyses: EnhancedLineAnalysis[]\n  ): EnhancedPoetryResult {\n    const form = POETRY_FORMS[formKey];\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n    return {\n      ok,\n      form: formKey,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      lines: lineAnalyses,\n      summary: '',\n      suggestions: [],\n      overallAlliterations: [],\n      detectedPatterns: [],\n    };\n  }\n\n  isCompletePoem(): boolean {\n    const result = this.result();\n    if (!result) return false;\n\n    return (\n      result.lines.length === result.totalLines.expected && result.lines.every((line) => line.match)\n    );\n  }\n\n  getQuickStats(): {\n    totalSyllables: number;\n    avgSyllablesPerLine: number;\n    vocabularyRichness: number;\n  } {\n    const result = this.result();\n    if (!result || result.lines.length === 0) {\n      return { totalSyllables: 0, avgSyllablesPerLine: 0, vocabularyRichness: 0 };\n    }\n\n    const totalSyllables = result.lines.reduce((sum, line) => sum + line.count, 0);\n    const avgSyllablesPerLine = totalSyllables / result.lines.length;\n\n    const allWords = result.lines.flatMap((line) => line.words.map((w) => w.word.toLowerCase()));\n    const uniqueWords = new Set(allWords);\n    const vocabularyRichness = (uniqueWords.size / allWords.length) * 100;\n\n    return {\n      totalSyllables,\n      avgSyllablesPerLine: Math.round(avgSyllablesPerLine * 10) / 10,\n      vocabularyRichness: Math.round(vocabularyRichness * 10) / 10,\n    };\n  }\n}\n",
            "properties": [
                {
                    "name": "detectedPatterns",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 49
                },
                {
                    "name": "form",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 39
                },
                {
                    "name": "lines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "EnhancedLineAnalysis[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 44
                },
                {
                    "name": "meterAnalysis",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MeterAnalysis",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 55
                },
                {
                    "name": "ok",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 38
                },
                {
                    "name": "overallAlliterations",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "AlliterationMatch[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 48
                },
                {
                    "name": "rhymeScheme",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 46
                },
                {
                    "name": "suggestions",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 47
                },
                {
                    "name": "summary",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 45
                },
                {
                    "name": "totalLines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 40
                },
                {
                    "name": "typos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 50
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "GrammaticalAnalysis",
            "id": "interface-GrammaticalAnalysis-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "conjugations",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 64
                },
                {
                    "name": "isAdjective",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 62
                },
                {
                    "name": "isAdverb",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 63
                },
                {
                    "name": "isNoun",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 60
                },
                {
                    "name": "isVerb",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 61
                },
                {
                    "name": "pluralForm",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 65
                },
                {
                    "name": "pos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 58
                },
                {
                    "name": "posLabel",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 59
                },
                {
                    "name": "stemForm",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 66
                },
                {
                    "name": "word",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 57
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "LineAnalysis",
            "id": "interface-LineAnalysis-9f2e5258c8513a233d7e44d78b9506fca3eaeaafe3f4b50c162e9e041de2e3840e9864cfac6cecc24684c7a1eef955a1eafc933f527dada08a89fe2e14324029",
            "file": "src/app/models/poetry.model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface PoetryForm {\n  id: string;\n  name: string;\n  pattern: number[];\n  lines: number;\n  origin: string;\n  description: string;\n}\n\nexport interface LineAnalysis {\n  text: string;\n  count: number;\n  expected: number;\n  match: boolean;\n  syllables: string[];\n  stresses?: string;\n}\n\nexport interface PoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: LineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n}\n\nexport interface MeterAnalysis {\n  pattern: string;\n  type: string;\n  consistency: number;\n}\n",
            "properties": [
                {
                    "name": "count",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 12
                },
                {
                    "name": "expected",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 13
                },
                {
                    "name": "match",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 14
                },
                {
                    "name": "stresses",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15
                },
                {
                    "name": "text",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 11
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "MeterAnalysis",
            "id": "interface-MeterAnalysis-9f2e5258c8513a233d7e44d78b9506fca3eaeaafe3f4b50c162e9e041de2e3840e9864cfac6cecc24684c7a1eef955a1eafc933f527dada08a89fe2e14324029",
            "file": "src/app/models/poetry.model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface PoetryForm {\n  id: string;\n  name: string;\n  pattern: number[];\n  lines: number;\n  origin: string;\n  description: string;\n}\n\nexport interface LineAnalysis {\n  text: string;\n  count: number;\n  expected: number;\n  match: boolean;\n  syllables: string[];\n  stresses?: string;\n}\n\nexport interface PoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: LineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n}\n\nexport interface MeterAnalysis {\n  pattern: string;\n  type: string;\n  consistency: number;\n}\n",
            "properties": [
                {
                    "name": "consistency",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 35
                },
                {
                    "name": "pattern",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 33
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 34
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "MeterAnalysis",
            "id": "interface-MeterAnalysis-c8ff5e422e8554e34650a202a0a41732300cf56a1ad0853b3fc676499f4c2ce0c687dd9ecb78f3df657e4274fec3fdc34b0adea4b92825d6d4813ddbc9d71d07-1",
            "file": "src/app/services/poetry/meter-analysis.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService } from './rita.service';\n\nexport type MeterType = 'iambic' | 'trochaic' | 'anapestic' | 'dactylic' | 'irregular';\n\nexport interface MeterAnalysis {\n  type: MeterType;\n  consistency: number;\n  pattern: string;\n  description: string;\n  examples: string[];\n}\n\nexport interface RhythmSuggestion {\n  line: number;\n  current: string;\n  issue: string;\n  suggestion: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class MeterAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  detectMeter(lines: string[]): MeterAnalysis {\n    const stressPatterns = lines\n      .map((line) => this.rita.analyzeLine(line).stresses)\n      .filter((s) => s && s.length > 0);\n\n    if (stressPatterns.length === 0) {\n      return this.getIrregularMeter();\n    }\n\n    const meterCounts = {\n      iambic: 0,\n      trochaic: 0,\n      anapestic: 0,\n      dactylic: 0,\n    };\n\n    stressPatterns.forEach((pattern) => {\n      const stresses = pattern.split('/').map((s) => parseInt(s));\n      const type = this.classifyStressPattern(stresses);\n      if (type !== 'irregular') {\n        meterCounts[type]++;\n      }\n    });\n\n    const total = stressPatterns.length;\n    const dominant = Object.entries(meterCounts).sort(([, a], [, b]) => b - a)[0];\n\n    if (!dominant) {\n      return this.getIrregularMeter();\n    }\n\n    const [type, count] = dominant as [MeterType, number];\n    const consistency = (count / total) * 100;\n\n    if (consistency < 40) {\n      return this.getIrregularMeter();\n    }\n\n    return {\n      type,\n      consistency,\n      pattern: this.getMeterPattern(type),\n      description: this.getMeterDescription(type),\n      examples: this.getMeterExamples(type),\n    };\n  }\n\n  private classifyStressPattern(stresses: number[]): MeterType | 'irregular' {\n    if (stresses.length < 2) return 'irregular';\n\n    const pairs: string[] = [];\n    for (let i = 0; i < stresses.length - 1; i++) {\n      pairs.push(`${stresses[i]}${stresses[i + 1]}`);\n    }\n\n    const pairCounts = {\n      '01': 0,\n      '10': 0,\n      '001': 0,\n      '100': 0,\n    };\n\n    pairs.forEach((pair) => {\n      if (pair === '01') pairCounts['01']++;\n      if (pair === '10') pairCounts['10']++;\n    });\n\n    for (let i = 0; i < stresses.length - 2; i++) {\n      const triplet = `${stresses[i]}${stresses[i + 1]}${stresses[i + 2]}`;\n      if (triplet === '001') pairCounts['001']++;\n      if (triplet === '100') pairCounts['100']++;\n    }\n\n    const max = Math.max(...Object.values(pairCounts));\n    if (max === 0) return 'irregular';\n\n    if (pairCounts['01'] === max) return 'iambic';\n    if (pairCounts['10'] === max) return 'trochaic';\n    if (pairCounts['001'] === max) return 'anapestic';\n    if (pairCounts['100'] === max) return 'dactylic';\n\n    return 'irregular';\n  }\n\n  generateRhythmSuggestions(lines: string[], targetMeter?: MeterType): RhythmSuggestion[] {\n    const suggestions: RhythmSuggestion[] = [];\n    const detectedMeter = this.detectMeter(lines);\n    const target = targetMeter || detectedMeter.type;\n\n    if (target === 'irregular') {\n      return suggestions;\n    }\n\n    lines.forEach((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      if (!analysis.stresses) return;\n\n      const stresses = analysis.stresses.split('/').map((s) => parseInt(s));\n      const lineType = this.classifyStressPattern(stresses);\n\n      if (lineType !== target) {\n        suggestions.push({\n          line: index + 1,\n          current: analysis.stresses,\n          issue: `This line follows a ${lineType} pattern instead of ${target}`,\n          suggestion: `Try restructuring to match the ${target} rhythm (${this.getMeterPattern(\n            target\n          )})`,\n        });\n      }\n    });\n\n    return suggestions;\n  }\n\n  private getMeterPattern(type: MeterType): string {\n    const patterns: Record<MeterType, string> = {\n      iambic: 'da-DUM (0/1)',\n      trochaic: 'DUM-da (1/0)',\n      anapestic: 'da-da-DUM (0/0/1)',\n      dactylic: 'DUM-da-da (1/0/0)',\n      irregular: 'mixed or free verse',\n    };\n    return patterns[type];\n  }\n\n  private getMeterDescription(type: MeterType): string {\n    const descriptions: Record<MeterType, string> = {\n      iambic: 'Most common in English poetry. Sounds natural and flowing.',\n      trochaic: \"Strong, emphatic rhythm. Common in children's verse.\",\n      anapestic: 'Galloping, energetic rhythm. Creates sense of movement.',\n      dactylic: 'Falling rhythm. Rare in English, common in ancient Greek.',\n      irregular: 'No consistent metrical pattern. Free verse or mixed meters.',\n    };\n    return descriptions[type];\n  }\n\n  private getMeterExamples(type: MeterType): string[] {\n    const examples: Record<MeterType, string[]> = {\n      iambic: [\n        \"Shall I compare thee to a summer's day?\",\n        'The curfew tolls the knell of parting day',\n      ],\n      trochaic: ['Tell me not in mournful numbers', 'Tiger, tiger, burning bright'],\n      anapestic: ['Twas the night before Christmas', 'And the sound of a voice that is still'],\n      dactylic: ['This is the forest primeval', 'Cannon to right of them'],\n      irregular: ['Free verse has no set pattern', 'Modern poetry often breaks rules'],\n    };\n    return examples[type];\n  }\n\n  private getIrregularMeter(): MeterAnalysis {\n    return {\n      type: 'irregular',\n      consistency: 0,\n      pattern: 'mixed or free verse',\n      description:\n        'No consistent metrical pattern detected. This could be free verse or mixed meters.',\n      examples: [],\n    };\n  }\n}\n",
            "properties": [
                {
                    "name": "consistency",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "description",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 10
                },
                {
                    "name": "examples",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 11
                },
                {
                    "name": "pattern",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MeterType",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": [],
            "isDuplicate": true,
            "duplicateId": 1,
            "duplicateName": "MeterAnalysis-1"
        },
        {
            "name": "PoetryForm",
            "id": "interface-PoetryForm-9f2e5258c8513a233d7e44d78b9506fca3eaeaafe3f4b50c162e9e041de2e3840e9864cfac6cecc24684c7a1eef955a1eafc933f527dada08a89fe2e14324029",
            "file": "src/app/models/poetry.model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface PoetryForm {\n  id: string;\n  name: string;\n  pattern: number[];\n  lines: number;\n  origin: string;\n  description: string;\n}\n\nexport interface LineAnalysis {\n  text: string;\n  count: number;\n  expected: number;\n  match: boolean;\n  syllables: string[];\n  stresses?: string;\n}\n\nexport interface PoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: LineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n}\n\nexport interface MeterAnalysis {\n  pattern: string;\n  type: string;\n  consistency: number;\n}\n",
            "properties": [
                {
                    "name": "description",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 2
                },
                {
                    "name": "lines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 3
                },
                {
                    "name": "origin",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "pattern",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 4
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "PoetryResult",
            "id": "interface-PoetryResult-9f2e5258c8513a233d7e44d78b9506fca3eaeaafe3f4b50c162e9e041de2e3840e9864cfac6cecc24684c7a1eef955a1eafc933f527dada08a89fe2e14324029",
            "file": "src/app/models/poetry.model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface PoetryForm {\n  id: string;\n  name: string;\n  pattern: number[];\n  lines: number;\n  origin: string;\n  description: string;\n}\n\nexport interface LineAnalysis {\n  text: string;\n  count: number;\n  expected: number;\n  match: boolean;\n  syllables: string[];\n  stresses?: string;\n}\n\nexport interface PoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: LineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n}\n\nexport interface MeterAnalysis {\n  pattern: string;\n  type: string;\n  consistency: number;\n}\n",
            "properties": [
                {
                    "name": "form",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 21
                },
                {
                    "name": "lines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "LineAnalysis[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 26
                },
                {
                    "name": "ok",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 20
                },
                {
                    "name": "rhymeScheme",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 28
                },
                {
                    "name": "suggestions",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 29
                },
                {
                    "name": "summary",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 27
                },
                {
                    "name": "totalLines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "PoetryStructure",
            "id": "interface-PoetryStructure-87839deece079bc7847173139a67015b54b1d00fdeef757ab3e95c0a0bdf68b78cba002925ff807dfb5be309a363c259bd762ca785914d525a6a44d20747e0bd",
            "file": "src/app/services/poetry/poetry-analysis.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService } from './rita.service';\nimport { POETRY_FORMS } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface PoetryStructure {\n  lines: LineAnalysis[];\n  totalLines: { expected: number; actual: number };\n  ok: boolean;\n  summary: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  analyzePoemStructure(rawLines: string[], formKey: string): PoetryStructure {\n    const form = POETRY_FORMS[formKey];\n    if (!form) {\n      throw new Error(`Unknown form \"${formKey}\"`);\n    }\n\n    const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n    const lineAnalyses: LineAnalysis[] = lines.map((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      const expected = form.pattern[index] ?? 0;\n\n      return {\n        text: line,\n        count: analysis.syllables,\n        expected,\n        match: analysis.syllables === expected,\n        syllables: analysis.breakdown,\n        stresses: analysis.stresses,\n      };\n    });\n\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n    const mismatches = lineAnalyses.filter((l) => !l.match).length;\n    const summary = ok\n      ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n          '-'\n        )} pattern`\n      : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n    return {\n      lines: lineAnalyses,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      ok,\n      summary,\n    };\n  }\n\n  validateLineSyllables(\n    line: string,\n    expectedSyllables: number\n  ): { valid: boolean; actual: number } {\n    const analysis = this.rita.analyzeLine(line);\n    return {\n      valid: analysis.syllables === expectedSyllables,\n      actual: analysis.syllables,\n    };\n  }\n\n  calculateSyllableAccuracy(lines: string[], pattern: number[]): number {\n    if (lines.length !== pattern.length) return 0;\n\n    let matches = 0;\n    lines.forEach((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      if (analysis.syllables === pattern[index]) {\n        matches++;\n      }\n    });\n\n    return (matches / pattern.length) * 100;\n  }\n\n  detectMeterPattern(lines: string[]): string[] {\n    const patterns: string[] = [];\n    const stressPatterns = lines\n      .map((line) => {\n        const analysis = this.rita.analyzeLine(line);\n        return analysis.stresses;\n      })\n      .filter((s) => s && s.length > 0);\n\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent meter: ${firstPattern}`);\n      }\n    }\n\n    return patterns;\n  }\n}\n",
            "properties": [
                {
                    "name": "lines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "LineAnalysis[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "ok",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "summary",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 10
                },
                {
                    "name": "totalLines",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "QualityMetrics",
            "id": "interface-QualityMetrics-7ce486a65750df1898e54ad355d397e9260f98fe45ae68caa60242e267f5634701e7c08a6a7f0953319376c9e4cf54f03e3ba75dc7c2cb9a7365b440b75ed93d",
            "file": "src/app/services/poetry/poem-quality.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { RitaService } from './rita.service';\nimport type { EnhancedPoetryResult } from './poetry-analyzer.service';\n\nexport interface QualityMetrics {\n  score: number;\n  breakdown: {\n    syllableAccuracy: number;\n    phoneticsRichness: number;\n    vocabularyDiversity: number;\n    rhythmConsistency: number;\n    rhetoricalDevices: number;\n  };\n  strengths: string[];\n  improvements: string[];\n  grade: 'A+' | 'A' | 'B+' | 'B' | 'C+' | 'C' | 'D' | 'F';\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoemQualityService {\n  private readonly rita = inject(RitaService);\n\n  assessQuality(lines: string[], pattern: number[], result: EnhancedPoetryResult): QualityMetrics {\n    const metrics = {\n      syllableAccuracy: this.calculateSyllableAccuracy(result, pattern),\n      phoneticsRichness: this.calculatePhoneticRichness(lines),\n      vocabularyDiversity: this.calculateVocabularyDiversity(lines),\n      rhythmConsistency: this.calculateRhythmConsistency(result),\n      rhetoricalDevices: this.calculateRhetoricalDevices(result),\n    };\n\n    const score = this.computeOverallScore(metrics);\n    const grade = this.assignGrade(score);\n    const strengths = this.identifyStrengths(metrics);\n    const improvements = this.suggestImprovements(metrics);\n\n    return {\n      score,\n      breakdown: metrics,\n      strengths,\n      improvements,\n      grade,\n    };\n  }\n\n  private calculateSyllableAccuracy(result: EnhancedPoetryResult, pattern: number[]): number {\n    if (result.lines.length !== pattern.length) return 0;\n\n    const matches = result.lines.filter((line) => line.match).length;\n    return (matches / pattern.length) * 100;\n  }\n\n  private calculatePhoneticRichness(lines: string[]): number {\n    const text = lines.join(' ');\n    const words = RiTa.tokens(text);\n\n    if (words.length === 0) return 0;\n\n    const uniquePhonemes = new Set<string>();\n    words.forEach((word) => {\n      const phones = RiTa.phones(word);\n      if (phones) {\n        phones.split('-').forEach((p) => uniquePhonemes.add(p));\n      }\n    });\n\n    return Math.min(100, (uniquePhonemes.size / 15) * 100);\n  }\n\n  private calculateVocabularyDiversity(lines: string[]): number {\n    const text = lines.join(' ');\n    const tokens = RiTa.tokenize(text);\n    const words = tokens.filter((t) => !RiTa.isPunct(t));\n\n    if (words.length === 0) return 0;\n\n    const unique = new Set(words.map((w) => w.toLowerCase()));\n    const ttr = unique.size / words.length;\n\n    return Math.min(100, (ttr / 0.6) * 100);\n  }\n\n  private calculateRhythmConsistency(result: EnhancedPoetryResult): number {\n    const stressPatterns = result.lines\n      .map((l) => l.stresses)\n      .filter((s): s is string => s !== undefined && s.length > 0);\n\n    if (stressPatterns.length < 2) return 50;\n\n    const firstPattern = stressPatterns[0];\n    const similarCount = stressPatterns.filter(\n      (p) => this.stressSimilarity(firstPattern, p) > 0.6\n    ).length;\n\n    return (similarCount / stressPatterns.length) * 100;\n  }\n\n  private calculateRhetoricalDevices(result: EnhancedPoetryResult): number {\n    let score = 0;\n\n    if (result.overallAlliterations.length > 0) {\n      score += Math.min(20, result.overallAlliterations.length * 5);\n    }\n\n    if (result.rhymeScheme && result.rhymeScheme !== 'A'.repeat(result.lines.length)) {\n      score += 30;\n    }\n\n    const concordance = RiTa.concordance(result.lines.map((l) => l.text).join(' '));\n    const repeatedWords = Object.values(concordance).filter((count) => count > 1).length;\n    if (repeatedWords > 0) {\n      score += Math.min(20, repeatedWords * 4);\n    }\n\n    const allWords = result.lines.flatMap((l) => l.words);\n    const uniquePOS = new Set(allWords.map((w) => w.pos));\n    if (uniquePOS.size >= 4) {\n      score += 15;\n    }\n\n    const sensoryWords = this.countSensoryWords(allWords.map((w) => w.word));\n    if (sensoryWords >= 3) {\n      score += 15;\n    }\n\n    return Math.min(100, score);\n  }\n\n  private computeOverallScore(metrics: QualityMetrics['breakdown']): number {\n    const weights = {\n      syllableAccuracy: 0.35,\n      phoneticsRichness: 0.15,\n      vocabularyDiversity: 0.2,\n      rhythmConsistency: 0.15,\n      rhetoricalDevices: 0.15,\n    };\n\n    return Object.entries(weights).reduce((total, [key, weight]) => {\n      return total + metrics[key as keyof typeof metrics] * weight;\n    }, 0);\n  }\n\n  private assignGrade(score: number): QualityMetrics['grade'] {\n    if (score >= 95) return 'A+';\n    if (score >= 90) return 'A';\n    if (score >= 85) return 'B+';\n    if (score >= 80) return 'B';\n    if (score >= 75) return 'C+';\n    if (score >= 70) return 'C';\n    if (score >= 60) return 'D';\n    return 'F';\n  }\n\n  private identifyStrengths(metrics: QualityMetrics['breakdown']): string[] {\n    const strengths: string[] = [];\n\n    if (metrics.syllableAccuracy === 100) {\n      strengths.push('Perfect syllable matching');\n    } else if (metrics.syllableAccuracy >= 80) {\n      strengths.push('Good syllable accuracy');\n    }\n\n    if (metrics.phoneticsRichness > 80) {\n      strengths.push('Rich phonetic variety');\n    }\n\n    if (metrics.vocabularyDiversity > 75) {\n      strengths.push('Diverse vocabulary');\n    }\n\n    if (metrics.rhythmConsistency > 80) {\n      strengths.push('Consistent rhythm');\n    }\n\n    if (metrics.rhetoricalDevices > 70) {\n      strengths.push('Strong use of literary devices');\n    }\n\n    return strengths.length > 0 ? strengths : ['Good foundation - keep practicing!'];\n  }\n\n  private suggestImprovements(metrics: QualityMetrics['breakdown']): string[] {\n    const improvements: string[] = [];\n\n    if (metrics.syllableAccuracy < 100) {\n      improvements.push('Adjust syllable counts to match the pattern');\n    }\n\n    if (metrics.phoneticsRichness < 60) {\n      improvements.push('Use more varied sounds and phonemes');\n    }\n\n    if (metrics.vocabularyDiversity < 50) {\n      improvements.push('Avoid repeating the same words');\n    }\n\n    if (metrics.rhythmConsistency < 60) {\n      improvements.push('Create more consistent stress patterns');\n    }\n\n    if (metrics.rhetoricalDevices < 50) {\n      improvements.push('Add alliteration, rhyme, or other literary devices');\n    }\n\n    return improvements.length > 0\n      ? improvements\n      : ['Excellent work! Consider experimenting with more complex forms.'];\n  }\n\n  private stressSimilarity(pattern1: string, pattern2: string): number {\n    const arr1 = pattern1.split('/');\n    const arr2 = pattern2.split('/');\n    const maxLen = Math.max(arr1.length, arr2.length);\n\n    let matches = 0;\n    for (let i = 0; i < maxLen; i++) {\n      if (arr1[i] === arr2[i]) matches++;\n    }\n\n    return matches / maxLen;\n  }\n\n  private countSensoryWords(words: string[]): number {\n    const sensoryPatterns = [\n      /bright|dark|color|hue|shade/i,\n      /loud|quiet|sound|music|voice|echo/i,\n      /soft|hard|smooth|rough|warm|cold/i,\n      /sweet|bitter|fragrant|scent|smell/i,\n      /taste|flavor|savory|delicious/i,\n    ];\n\n    return words.filter((word) => sensoryPatterns.some((pattern) => pattern.test(word))).length;\n  }\n}\n",
            "properties": [
                {
                    "name": "breakdown",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "grade",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "\"A+\" | \"A\" | \"B+\" | \"B\" | \"C+\" | \"C\" | \"D\" | \"F\"",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "improvements",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "score",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "strengths",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "QuickStats",
            "id": "interface-QuickStats-adb9d00591ba62e85d96b36572bd9ee90487f799978398ea24a1c5c2540d976ad34f768888ebd52f01e34b9dda05e6936e6bcc7182796135f68827978d87ef23",
            "file": "src/app/components/quick-stats-panel/quick-stats-panel.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CardComponent } from '../card/card.component';\nimport { BadgeComponent } from '../badge/badge.component';\n\nexport interface QuickStats {\n  totalSyllables: number;\n  avgSyllablesPerLine: number;\n  vocabularyRichness: number;\n  patternMatch: string;\n}\n\n@Component({\n  selector: 'app-quick-stats-panel',\n  standalone: true,\n  imports: [CardComponent, BadgeComponent],\n  templateUrl: './quick-stats-panel.component.html',\n})\nexport class QuickStatsPanelComponent {\n  @Input({ required: true }) stats!: QuickStats;\n}\n",
            "properties": [
                {
                    "name": "avgSyllablesPerLine",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "patternMatch",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "totalSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "vocabularyRichness",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "RhymeMatch",
            "id": "interface-RhymeMatch-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "nearRhymes",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 43
                },
                {
                    "name": "perfectRhymes",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 42
                },
                {
                    "name": "rhymesWith",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 41
                },
                {
                    "name": "word",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 40
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "RhythmSuggestion",
            "id": "interface-RhythmSuggestion-c8ff5e422e8554e34650a202a0a41732300cf56a1ad0853b3fc676499f4c2ce0c687dd9ecb78f3df657e4274fec3fdc34b0adea4b92825d6d4813ddbc9d71d07",
            "file": "src/app/services/poetry/meter-analysis.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService } from './rita.service';\n\nexport type MeterType = 'iambic' | 'trochaic' | 'anapestic' | 'dactylic' | 'irregular';\n\nexport interface MeterAnalysis {\n  type: MeterType;\n  consistency: number;\n  pattern: string;\n  description: string;\n  examples: string[];\n}\n\nexport interface RhythmSuggestion {\n  line: number;\n  current: string;\n  issue: string;\n  suggestion: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class MeterAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  detectMeter(lines: string[]): MeterAnalysis {\n    const stressPatterns = lines\n      .map((line) => this.rita.analyzeLine(line).stresses)\n      .filter((s) => s && s.length > 0);\n\n    if (stressPatterns.length === 0) {\n      return this.getIrregularMeter();\n    }\n\n    const meterCounts = {\n      iambic: 0,\n      trochaic: 0,\n      anapestic: 0,\n      dactylic: 0,\n    };\n\n    stressPatterns.forEach((pattern) => {\n      const stresses = pattern.split('/').map((s) => parseInt(s));\n      const type = this.classifyStressPattern(stresses);\n      if (type !== 'irregular') {\n        meterCounts[type]++;\n      }\n    });\n\n    const total = stressPatterns.length;\n    const dominant = Object.entries(meterCounts).sort(([, a], [, b]) => b - a)[0];\n\n    if (!dominant) {\n      return this.getIrregularMeter();\n    }\n\n    const [type, count] = dominant as [MeterType, number];\n    const consistency = (count / total) * 100;\n\n    if (consistency < 40) {\n      return this.getIrregularMeter();\n    }\n\n    return {\n      type,\n      consistency,\n      pattern: this.getMeterPattern(type),\n      description: this.getMeterDescription(type),\n      examples: this.getMeterExamples(type),\n    };\n  }\n\n  private classifyStressPattern(stresses: number[]): MeterType | 'irregular' {\n    if (stresses.length < 2) return 'irregular';\n\n    const pairs: string[] = [];\n    for (let i = 0; i < stresses.length - 1; i++) {\n      pairs.push(`${stresses[i]}${stresses[i + 1]}`);\n    }\n\n    const pairCounts = {\n      '01': 0,\n      '10': 0,\n      '001': 0,\n      '100': 0,\n    };\n\n    pairs.forEach((pair) => {\n      if (pair === '01') pairCounts['01']++;\n      if (pair === '10') pairCounts['10']++;\n    });\n\n    for (let i = 0; i < stresses.length - 2; i++) {\n      const triplet = `${stresses[i]}${stresses[i + 1]}${stresses[i + 2]}`;\n      if (triplet === '001') pairCounts['001']++;\n      if (triplet === '100') pairCounts['100']++;\n    }\n\n    const max = Math.max(...Object.values(pairCounts));\n    if (max === 0) return 'irregular';\n\n    if (pairCounts['01'] === max) return 'iambic';\n    if (pairCounts['10'] === max) return 'trochaic';\n    if (pairCounts['001'] === max) return 'anapestic';\n    if (pairCounts['100'] === max) return 'dactylic';\n\n    return 'irregular';\n  }\n\n  generateRhythmSuggestions(lines: string[], targetMeter?: MeterType): RhythmSuggestion[] {\n    const suggestions: RhythmSuggestion[] = [];\n    const detectedMeter = this.detectMeter(lines);\n    const target = targetMeter || detectedMeter.type;\n\n    if (target === 'irregular') {\n      return suggestions;\n    }\n\n    lines.forEach((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      if (!analysis.stresses) return;\n\n      const stresses = analysis.stresses.split('/').map((s) => parseInt(s));\n      const lineType = this.classifyStressPattern(stresses);\n\n      if (lineType !== target) {\n        suggestions.push({\n          line: index + 1,\n          current: analysis.stresses,\n          issue: `This line follows a ${lineType} pattern instead of ${target}`,\n          suggestion: `Try restructuring to match the ${target} rhythm (${this.getMeterPattern(\n            target\n          )})`,\n        });\n      }\n    });\n\n    return suggestions;\n  }\n\n  private getMeterPattern(type: MeterType): string {\n    const patterns: Record<MeterType, string> = {\n      iambic: 'da-DUM (0/1)',\n      trochaic: 'DUM-da (1/0)',\n      anapestic: 'da-da-DUM (0/0/1)',\n      dactylic: 'DUM-da-da (1/0/0)',\n      irregular: 'mixed or free verse',\n    };\n    return patterns[type];\n  }\n\n  private getMeterDescription(type: MeterType): string {\n    const descriptions: Record<MeterType, string> = {\n      iambic: 'Most common in English poetry. Sounds natural and flowing.',\n      trochaic: \"Strong, emphatic rhythm. Common in children's verse.\",\n      anapestic: 'Galloping, energetic rhythm. Creates sense of movement.',\n      dactylic: 'Falling rhythm. Rare in English, common in ancient Greek.',\n      irregular: 'No consistent metrical pattern. Free verse or mixed meters.',\n    };\n    return descriptions[type];\n  }\n\n  private getMeterExamples(type: MeterType): string[] {\n    const examples: Record<MeterType, string[]> = {\n      iambic: [\n        \"Shall I compare thee to a summer's day?\",\n        'The curfew tolls the knell of parting day',\n      ],\n      trochaic: ['Tell me not in mournful numbers', 'Tiger, tiger, burning bright'],\n      anapestic: ['Twas the night before Christmas', 'And the sound of a voice that is still'],\n      dactylic: ['This is the forest primeval', 'Cannon to right of them'],\n      irregular: ['Free verse has no set pattern', 'Modern poetry often breaks rules'],\n    };\n    return examples[type];\n  }\n\n  private getIrregularMeter(): MeterAnalysis {\n    return {\n      type: 'irregular',\n      consistency: 0,\n      pattern: 'mixed or free verse',\n      description:\n        'No consistent metrical pattern detected. This could be free verse or mixed meters.',\n      examples: [],\n    };\n  }\n}\n",
            "properties": [
                {
                    "name": "current",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "issue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "line",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15
                },
                {
                    "name": "suggestion",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 18
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "SelectOption",
            "id": "interface-SelectOption-3d3b3a668c59b4c80e2beae9f494be39347e4d0b0c447b11b5aa7a9376f4e3b82c1289dffb65c84d1a0aa2f0974374d1df99eeaabcb1fbf2257e6342344964ef",
            "file": "src/app/components/select/select.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Component, Input, Output, EventEmitter, forwardRef } from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\n\nexport interface SelectOption {\n  value: string;\n  label: string;\n  description?: string;\n}\n\n@Component({\n  selector: 'app-select',\n  standalone: true,\n  templateUrl: './select.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => SelectComponent),\n      multi: true,\n    },\n  ],\n})\nexport class SelectComponent implements ControlValueAccessor {\n  @Input() options: SelectOption[] = [];\n  @Input() label = '';\n  @Input() disabled = false;\n  @Input() id = '';\n\n  @Input()\n  get value(): string {\n    return this._value;\n  }\n  set value(val: string) {\n    this._value = val || '';\n    this.onChange(this._value);\n  }\n\n  _value = '';\n\n  @Output() selectChange = new EventEmitter<string>();\n\n  private onChange: (value: string) => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private onTouched: () => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n\n  writeValue(value: string): void {\n    this._value = value || '';\n  }\n\n  registerOnChange(fn: (value: string) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  onSelectChange(event: Event): void {\n    const target = event.target as HTMLSelectElement;\n    this._value = target.value;\n    this.onChange(this._value);\n    this.selectChange.emit(this._value);\n  }\n\n  onBlur(): void {\n    this.onTouched();\n  }\n}\n",
            "properties": [
                {
                    "name": "description",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "SuggestionContext",
            "id": "interface-SuggestionContext-24eb12fada130bc88b863f4d93cc015155ad8963e6b439cd89626c34ffadb8c508817746d6d4f5f7e11b910ca3bb30339b231a1a9016833254b2677222c8462e",
            "file": "src/app/services/poetry/poetry-suggestions.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService, type AlternativeWord } from './rita.service';\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\nexport interface SuggestionContext {\n  pos?: string;\n  lineIndex?: number;\n  isLineEnd?: boolean;\n  previousWord?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetrySuggestionsService {\n  private readonly rita = inject(RitaService);\n\n  async getWordAlternativesEnhanced(\n    word: string,\n    targetSyllables: number,\n    context: SuggestionContext = {}\n  ): Promise<WordSuggestionData> {\n    const currentSyllables = this.rita.analyzeLine(word).syllables;\n\n    // Búsqueda simple y efectiva - CORREGIR parámetros\n    const [exactMatches, rhymes, phonetic] = await Promise.all([\n      this.searchBySyllables(targetSyllables), // ❌ Eliminar context.pos\n      context.isLineEnd\n        ? this.rita.findRhymes(word, targetSyllables).then((r) => r.perfectRhymes)\n        : Promise.resolve([]),\n      this.rita.suggestAlternatives(word, targetSyllables, 6),\n    ]);\n\n    const allAlternatives = [\n      ...exactMatches,\n      ...rhymes.map((w) => ({\n        word: w, // ✅ w es string, no AlternativeWord\n        syllables: targetSyllables,\n        reason: 'rhyme-match' as const,\n        pos: this.rita.analyzeGrammar(w).pos,\n      })),\n      ...phonetic,\n    ];\n\n    const unique = this.deduplicateAndRank(allAlternatives, word, context);\n\n    return {\n      original: word,\n      currentSyllables,\n      targetSyllables,\n      alternatives: unique.slice(0, 10),\n    };\n  }\n\n  private async searchBySyllables(syllables: number): Promise<AlternativeWord[]> {\n    // ❌ Eliminar pos parameter\n    try {\n      // Búsqueda simple por primera letra y sílabas\n      const results = await this.rita.suggestAlternatives('a', syllables, 8);\n\n      // CORREGIR: results ya son AlternativeWord[], no strings\n      return results.map((altWord) => ({\n        // ✅ altWord es AlternativeWord\n        ...altWord,\n        reason: 'exact-match' as const,\n      }));\n    } catch (error) {\n      console.warn('Search by syllables failed:', error);\n      return [];\n    }\n  }\n\n  private deduplicateAndRank(\n    alternatives: AlternativeWord[],\n    originalWord: string,\n    context: SuggestionContext\n  ): AlternativeWord[] {\n    const seen = new Set<string>();\n    const unique = alternatives.filter((alt) => {\n      const key = alt.word.toLowerCase();\n      if (seen.has(key) || key === originalWord.toLowerCase()) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n\n    return unique.sort((a, b) => {\n      if (a.reason === 'exact-match' && b.reason !== 'exact-match') return -1;\n      if (b.reason === 'exact-match' && a.reason !== 'exact-match') return 1;\n\n      if (context.isLineEnd) {\n        if (a.reason === 'rhyme-match' && b.reason !== 'rhyme-match') return -1;\n        if (b.reason === 'rhyme-match' && a.reason !== 'rhyme-match') return 1;\n      }\n\n      if (context.pos) {\n        const aMatchesPOS = a.pos === context.pos;\n        const bMatchesPOS = b.pos === context.pos;\n        if (aMatchesPOS && !bMatchesPOS) return -1;\n        if (bMatchesPOS && !aMatchesPOS) return 1;\n      }\n\n      return 0;\n    });\n  }\n\n  async getWordAlternatives(word: string, targetSyllables: number): Promise<WordSuggestionData> {\n    return this.getWordAlternativesEnhanced(word, targetSyllables);\n  }\n\n  generateLineSuggestions(line: string, targetSyllables: number): string[] {\n    return this.rita.generateSuggestions(line, targetSyllables);\n  }\n}\n",
            "properties": [
                {
                    "name": "isLineEnd",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 14
                },
                {
                    "name": "lineIndex",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 13
                },
                {
                    "name": "pos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 12
                },
                {
                    "name": "previousWord",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 15
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "SyllableAnalysis",
            "id": "interface-SyllableAnalysis-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "breakdown",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "phones",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "stresses",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "Tab",
            "id": "interface-Tab-192ae07a5674905f61ca8210aa66bbe833e06114770fb1716f27a820eee787d134e3ee4c181c46e308c196513dffe79f1b27bfdb3e920a818479dea83fd3eb79",
            "file": "src/app/components/tabs/tabs.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\n\nexport interface Tab {\n  id: string;\n  label: string;\n  icon?: string;\n  disabled?: boolean;\n}\n\n@Component({\n  selector: 'app-tabs',\n  standalone: true,\n  templateUrl: './tabs.component.html',\n})\nexport class TabsComponent {\n  @Input() tabs: Tab[] = [];\n  @Input() selectedTab = '';\n  @Output() tabChange = new EventEmitter<string>();\n\n  selectTab(tabId: string): void {\n    if (this.selectedTab !== tabId) {\n      this.selectedTab = tabId;\n      this.tabChange.emit(tabId);\n    }\n  }\n}\n",
            "properties": [
                {
                    "name": "disabled",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 4
                },
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "ThemeColor",
            "id": "interface-ThemeColor-29cfd58f74de1dba14f11aa909802f2e70d9e93dcf90e3100a1d0aa8c6d81a367c96a7f818a276a876bd9065787802d4cb308f76a4f67e543e96d47808c31a60",
            "file": "src/lib/material-theme/theme.config.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {\n  SchemeTonalSpot,\n  SchemeNeutral,\n  SchemeVibrant,\n  SchemeExpressive,\n  SchemeMonochrome,\n  SchemeContent,\n  SchemeFidelity,\n  SchemeFruitSalad,\n  SchemeRainbow,\n  Hct,\n  type DynamicScheme,\n} from '@material/material-color-utilities';\n\nexport type SchemeConstructor = new (\n  sourceColorHct: Hct,\n  isDark: boolean,\n  contrastLevel: number\n) => DynamicScheme;\n\nexport const SEED_COLOR = '#F4C2C2';\n\nexport const SCHEMES: { name: string; variant: SchemeConstructor }[] = [\n  { name: 'tonal-spot', variant: SchemeTonalSpot },\n  { name: 'neutral', variant: SchemeNeutral },\n  { name: 'vibrant', variant: SchemeVibrant },\n  { name: 'expressive', variant: SchemeExpressive },\n  { name: 'monochrome', variant: SchemeMonochrome },\n  { name: 'content', variant: SchemeContent },\n  { name: 'fidelity', variant: SchemeFidelity },\n  { name: 'fruit-salad', variant: SchemeFruitSalad },\n  { name: 'rainbow', variant: SchemeRainbow },\n];\n\nexport const SELECTED_SCHEME = 'fidelity';\n\nexport const TERMINAL_COLORS_CONFIG = {\n  red: { hue: 10, chroma: 84, tone: 50 },\n  green: { hue: 145, chroma: 48, tone: 50 },\n  yellow: { hue: 90, chroma: 70, tone: 60 },\n  blue: { hue: 245, chroma: 80, tone: 50 },\n  magenta: { hue: 330, chroma: 68, tone: 50 },\n  cyan: { hue: 200, chroma: 48, tone: 50 },\n};\n\nexport const THEME_CSS_VARS = [\n  'primary',\n  'onPrimary',\n  'primaryContainer',\n  'onPrimaryContainer',\n  'secondary',\n  'onSecondary',\n  'secondaryContainer',\n  'onSecondaryContainer',\n  'tertiary',\n  'onTertiary',\n  'tertiaryContainer',\n  'onTertiaryContainer',\n  'error',\n  'onError',\n  'errorContainer',\n  'onErrorContainer',\n  'background',\n  'onBackground',\n  'surface',\n  'surfaceDim',\n  'surfaceBright',\n  'surfaceContainerLowest',\n  'surfaceContainerLow',\n  'surfaceContainer',\n  'surfaceContainerHigh',\n  'surfaceContainerHighest',\n  'onSurface',\n  'surfaceVariant',\n  'onSurfaceVariant',\n  'outline',\n  'outlineVariant',\n  'shadow',\n  'scrim',\n  'inverseSurface',\n  'inverseOnSurface',\n  'inversePrimary',\n];\n\nexport const TERMINAL_CSS_VARS = [\n  'red',\n  'redContainer',\n  'onRedContainer',\n  'green',\n  'greenContainer',\n  'onGreenContainer',\n  'yellow',\n  'yellowContainer',\n  'onYellowContainer',\n  'blue',\n  'blueContainer',\n  'onBlueContainer',\n  'magenta',\n  'magentaContainer',\n  'onMagentaContainer',\n  'cyan',\n  'cyanContainer',\n  'onCyanContainer',\n\n  'inverseRed',\n  'inverseRedContainer',\n  'inverseOnRedContainer',\n  'inverseGreen',\n  'inverseGreenContainer',\n  'inverseOnGreenContainer',\n  'inverseYellow',\n  'inverseYellowContainer',\n  'inverseOnYellowContainer',\n  'inverseBlue',\n  'inverseBlueContainer',\n  'inverseOnBlueContainer',\n  'inverseMagenta',\n  'inverseMagentaContainer',\n  'inverseOnMagentaContainer',\n  'inverseCyan',\n  'inverseCyanContainer',\n  'inverseOnCyanContainer',\n];\n\nexport const ALL_CSS_VARS = [...THEME_CSS_VARS, ...TERMINAL_CSS_VARS];\n\nexport const THEME_CONFIG = {\n  seedColor: SEED_COLOR,\n  selectedScheme: SELECTED_SCHEME,\n  availableSchemes: SCHEMES.map((s) => s.name),\n  materialVariables: THEME_CSS_VARS.length,\n  terminalVariables: TERMINAL_CSS_VARS.length,\n  totalVariables: ALL_CSS_VARS.length,\n};\n\nexport interface ThemeColor {\n  hue: number;\n  chroma: number;\n  tone: number;\n}\n\nexport type TerminalColors = keyof typeof TERMINAL_COLORS_CONFIG;\nexport type MaterialColors = (typeof THEME_CSS_VARS)[number];\nexport type AllColors = MaterialColors | TerminalColors;\n\nexport function getSchemeConstructor(schemeName: string): SchemeConstructor {\n  const scheme = SCHEMES.find((s) => s.name === schemeName);\n  if (!scheme) {\n    throw new Error(\n      `Scheme not found: ${schemeName}. Available schemes: ${SCHEMES.map((s) => s.name).join(', ')}`\n    );\n  }\n  return scheme.variant;\n}\n\nexport function isValidScheme(schemeName: string): boolean {\n  return SCHEMES.some((s) => s.name === schemeName);\n}\n\nexport function getAvailableSchemes(): string[] {\n  return SCHEMES.map((s) => s.name);\n}\n\nexport function getConfigInfo(): string {\n  return `\nTheme Configuration:\n-------------------\nSeed Color: ${SEED_COLOR}\nSelected Scheme: ${SELECTED_SCHEME}\nAvailable Schemes: ${getAvailableSchemes().join(', ')}\nMaterial Variables: ${THEME_CSS_VARS.length}\nTerminal Variables: ${TERMINAL_CSS_VARS.length}\nTotal Variables: ${ALL_CSS_VARS.length}\n  `.trim();\n}\n",
            "properties": [
                {
                    "name": "chroma",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 138
                },
                {
                    "name": "hue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 137
                },
                {
                    "name": "tone",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 139
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "WordAnalysis",
            "id": "interface-WordAnalysis-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "properties": [
                {
                    "name": "phones",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15
                },
                {
                    "name": "pos",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "stresses",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "syllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 14
                },
                {
                    "name": "word",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 13
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "WordSuggestionData",
            "id": "interface-WordSuggestionData-cc01c88b56c2eb0b88baa736de26edf66653299b14fecfbb0dc7434c68b3977c7f382c4e601296066b01dfe98a03a03a66ecf008c0598e91718873cd4c5aefdb",
            "file": "src/app/services/poetry/poetry-analyzer.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject, signal } from '@angular/core';\nimport { PoetryAnalysisService } from './poetry-analysis.service';\nimport { PoetrySuggestionsService } from './poetry-suggestions.service';\nimport { PoetryPatternsService } from './poetry-patterns.service';\nimport { RhymeAnalysisService } from './rhyme-analysis.service';\nimport { PoemQualityService, type QualityMetrics } from './poem-quality.service';\nimport {\n  MeterAnalysisService,\n  type MeterAnalysis,\n  type RhythmSuggestion,\n} from './meter-analysis.service';\nimport {\n  RitaService,\n  type GrammaticalAnalysis,\n  type AlliterationMatch,\n  type AlternativeWord,\n} from './rita.service';\nimport { POETRY_FORMS, POETRY_EXAMPLES } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface EnhancedLineAnalysis extends LineAnalysis {\n  words: {\n    word: string;\n    syllables: number;\n    pos: string;\n    phones: string;\n    grammar?: GrammaticalAnalysis;\n  }[];\n  alliterations?: AlliterationMatch[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n}\n\nexport interface EnhancedPoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: EnhancedLineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n  overallAlliterations: AlliterationMatch[];\n  detectedPatterns: string[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n  meterAnalysis?: MeterAnalysis;\n}\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalyzerService {\n  private readonly analysis = inject(PoetryAnalysisService);\n  private readonly suggestions = inject(PoetrySuggestionsService);\n  private readonly patterns = inject(PoetryPatternsService);\n  private readonly rhymes = inject(RhymeAnalysisService);\n  private readonly quality = inject(PoemQualityService);\n  private readonly meterService = inject(MeterAnalysisService);\n  private readonly rita = inject(RitaService);\n\n  readonly isLoading = signal(false);\n  readonly result = signal<EnhancedPoetryResult | null>(null);\n  readonly selectedWord = signal<string | null>(null);\n  readonly wordAlternatives = signal<WordSuggestionData | null>(null);\n  readonly qualityMetrics = signal<QualityMetrics | null>(null);\n  readonly selectedForm = signal<string>('haiku');\n  readonly poemText = signal<string>('');\n  readonly rhythmSuggestions = signal<RhythmSuggestion[]>([]);\n\n  async analyze(formKey: string, rawLines: string[]): Promise<EnhancedPoetryResult> {\n    this.isLoading.set(true);\n\n    try {\n      const form = POETRY_FORMS[formKey];\n      if (!form) {\n        throw new Error(`Unknown form \"${formKey}\"`);\n      }\n\n      const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n      // Análisis dinámico basado en el poema actual\n      const typos = await this.rita.detectTypos(lines);\n      const meterAnalysis = this.meterService.detectMeter(lines);\n      const rhythmSuggestions = this.meterService.generateRhythmSuggestions(\n        lines,\n        meterAnalysis.type\n      );\n      this.rhythmSuggestions.set(rhythmSuggestions);\n\n      const lineAnalyses: EnhancedLineAnalysis[] = await Promise.all(\n        lines.map(async (line, index) => {\n          const analysis = this.rita.analyzeLine(line);\n          const words = this.rita.analyzeWords(line);\n          const alliterations = this.rita.detectAlliterations(line);\n          const expected = form.pattern[index] ?? 0;\n\n          const wordsWithGrammar = words.map((word) => ({\n            ...word,\n            grammar: this.rita.analyzeGrammar(word.word),\n          }));\n\n          return {\n            text: line,\n            count: analysis.syllables,\n            expected,\n            match: analysis.syllables === expected,\n            syllables: analysis.breakdown,\n            stresses: analysis.stresses,\n            words: wordsWithGrammar,\n            alliterations: alliterations.length > 0 ? alliterations : undefined,\n            typos: typos.filter((t) => t.line === index),\n          };\n        })\n      );\n\n      // Calcular calidad basada en el poema actual\n      const quality = this.quality.assessQuality(\n        lines,\n        form.pattern,\n        this.createResultForQualityAssessment(formKey, lineAnalyses)\n      );\n\n      const overallAlliterations = this.rhymes.detectCrossLineAlliterations(lines);\n      const detectedPatterns = [\n        ...this.detectPatterns(lineAnalyses),\n        ...this.generateMeterPatterns(meterAnalysis),\n      ];\n\n      const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n      const mismatches = lineAnalyses.filter((l) => !l.match).length;\n      const summary = ok\n        ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n            '-'\n          )} pattern`\n        : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n      const suggestions = this.generateEnhancedSuggestions(\n        lineAnalyses,\n        form.pattern,\n        meterAnalysis\n      );\n      const rhymeScheme = lines.length > 1 ? this.rita.analyzeRhymeScheme(lines) : undefined;\n\n      const result: EnhancedPoetryResult = {\n        ok,\n        form: formKey,\n        totalLines: {\n          expected: form.pattern.length,\n          actual: lineAnalyses.length,\n        },\n        lines: lineAnalyses,\n        summary,\n        rhymeScheme,\n        suggestions,\n        overallAlliterations,\n        detectedPatterns,\n        typos: typos.length > 0 ? typos : undefined,\n        meterAnalysis,\n      };\n\n      this.result.set(result);\n      this.qualityMetrics.set(quality);\n      return result;\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  async selectWordEnhanced(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) return;\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.suggestions.getWordAlternativesEnhanced(\n              word,\n              neededSyllables,\n              {\n                pos: wordAnalysis.pos,\n                lineIndex: result.lines.indexOf(line),\n                isLineEnd: line.words[line.words.length - 1]?.word === word,\n                previousWord: this.getPreviousWord(line.words, word),\n              }\n            );\n\n            this.wordAlternatives.set(alternatives);\n          } catch (error) {\n            console.warn('Error getting enhanced alternatives:', error);\n            await this.selectWord(word);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  async selectWord(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) {\n      return;\n    }\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.rita.suggestAlternatives(word, neededSyllables, 8);\n            this.wordAlternatives.set({\n              original: word,\n              currentSyllables: wordAnalysis.syllables,\n              targetSyllables: neededSyllables,\n              alternatives,\n            });\n          } catch (error) {\n            console.warn('Error getting word alternatives:', error);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  loadExample(): void {\n    const formId = this.selectedForm();\n    const example = POETRY_EXAMPLES[formId];\n    if (example) {\n      this.poemText.set(example.join('\\n'));\n      // Analizar automáticamente el ejemplo cargado\n      this.analyze(formId, example);\n    }\n  }\n\n  assessQuality(): void {\n    const result = this.result();\n    if (!result) return;\n\n    const lines = result.lines.map((l) => l.text);\n    const pattern = POETRY_FORMS[result.form].pattern;\n\n    const metrics = this.quality.assessQuality(lines, pattern, result);\n    this.qualityMetrics.set(metrics);\n  }\n\n  replaceWord(oldWord: string, newWord: string): void {\n    const result = this.result();\n    if (!result) return;\n\n    const updatedLines = result.lines.map((line) => {\n      const updatedText = line.text.replace(new RegExp(`\\\\b${oldWord}\\\\b`, 'gi'), newWord);\n      return updatedText;\n    });\n\n    this.poemText.set(updatedLines.join('\\n'));\n    this.analyze(result.form, updatedLines);\n    this.selectWordEnhanced(null);\n  }\n\n  clear(): void {\n    this.result.set(null);\n    this.selectedWord.set(null);\n    this.wordAlternatives.set(null);\n    this.qualityMetrics.set(null);\n    this.rhythmSuggestions.set([]);\n    this.poemText.set('');\n  }\n\n  private detectPatterns(lines: EnhancedLineAnalysis[]): string[] {\n    const patterns: string[] = [];\n\n    // Detectar patrones basados en el análisis real\n    const stressPatterns = lines.map((l) => l.stresses).filter((s) => s);\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent stress pattern: ${firstPattern}`);\n      }\n    }\n\n    // Detectar aliteraciones en el poema actual\n    const linesWithAlliteration = lines.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length > 0) {\n      patterns.push(\n        `${linesWithAlliteration.length} line${\n          linesWithAlliteration.length > 1 ? 's' : ''\n        } contain alliteration`\n      );\n    }\n\n    // Análisis de vocabulario del poema actual\n    const allWords = lines.flatMap((l) => l.words);\n    const nouns = allWords.filter((w) => w.pos.startsWith('nn')).length;\n    const verbs = allWords.filter((w) => w.pos.startsWith('vb')).length;\n    const adjectives = allWords.filter((w) => w.pos.startsWith('jj')).length;\n    const adverbs = allWords.filter((w) => w.pos.startsWith('rb')).length;\n\n    if (nouns > verbs * 2) {\n      patterns.push('Noun-heavy composition (descriptive style)');\n    } else if (verbs > nouns * 1.5) {\n      patterns.push('Verb-heavy composition (active style)');\n    }\n\n    if (adjectives > allWords.length * 0.2) {\n      patterns.push('High use of adjectives (vivid imagery)');\n    }\n\n    if (adverbs > allWords.length * 0.15) {\n      patterns.push('Adverb-rich language (detailed action)');\n    }\n\n    // Análisis de longitud de palabras\n    const avgWordLength =\n      allWords.reduce((sum, w) => sum + w.word.length, 0) / (allWords.length || 1);\n    if (avgWordLength > 6) {\n      patterns.push('Complex vocabulary (long words)');\n    } else if (avgWordLength < 4) {\n      patterns.push('Simple vocabulary (short words)');\n    }\n\n    return patterns;\n  }\n\n  private generateMeterPatterns(meter: MeterAnalysis): string[] {\n    const patterns: string[] = [];\n\n    if (meter.consistency > 70) {\n      patterns.push(`Strong ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    } else if (meter.consistency > 40) {\n      patterns.push(`Emerging ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    }\n\n    if (meter.type !== 'irregular') {\n      patterns.push(`Meter: ${meter.pattern}`);\n    }\n\n    return patterns;\n  }\n\n  private generateEnhancedSuggestions(\n    lineAnalyses: EnhancedLineAnalysis[],\n    pattern: number[],\n    meterAnalysis: MeterAnalysis\n  ): string[] {\n    const suggestions: string[] = [];\n\n    // Sugerencias basadas en la estructura del poema actual\n    if (lineAnalyses.length < pattern.length) {\n      const missing = pattern.length - lineAnalyses.length;\n      suggestions.push(`Add ${missing} more line${missing > 1 ? 's' : ''} to complete the pattern`);\n    } else if (lineAnalyses.length > pattern.length) {\n      const extra = lineAnalyses.length - pattern.length;\n      suggestions.push(`Remove ${extra} line${extra > 1 ? 's' : ''} to match the pattern`);\n    }\n\n    // Sugerencias rítmicas basadas en el análisis métrico\n    if (meterAnalysis.consistency < 60) {\n      suggestions.push(\n        `Improve rhythm consistency: ${meterAnalysis.type} meter detected but inconsistent`\n      );\n    }\n\n    if (meterAnalysis.type === 'irregular' && lineAnalyses.length > 2) {\n      suggestions.push('Consider using a regular meter pattern for better poetic flow');\n    }\n\n    // Sugerencias específicas por línea\n    lineAnalyses.forEach((line, index) => {\n      if (!line.match && index < pattern.length) {\n        const lineSuggestions = this.rita.generateSuggestions(line.text, pattern[index]);\n        suggestions.push(`Line ${index + 1}: ${lineSuggestions[0]}`);\n\n        const diff = pattern[index] - line.count;\n        if (diff > 0) {\n          const shortWords = line.words.filter((w) => w.syllables === 1);\n          if (shortWords.length > 0) {\n            suggestions.push(`  → Try replacing \"${shortWords[0].word}\" with a longer synonym`);\n          }\n        } else if (diff < 0) {\n          const longWords = line.words\n            .filter((w) => w.syllables > 2)\n            .sort((a, b) => b.syllables - a.syllables);\n          if (longWords.length > 0) {\n            suggestions.push(\n              `  → Try replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter word`\n            );\n          }\n        }\n      }\n    });\n\n    // Sugerencias de dispositivos literarios\n    const linesWithAlliteration = lineAnalyses.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length === 0 && lineAnalyses.length > 2) {\n      suggestions.push('Consider adding alliteration for poetic effect');\n    }\n\n    const hasRhyme = lineAnalyses.some((line) =>\n      line.words.some(\n        (word) => (word.pos && word.pos.startsWith('nn')) || word.pos.startsWith('vb')\n      )\n    );\n    if (!hasRhyme && lineAnalyses.length > 1) {\n      suggestions.push('Try incorporating rhyme for musical quality');\n    }\n\n    return suggestions.slice(0, 6);\n  }\n\n  private getPreviousWord(words: { word: string }[], currentWord: string): string | undefined {\n    const currentIndex = words.findIndex((w) => w.word.toLowerCase() === currentWord.toLowerCase());\n    return currentIndex > 0 ? words[currentIndex - 1].word : undefined;\n  }\n\n  private createResultForQualityAssessment(\n    formKey: string,\n    lineAnalyses: EnhancedLineAnalysis[]\n  ): EnhancedPoetryResult {\n    const form = POETRY_FORMS[formKey];\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n    return {\n      ok,\n      form: formKey,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      lines: lineAnalyses,\n      summary: '',\n      suggestions: [],\n      overallAlliterations: [],\n      detectedPatterns: [],\n    };\n  }\n\n  isCompletePoem(): boolean {\n    const result = this.result();\n    if (!result) return false;\n\n    return (\n      result.lines.length === result.totalLines.expected && result.lines.every((line) => line.match)\n    );\n  }\n\n  getQuickStats(): {\n    totalSyllables: number;\n    avgSyllablesPerLine: number;\n    vocabularyRichness: number;\n  } {\n    const result = this.result();\n    if (!result || result.lines.length === 0) {\n      return { totalSyllables: 0, avgSyllablesPerLine: 0, vocabularyRichness: 0 };\n    }\n\n    const totalSyllables = result.lines.reduce((sum, line) => sum + line.count, 0);\n    const avgSyllablesPerLine = totalSyllables / result.lines.length;\n\n    const allWords = result.lines.flatMap((line) => line.words.map((w) => w.word.toLowerCase()));\n    const uniqueWords = new Set(allWords);\n    const vocabularyRichness = (uniqueWords.size / allWords.length) * 100;\n\n    return {\n      totalSyllables,\n      avgSyllablesPerLine: Math.round(avgSyllablesPerLine * 10) / 10,\n      vocabularyRichness: Math.round(vocabularyRichness * 10) / 10,\n    };\n  }\n}\n",
            "properties": [
                {
                    "name": "alternatives",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "AlternativeWord[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 62
                },
                {
                    "name": "currentSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 60
                },
                {
                    "name": "original",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 59
                },
                {
                    "name": "targetSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 61
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": []
        },
        {
            "name": "WordSuggestionData",
            "id": "interface-WordSuggestionData-24eb12fada130bc88b863f4d93cc015155ad8963e6b439cd89626c34ffadb8c508817746d6d4f5f7e11b910ca3bb30339b231a1a9016833254b2677222c8462e-1",
            "file": "src/app/services/poetry/poetry-suggestions.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService, type AlternativeWord } from './rita.service';\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\nexport interface SuggestionContext {\n  pos?: string;\n  lineIndex?: number;\n  isLineEnd?: boolean;\n  previousWord?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetrySuggestionsService {\n  private readonly rita = inject(RitaService);\n\n  async getWordAlternativesEnhanced(\n    word: string,\n    targetSyllables: number,\n    context: SuggestionContext = {}\n  ): Promise<WordSuggestionData> {\n    const currentSyllables = this.rita.analyzeLine(word).syllables;\n\n    // Búsqueda simple y efectiva - CORREGIR parámetros\n    const [exactMatches, rhymes, phonetic] = await Promise.all([\n      this.searchBySyllables(targetSyllables), // ❌ Eliminar context.pos\n      context.isLineEnd\n        ? this.rita.findRhymes(word, targetSyllables).then((r) => r.perfectRhymes)\n        : Promise.resolve([]),\n      this.rita.suggestAlternatives(word, targetSyllables, 6),\n    ]);\n\n    const allAlternatives = [\n      ...exactMatches,\n      ...rhymes.map((w) => ({\n        word: w, // ✅ w es string, no AlternativeWord\n        syllables: targetSyllables,\n        reason: 'rhyme-match' as const,\n        pos: this.rita.analyzeGrammar(w).pos,\n      })),\n      ...phonetic,\n    ];\n\n    const unique = this.deduplicateAndRank(allAlternatives, word, context);\n\n    return {\n      original: word,\n      currentSyllables,\n      targetSyllables,\n      alternatives: unique.slice(0, 10),\n    };\n  }\n\n  private async searchBySyllables(syllables: number): Promise<AlternativeWord[]> {\n    // ❌ Eliminar pos parameter\n    try {\n      // Búsqueda simple por primera letra y sílabas\n      const results = await this.rita.suggestAlternatives('a', syllables, 8);\n\n      // CORREGIR: results ya son AlternativeWord[], no strings\n      return results.map((altWord) => ({\n        // ✅ altWord es AlternativeWord\n        ...altWord,\n        reason: 'exact-match' as const,\n      }));\n    } catch (error) {\n      console.warn('Search by syllables failed:', error);\n      return [];\n    }\n  }\n\n  private deduplicateAndRank(\n    alternatives: AlternativeWord[],\n    originalWord: string,\n    context: SuggestionContext\n  ): AlternativeWord[] {\n    const seen = new Set<string>();\n    const unique = alternatives.filter((alt) => {\n      const key = alt.word.toLowerCase();\n      if (seen.has(key) || key === originalWord.toLowerCase()) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n\n    return unique.sort((a, b) => {\n      if (a.reason === 'exact-match' && b.reason !== 'exact-match') return -1;\n      if (b.reason === 'exact-match' && a.reason !== 'exact-match') return 1;\n\n      if (context.isLineEnd) {\n        if (a.reason === 'rhyme-match' && b.reason !== 'rhyme-match') return -1;\n        if (b.reason === 'rhyme-match' && a.reason !== 'rhyme-match') return 1;\n      }\n\n      if (context.pos) {\n        const aMatchesPOS = a.pos === context.pos;\n        const bMatchesPOS = b.pos === context.pos;\n        if (aMatchesPOS && !bMatchesPOS) return -1;\n        if (bMatchesPOS && !aMatchesPOS) return 1;\n      }\n\n      return 0;\n    });\n  }\n\n  async getWordAlternatives(word: string, targetSyllables: number): Promise<WordSuggestionData> {\n    return this.getWordAlternativesEnhanced(word, targetSyllables);\n  }\n\n  generateLineSuggestions(line: string, targetSyllables: number): string[] {\n    return this.rita.generateSuggestions(line, targetSyllables);\n  }\n}\n",
            "properties": [
                {
                    "name": "alternatives",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "AlternativeWord[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "currentSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "original",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "targetSyllables",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                }
            ],
            "indexSignatures": [],
            "kind": 172,
            "methods": [],
            "extends": [],
            "isDuplicate": true,
            "duplicateId": 1,
            "duplicateName": "WordSuggestionData-1"
        }
    ],
    "injectables": [
        {
            "name": "MeterAnalysisService",
            "id": "injectable-MeterAnalysisService-c8ff5e422e8554e34650a202a0a41732300cf56a1ad0853b3fc676499f4c2ce0c687dd9ecb78f3df657e4274fec3fdc34b0adea4b92825d6d4813ddbc9d71d07",
            "file": "src/app/services/poetry/meter-analysis.service.ts",
            "properties": [
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 25,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "classifyStressPattern",
                    "args": [
                        {
                            "name": "stresses",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "MeterType | \"irregular\"",
                    "typeParameters": [],
                    "line": 74,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "stresses",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectMeter",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "MeterAnalysis",
                    "typeParameters": [],
                    "line": 27,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateRhythmSuggestions",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetMeter",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "RhythmSuggestion[]",
                    "typeParameters": [],
                    "line": 111,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetMeter",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getIrregularMeter",
                    "args": [],
                    "optional": false,
                    "returnType": "MeterAnalysis",
                    "typeParameters": [],
                    "line": 178,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "getMeterDescription",
                    "args": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 153,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getMeterExamples",
                    "args": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 164,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getMeterPattern",
                    "args": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 142,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "type",
                            "type": "MeterType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService } from './rita.service';\n\nexport type MeterType = 'iambic' | 'trochaic' | 'anapestic' | 'dactylic' | 'irregular';\n\nexport interface MeterAnalysis {\n  type: MeterType;\n  consistency: number;\n  pattern: string;\n  description: string;\n  examples: string[];\n}\n\nexport interface RhythmSuggestion {\n  line: number;\n  current: string;\n  issue: string;\n  suggestion: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class MeterAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  detectMeter(lines: string[]): MeterAnalysis {\n    const stressPatterns = lines\n      .map((line) => this.rita.analyzeLine(line).stresses)\n      .filter((s) => s && s.length > 0);\n\n    if (stressPatterns.length === 0) {\n      return this.getIrregularMeter();\n    }\n\n    const meterCounts = {\n      iambic: 0,\n      trochaic: 0,\n      anapestic: 0,\n      dactylic: 0,\n    };\n\n    stressPatterns.forEach((pattern) => {\n      const stresses = pattern.split('/').map((s) => parseInt(s));\n      const type = this.classifyStressPattern(stresses);\n      if (type !== 'irregular') {\n        meterCounts[type]++;\n      }\n    });\n\n    const total = stressPatterns.length;\n    const dominant = Object.entries(meterCounts).sort(([, a], [, b]) => b - a)[0];\n\n    if (!dominant) {\n      return this.getIrregularMeter();\n    }\n\n    const [type, count] = dominant as [MeterType, number];\n    const consistency = (count / total) * 100;\n\n    if (consistency < 40) {\n      return this.getIrregularMeter();\n    }\n\n    return {\n      type,\n      consistency,\n      pattern: this.getMeterPattern(type),\n      description: this.getMeterDescription(type),\n      examples: this.getMeterExamples(type),\n    };\n  }\n\n  private classifyStressPattern(stresses: number[]): MeterType | 'irregular' {\n    if (stresses.length < 2) return 'irregular';\n\n    const pairs: string[] = [];\n    for (let i = 0; i < stresses.length - 1; i++) {\n      pairs.push(`${stresses[i]}${stresses[i + 1]}`);\n    }\n\n    const pairCounts = {\n      '01': 0,\n      '10': 0,\n      '001': 0,\n      '100': 0,\n    };\n\n    pairs.forEach((pair) => {\n      if (pair === '01') pairCounts['01']++;\n      if (pair === '10') pairCounts['10']++;\n    });\n\n    for (let i = 0; i < stresses.length - 2; i++) {\n      const triplet = `${stresses[i]}${stresses[i + 1]}${stresses[i + 2]}`;\n      if (triplet === '001') pairCounts['001']++;\n      if (triplet === '100') pairCounts['100']++;\n    }\n\n    const max = Math.max(...Object.values(pairCounts));\n    if (max === 0) return 'irregular';\n\n    if (pairCounts['01'] === max) return 'iambic';\n    if (pairCounts['10'] === max) return 'trochaic';\n    if (pairCounts['001'] === max) return 'anapestic';\n    if (pairCounts['100'] === max) return 'dactylic';\n\n    return 'irregular';\n  }\n\n  generateRhythmSuggestions(lines: string[], targetMeter?: MeterType): RhythmSuggestion[] {\n    const suggestions: RhythmSuggestion[] = [];\n    const detectedMeter = this.detectMeter(lines);\n    const target = targetMeter || detectedMeter.type;\n\n    if (target === 'irregular') {\n      return suggestions;\n    }\n\n    lines.forEach((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      if (!analysis.stresses) return;\n\n      const stresses = analysis.stresses.split('/').map((s) => parseInt(s));\n      const lineType = this.classifyStressPattern(stresses);\n\n      if (lineType !== target) {\n        suggestions.push({\n          line: index + 1,\n          current: analysis.stresses,\n          issue: `This line follows a ${lineType} pattern instead of ${target}`,\n          suggestion: `Try restructuring to match the ${target} rhythm (${this.getMeterPattern(\n            target\n          )})`,\n        });\n      }\n    });\n\n    return suggestions;\n  }\n\n  private getMeterPattern(type: MeterType): string {\n    const patterns: Record<MeterType, string> = {\n      iambic: 'da-DUM (0/1)',\n      trochaic: 'DUM-da (1/0)',\n      anapestic: 'da-da-DUM (0/0/1)',\n      dactylic: 'DUM-da-da (1/0/0)',\n      irregular: 'mixed or free verse',\n    };\n    return patterns[type];\n  }\n\n  private getMeterDescription(type: MeterType): string {\n    const descriptions: Record<MeterType, string> = {\n      iambic: 'Most common in English poetry. Sounds natural and flowing.',\n      trochaic: \"Strong, emphatic rhythm. Common in children's verse.\",\n      anapestic: 'Galloping, energetic rhythm. Creates sense of movement.',\n      dactylic: 'Falling rhythm. Rare in English, common in ancient Greek.',\n      irregular: 'No consistent metrical pattern. Free verse or mixed meters.',\n    };\n    return descriptions[type];\n  }\n\n  private getMeterExamples(type: MeterType): string[] {\n    const examples: Record<MeterType, string[]> = {\n      iambic: [\n        \"Shall I compare thee to a summer's day?\",\n        'The curfew tolls the knell of parting day',\n      ],\n      trochaic: ['Tell me not in mournful numbers', 'Tiger, tiger, burning bright'],\n      anapestic: ['Twas the night before Christmas', 'And the sound of a voice that is still'],\n      dactylic: ['This is the forest primeval', 'Cannon to right of them'],\n      irregular: ['Free verse has no set pattern', 'Modern poetry often breaks rules'],\n    };\n    return examples[type];\n  }\n\n  private getIrregularMeter(): MeterAnalysis {\n    return {\n      type: 'irregular',\n      consistency: 0,\n      pattern: 'mixed or free verse',\n      description:\n        'No consistent metrical pattern detected. This could be free verse or mixed meters.',\n      examples: [],\n    };\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "PoemQualityService",
            "id": "injectable-PoemQualityService-7ce486a65750df1898e54ad355d397e9260f98fe45ae68caa60242e267f5634701e7c08a6a7f0953319376c9e4cf54f03e3ba75dc7c2cb9a7365b440b75ed93d",
            "file": "src/app/services/poetry/poem-quality.service.ts",
            "properties": [
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 24,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "assessQuality",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "QualityMetrics",
                    "typeParameters": [],
                    "line": 26,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "assignGrade",
                    "args": [
                        {
                            "name": "score",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "",
                    "typeParameters": [],
                    "line": 146,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "score",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculatePhoneticRichness",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 56,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculateRhetoricalDevices",
                    "args": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 101,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculateRhythmConsistency",
                    "args": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 86,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculateSyllableAccuracy",
                    "args": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 49,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "result",
                            "type": "EnhancedPoetryResult",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculateVocabularyDiversity",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 73,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "computeOverallScore",
                    "args": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 132,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "countSensoryWords",
                    "args": [
                        {
                            "name": "words",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 226,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "words",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "identifyStrengths",
                    "args": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 157,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "stressSimilarity",
                    "args": [
                        {
                            "name": "pattern1",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "pattern2",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 213,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "pattern1",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "pattern2",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "suggestImprovements",
                    "args": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 185,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "metrics",
                            "type": "QualityMetrics",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { RitaService } from './rita.service';\nimport type { EnhancedPoetryResult } from './poetry-analyzer.service';\n\nexport interface QualityMetrics {\n  score: number;\n  breakdown: {\n    syllableAccuracy: number;\n    phoneticsRichness: number;\n    vocabularyDiversity: number;\n    rhythmConsistency: number;\n    rhetoricalDevices: number;\n  };\n  strengths: string[];\n  improvements: string[];\n  grade: 'A+' | 'A' | 'B+' | 'B' | 'C+' | 'C' | 'D' | 'F';\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoemQualityService {\n  private readonly rita = inject(RitaService);\n\n  assessQuality(lines: string[], pattern: number[], result: EnhancedPoetryResult): QualityMetrics {\n    const metrics = {\n      syllableAccuracy: this.calculateSyllableAccuracy(result, pattern),\n      phoneticsRichness: this.calculatePhoneticRichness(lines),\n      vocabularyDiversity: this.calculateVocabularyDiversity(lines),\n      rhythmConsistency: this.calculateRhythmConsistency(result),\n      rhetoricalDevices: this.calculateRhetoricalDevices(result),\n    };\n\n    const score = this.computeOverallScore(metrics);\n    const grade = this.assignGrade(score);\n    const strengths = this.identifyStrengths(metrics);\n    const improvements = this.suggestImprovements(metrics);\n\n    return {\n      score,\n      breakdown: metrics,\n      strengths,\n      improvements,\n      grade,\n    };\n  }\n\n  private calculateSyllableAccuracy(result: EnhancedPoetryResult, pattern: number[]): number {\n    if (result.lines.length !== pattern.length) return 0;\n\n    const matches = result.lines.filter((line) => line.match).length;\n    return (matches / pattern.length) * 100;\n  }\n\n  private calculatePhoneticRichness(lines: string[]): number {\n    const text = lines.join(' ');\n    const words = RiTa.tokens(text);\n\n    if (words.length === 0) return 0;\n\n    const uniquePhonemes = new Set<string>();\n    words.forEach((word) => {\n      const phones = RiTa.phones(word);\n      if (phones) {\n        phones.split('-').forEach((p) => uniquePhonemes.add(p));\n      }\n    });\n\n    return Math.min(100, (uniquePhonemes.size / 15) * 100);\n  }\n\n  private calculateVocabularyDiversity(lines: string[]): number {\n    const text = lines.join(' ');\n    const tokens = RiTa.tokenize(text);\n    const words = tokens.filter((t) => !RiTa.isPunct(t));\n\n    if (words.length === 0) return 0;\n\n    const unique = new Set(words.map((w) => w.toLowerCase()));\n    const ttr = unique.size / words.length;\n\n    return Math.min(100, (ttr / 0.6) * 100);\n  }\n\n  private calculateRhythmConsistency(result: EnhancedPoetryResult): number {\n    const stressPatterns = result.lines\n      .map((l) => l.stresses)\n      .filter((s): s is string => s !== undefined && s.length > 0);\n\n    if (stressPatterns.length < 2) return 50;\n\n    const firstPattern = stressPatterns[0];\n    const similarCount = stressPatterns.filter(\n      (p) => this.stressSimilarity(firstPattern, p) > 0.6\n    ).length;\n\n    return (similarCount / stressPatterns.length) * 100;\n  }\n\n  private calculateRhetoricalDevices(result: EnhancedPoetryResult): number {\n    let score = 0;\n\n    if (result.overallAlliterations.length > 0) {\n      score += Math.min(20, result.overallAlliterations.length * 5);\n    }\n\n    if (result.rhymeScheme && result.rhymeScheme !== 'A'.repeat(result.lines.length)) {\n      score += 30;\n    }\n\n    const concordance = RiTa.concordance(result.lines.map((l) => l.text).join(' '));\n    const repeatedWords = Object.values(concordance).filter((count) => count > 1).length;\n    if (repeatedWords > 0) {\n      score += Math.min(20, repeatedWords * 4);\n    }\n\n    const allWords = result.lines.flatMap((l) => l.words);\n    const uniquePOS = new Set(allWords.map((w) => w.pos));\n    if (uniquePOS.size >= 4) {\n      score += 15;\n    }\n\n    const sensoryWords = this.countSensoryWords(allWords.map((w) => w.word));\n    if (sensoryWords >= 3) {\n      score += 15;\n    }\n\n    return Math.min(100, score);\n  }\n\n  private computeOverallScore(metrics: QualityMetrics['breakdown']): number {\n    const weights = {\n      syllableAccuracy: 0.35,\n      phoneticsRichness: 0.15,\n      vocabularyDiversity: 0.2,\n      rhythmConsistency: 0.15,\n      rhetoricalDevices: 0.15,\n    };\n\n    return Object.entries(weights).reduce((total, [key, weight]) => {\n      return total + metrics[key as keyof typeof metrics] * weight;\n    }, 0);\n  }\n\n  private assignGrade(score: number): QualityMetrics['grade'] {\n    if (score >= 95) return 'A+';\n    if (score >= 90) return 'A';\n    if (score >= 85) return 'B+';\n    if (score >= 80) return 'B';\n    if (score >= 75) return 'C+';\n    if (score >= 70) return 'C';\n    if (score >= 60) return 'D';\n    return 'F';\n  }\n\n  private identifyStrengths(metrics: QualityMetrics['breakdown']): string[] {\n    const strengths: string[] = [];\n\n    if (metrics.syllableAccuracy === 100) {\n      strengths.push('Perfect syllable matching');\n    } else if (metrics.syllableAccuracy >= 80) {\n      strengths.push('Good syllable accuracy');\n    }\n\n    if (metrics.phoneticsRichness > 80) {\n      strengths.push('Rich phonetic variety');\n    }\n\n    if (metrics.vocabularyDiversity > 75) {\n      strengths.push('Diverse vocabulary');\n    }\n\n    if (metrics.rhythmConsistency > 80) {\n      strengths.push('Consistent rhythm');\n    }\n\n    if (metrics.rhetoricalDevices > 70) {\n      strengths.push('Strong use of literary devices');\n    }\n\n    return strengths.length > 0 ? strengths : ['Good foundation - keep practicing!'];\n  }\n\n  private suggestImprovements(metrics: QualityMetrics['breakdown']): string[] {\n    const improvements: string[] = [];\n\n    if (metrics.syllableAccuracy < 100) {\n      improvements.push('Adjust syllable counts to match the pattern');\n    }\n\n    if (metrics.phoneticsRichness < 60) {\n      improvements.push('Use more varied sounds and phonemes');\n    }\n\n    if (metrics.vocabularyDiversity < 50) {\n      improvements.push('Avoid repeating the same words');\n    }\n\n    if (metrics.rhythmConsistency < 60) {\n      improvements.push('Create more consistent stress patterns');\n    }\n\n    if (metrics.rhetoricalDevices < 50) {\n      improvements.push('Add alliteration, rhyme, or other literary devices');\n    }\n\n    return improvements.length > 0\n      ? improvements\n      : ['Excellent work! Consider experimenting with more complex forms.'];\n  }\n\n  private stressSimilarity(pattern1: string, pattern2: string): number {\n    const arr1 = pattern1.split('/');\n    const arr2 = pattern2.split('/');\n    const maxLen = Math.max(arr1.length, arr2.length);\n\n    let matches = 0;\n    for (let i = 0; i < maxLen; i++) {\n      if (arr1[i] === arr2[i]) matches++;\n    }\n\n    return matches / maxLen;\n  }\n\n  private countSensoryWords(words: string[]): number {\n    const sensoryPatterns = [\n      /bright|dark|color|hue|shade/i,\n      /loud|quiet|sound|music|voice|echo/i,\n      /soft|hard|smooth|rough|warm|cold/i,\n      /sweet|bitter|fragrant|scent|smell/i,\n      /taste|flavor|savory|delicious/i,\n    ];\n\n    return words.filter((word) => sensoryPatterns.some((pattern) => pattern.test(word))).length;\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "PoetryAnalysisService",
            "id": "injectable-PoetryAnalysisService-87839deece079bc7847173139a67015b54b1d00fdeef757ab3e95c0a0bdf68b78cba002925ff807dfb5be309a363c259bd762ca785914d525a6a44d20747e0bd",
            "file": "src/app/services/poetry/poetry-analysis.service.ts",
            "properties": [
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "analyzePoemStructure",
                    "args": [
                        {
                            "name": "rawLines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "PoetryStructure",
                    "typeParameters": [],
                    "line": 19,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "rawLines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "calculateSyllableAccuracy",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 71,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectMeterPattern",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 85,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "validateLineSyllables",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "expectedSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "literal type",
                    "typeParameters": [],
                    "line": 60,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "expectedSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService } from './rita.service';\nimport { POETRY_FORMS } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface PoetryStructure {\n  lines: LineAnalysis[];\n  totalLines: { expected: number; actual: number };\n  ok: boolean;\n  summary: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  analyzePoemStructure(rawLines: string[], formKey: string): PoetryStructure {\n    const form = POETRY_FORMS[formKey];\n    if (!form) {\n      throw new Error(`Unknown form \"${formKey}\"`);\n    }\n\n    const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n    const lineAnalyses: LineAnalysis[] = lines.map((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      const expected = form.pattern[index] ?? 0;\n\n      return {\n        text: line,\n        count: analysis.syllables,\n        expected,\n        match: analysis.syllables === expected,\n        syllables: analysis.breakdown,\n        stresses: analysis.stresses,\n      };\n    });\n\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n    const mismatches = lineAnalyses.filter((l) => !l.match).length;\n    const summary = ok\n      ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n          '-'\n        )} pattern`\n      : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n    return {\n      lines: lineAnalyses,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      ok,\n      summary,\n    };\n  }\n\n  validateLineSyllables(\n    line: string,\n    expectedSyllables: number\n  ): { valid: boolean; actual: number } {\n    const analysis = this.rita.analyzeLine(line);\n    return {\n      valid: analysis.syllables === expectedSyllables,\n      actual: analysis.syllables,\n    };\n  }\n\n  calculateSyllableAccuracy(lines: string[], pattern: number[]): number {\n    if (lines.length !== pattern.length) return 0;\n\n    let matches = 0;\n    lines.forEach((line, index) => {\n      const analysis = this.rita.analyzeLine(line);\n      if (analysis.syllables === pattern[index]) {\n        matches++;\n      }\n    });\n\n    return (matches / pattern.length) * 100;\n  }\n\n  detectMeterPattern(lines: string[]): string[] {\n    const patterns: string[] = [];\n    const stressPatterns = lines\n      .map((line) => {\n        const analysis = this.rita.analyzeLine(line);\n        return analysis.stresses;\n      })\n      .filter((s) => s && s.length > 0);\n\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent meter: ${firstPattern}`);\n      }\n    }\n\n    return patterns;\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "PoetryAnalyzerService",
            "id": "injectable-PoetryAnalyzerService-cc01c88b56c2eb0b88baa736de26edf66653299b14fecfbb0dc7434c68b3977c7f382c4e601296066b01dfe98a03a03a66ecf008c0598e91718873cd4c5aefdb",
            "file": "src/app/services/poetry/poetry-analyzer.service.ts",
            "properties": [
                {
                    "name": "analysis",
                    "defaultValue": "inject(PoetryAnalysisService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 69,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "isLoading",
                    "defaultValue": "signal(false)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 77,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "meterService",
                    "defaultValue": "inject(MeterAnalysisService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 74,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "patterns",
                    "defaultValue": "inject(PoetryPatternsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 71,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "poemText",
                    "defaultValue": "signal<string>('')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 83,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "quality",
                    "defaultValue": "inject(PoemQualityService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 73,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "qualityMetrics",
                    "defaultValue": "signal<QualityMetrics | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 81,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "result",
                    "defaultValue": "signal<EnhancedPoetryResult | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 78,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "rhymes",
                    "defaultValue": "inject(RhymeAnalysisService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 72,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "rhythmSuggestions",
                    "defaultValue": "signal<RhythmSuggestion[]>([])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 84,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 75,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "selectedForm",
                    "defaultValue": "signal<string>('haiku')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 82,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "selectedWord",
                    "defaultValue": "signal<string | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 79,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "suggestions",
                    "defaultValue": "inject(PoetrySuggestionsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 70,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "wordAlternatives",
                    "defaultValue": "signal<WordSuggestionData | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 80,
                    "modifierKind": [
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "analyze",
                    "args": [
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "rawLines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<EnhancedPoetryResult>",
                    "typeParameters": [],
                    "line": 86,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "rawLines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "assessQuality",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 275,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "clear",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 300,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "createResultForQualityAssessment",
                    "args": [
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "lineAnalyses",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "EnhancedPoetryResult",
                    "typeParameters": [],
                    "line": 460,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "formKey",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "lineAnalyses",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectPatterns",
                    "args": [
                        {
                            "name": "lines",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 309,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateEnhancedSuggestions",
                    "args": [
                        {
                            "name": "lineAnalyses",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "meterAnalysis",
                            "type": "MeterAnalysis",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 383,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "lineAnalyses",
                            "type": "EnhancedLineAnalysis[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "pattern",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "meterAnalysis",
                            "type": "MeterAnalysis",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateMeterPatterns",
                    "args": [
                        {
                            "name": "meter",
                            "type": "MeterAnalysis",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 367,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "meter",
                            "type": "MeterAnalysis",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getPreviousWord",
                    "args": [
                        {
                            "name": "words",
                            "type": "literal type[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "currentWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string | undefined",
                    "typeParameters": [],
                    "line": 455,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "words",
                            "type": "literal type[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "currentWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getQuickStats",
                    "args": [],
                    "optional": false,
                    "returnType": "literal type",
                    "typeParameters": [],
                    "line": 491,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "isCompletePoem",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 482,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "loadExample",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 265,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "replaceWord",
                    "args": [
                        {
                            "name": "oldWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "newWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 286,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "oldWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "newWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "selectWord",
                    "args": [
                        {
                            "name": "word",
                            "type": "string | null",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 228,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string | null",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "selectWordEnhanced",
                    "args": [
                        {
                            "name": "word",
                            "type": "string | null",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 186,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string | null",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject, signal } from '@angular/core';\nimport { PoetryAnalysisService } from './poetry-analysis.service';\nimport { PoetrySuggestionsService } from './poetry-suggestions.service';\nimport { PoetryPatternsService } from './poetry-patterns.service';\nimport { RhymeAnalysisService } from './rhyme-analysis.service';\nimport { PoemQualityService, type QualityMetrics } from './poem-quality.service';\nimport {\n  MeterAnalysisService,\n  type MeterAnalysis,\n  type RhythmSuggestion,\n} from './meter-analysis.service';\nimport {\n  RitaService,\n  type GrammaticalAnalysis,\n  type AlliterationMatch,\n  type AlternativeWord,\n} from './rita.service';\nimport { POETRY_FORMS, POETRY_EXAMPLES } from '../../data/poetry-forms.data';\nimport type { LineAnalysis } from '../../models/poetry.model';\n\nexport interface EnhancedLineAnalysis extends LineAnalysis {\n  words: {\n    word: string;\n    syllables: number;\n    pos: string;\n    phones: string;\n    grammar?: GrammaticalAnalysis;\n  }[];\n  alliterations?: AlliterationMatch[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n}\n\nexport interface EnhancedPoetryResult {\n  ok: boolean;\n  form: string;\n  totalLines: {\n    expected: number;\n    actual: number;\n  };\n  lines: EnhancedLineAnalysis[];\n  summary: string;\n  rhymeScheme?: string;\n  suggestions: string[];\n  overallAlliterations: AlliterationMatch[];\n  detectedPatterns: string[];\n  typos?: {\n    line: number;\n    word: string;\n    suggestions: string[];\n  }[];\n  meterAnalysis?: MeterAnalysis;\n}\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryAnalyzerService {\n  private readonly analysis = inject(PoetryAnalysisService);\n  private readonly suggestions = inject(PoetrySuggestionsService);\n  private readonly patterns = inject(PoetryPatternsService);\n  private readonly rhymes = inject(RhymeAnalysisService);\n  private readonly quality = inject(PoemQualityService);\n  private readonly meterService = inject(MeterAnalysisService);\n  private readonly rita = inject(RitaService);\n\n  readonly isLoading = signal(false);\n  readonly result = signal<EnhancedPoetryResult | null>(null);\n  readonly selectedWord = signal<string | null>(null);\n  readonly wordAlternatives = signal<WordSuggestionData | null>(null);\n  readonly qualityMetrics = signal<QualityMetrics | null>(null);\n  readonly selectedForm = signal<string>('haiku');\n  readonly poemText = signal<string>('');\n  readonly rhythmSuggestions = signal<RhythmSuggestion[]>([]);\n\n  async analyze(formKey: string, rawLines: string[]): Promise<EnhancedPoetryResult> {\n    this.isLoading.set(true);\n\n    try {\n      const form = POETRY_FORMS[formKey];\n      if (!form) {\n        throw new Error(`Unknown form \"${formKey}\"`);\n      }\n\n      const lines = rawLines.map((line) => line.trim()).filter((line) => line.length > 0);\n\n      // Análisis dinámico basado en el poema actual\n      const typos = await this.rita.detectTypos(lines);\n      const meterAnalysis = this.meterService.detectMeter(lines);\n      const rhythmSuggestions = this.meterService.generateRhythmSuggestions(\n        lines,\n        meterAnalysis.type\n      );\n      this.rhythmSuggestions.set(rhythmSuggestions);\n\n      const lineAnalyses: EnhancedLineAnalysis[] = await Promise.all(\n        lines.map(async (line, index) => {\n          const analysis = this.rita.analyzeLine(line);\n          const words = this.rita.analyzeWords(line);\n          const alliterations = this.rita.detectAlliterations(line);\n          const expected = form.pattern[index] ?? 0;\n\n          const wordsWithGrammar = words.map((word) => ({\n            ...word,\n            grammar: this.rita.analyzeGrammar(word.word),\n          }));\n\n          return {\n            text: line,\n            count: analysis.syllables,\n            expected,\n            match: analysis.syllables === expected,\n            syllables: analysis.breakdown,\n            stresses: analysis.stresses,\n            words: wordsWithGrammar,\n            alliterations: alliterations.length > 0 ? alliterations : undefined,\n            typos: typos.filter((t) => t.line === index),\n          };\n        })\n      );\n\n      // Calcular calidad basada en el poema actual\n      const quality = this.quality.assessQuality(\n        lines,\n        form.pattern,\n        this.createResultForQualityAssessment(formKey, lineAnalyses)\n      );\n\n      const overallAlliterations = this.rhymes.detectCrossLineAlliterations(lines);\n      const detectedPatterns = [\n        ...this.detectPatterns(lineAnalyses),\n        ...this.generateMeterPatterns(meterAnalysis),\n      ];\n\n      const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n      const mismatches = lineAnalyses.filter((l) => !l.match).length;\n      const summary = ok\n        ? `Perfect match: all ${lineAnalyses.length} lines follow the ${form.pattern.join(\n            '-'\n          )} pattern`\n        : `${mismatches} of ${lineAnalyses.length} lines don't match the expected pattern`;\n\n      const suggestions = this.generateEnhancedSuggestions(\n        lineAnalyses,\n        form.pattern,\n        meterAnalysis\n      );\n      const rhymeScheme = lines.length > 1 ? this.rita.analyzeRhymeScheme(lines) : undefined;\n\n      const result: EnhancedPoetryResult = {\n        ok,\n        form: formKey,\n        totalLines: {\n          expected: form.pattern.length,\n          actual: lineAnalyses.length,\n        },\n        lines: lineAnalyses,\n        summary,\n        rhymeScheme,\n        suggestions,\n        overallAlliterations,\n        detectedPatterns,\n        typos: typos.length > 0 ? typos : undefined,\n        meterAnalysis,\n      };\n\n      this.result.set(result);\n      this.qualityMetrics.set(quality);\n      return result;\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  async selectWordEnhanced(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) return;\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.suggestions.getWordAlternativesEnhanced(\n              word,\n              neededSyllables,\n              {\n                pos: wordAnalysis.pos,\n                lineIndex: result.lines.indexOf(line),\n                isLineEnd: line.words[line.words.length - 1]?.word === word,\n                previousWord: this.getPreviousWord(line.words, word),\n              }\n            );\n\n            this.wordAlternatives.set(alternatives);\n          } catch (error) {\n            console.warn('Error getting enhanced alternatives:', error);\n            await this.selectWord(word);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  async selectWord(word: string | null): Promise<void> {\n    this.selectedWord.set(word);\n    this.wordAlternatives.set(null);\n\n    if (!word) {\n      return;\n    }\n\n    const result = this.result();\n    if (!result) return;\n\n    for (const line of result.lines) {\n      const wordAnalysis = line.words.find((w) => w.word.toLowerCase() === word.toLowerCase());\n      if (wordAnalysis) {\n        const targetSyllables = line.expected;\n        const currentLineSyllables = line.count;\n        const diff = targetSyllables - currentLineSyllables;\n        const neededSyllables = wordAnalysis.syllables + diff;\n\n        if (neededSyllables > 0) {\n          try {\n            const alternatives = await this.rita.suggestAlternatives(word, neededSyllables, 8);\n            this.wordAlternatives.set({\n              original: word,\n              currentSyllables: wordAnalysis.syllables,\n              targetSyllables: neededSyllables,\n              alternatives,\n            });\n          } catch (error) {\n            console.warn('Error getting word alternatives:', error);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  loadExample(): void {\n    const formId = this.selectedForm();\n    const example = POETRY_EXAMPLES[formId];\n    if (example) {\n      this.poemText.set(example.join('\\n'));\n      // Analizar automáticamente el ejemplo cargado\n      this.analyze(formId, example);\n    }\n  }\n\n  assessQuality(): void {\n    const result = this.result();\n    if (!result) return;\n\n    const lines = result.lines.map((l) => l.text);\n    const pattern = POETRY_FORMS[result.form].pattern;\n\n    const metrics = this.quality.assessQuality(lines, pattern, result);\n    this.qualityMetrics.set(metrics);\n  }\n\n  replaceWord(oldWord: string, newWord: string): void {\n    const result = this.result();\n    if (!result) return;\n\n    const updatedLines = result.lines.map((line) => {\n      const updatedText = line.text.replace(new RegExp(`\\\\b${oldWord}\\\\b`, 'gi'), newWord);\n      return updatedText;\n    });\n\n    this.poemText.set(updatedLines.join('\\n'));\n    this.analyze(result.form, updatedLines);\n    this.selectWordEnhanced(null);\n  }\n\n  clear(): void {\n    this.result.set(null);\n    this.selectedWord.set(null);\n    this.wordAlternatives.set(null);\n    this.qualityMetrics.set(null);\n    this.rhythmSuggestions.set([]);\n    this.poemText.set('');\n  }\n\n  private detectPatterns(lines: EnhancedLineAnalysis[]): string[] {\n    const patterns: string[] = [];\n\n    // Detectar patrones basados en el análisis real\n    const stressPatterns = lines.map((l) => l.stresses).filter((s) => s);\n    if (stressPatterns.length > 2) {\n      const firstPattern = stressPatterns[0];\n      const allSame = stressPatterns.every((p) => p === firstPattern);\n      if (allSame) {\n        patterns.push(`Consistent stress pattern: ${firstPattern}`);\n      }\n    }\n\n    // Detectar aliteraciones en el poema actual\n    const linesWithAlliteration = lines.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length > 0) {\n      patterns.push(\n        `${linesWithAlliteration.length} line${\n          linesWithAlliteration.length > 1 ? 's' : ''\n        } contain alliteration`\n      );\n    }\n\n    // Análisis de vocabulario del poema actual\n    const allWords = lines.flatMap((l) => l.words);\n    const nouns = allWords.filter((w) => w.pos.startsWith('nn')).length;\n    const verbs = allWords.filter((w) => w.pos.startsWith('vb')).length;\n    const adjectives = allWords.filter((w) => w.pos.startsWith('jj')).length;\n    const adverbs = allWords.filter((w) => w.pos.startsWith('rb')).length;\n\n    if (nouns > verbs * 2) {\n      patterns.push('Noun-heavy composition (descriptive style)');\n    } else if (verbs > nouns * 1.5) {\n      patterns.push('Verb-heavy composition (active style)');\n    }\n\n    if (adjectives > allWords.length * 0.2) {\n      patterns.push('High use of adjectives (vivid imagery)');\n    }\n\n    if (adverbs > allWords.length * 0.15) {\n      patterns.push('Adverb-rich language (detailed action)');\n    }\n\n    // Análisis de longitud de palabras\n    const avgWordLength =\n      allWords.reduce((sum, w) => sum + w.word.length, 0) / (allWords.length || 1);\n    if (avgWordLength > 6) {\n      patterns.push('Complex vocabulary (long words)');\n    } else if (avgWordLength < 4) {\n      patterns.push('Simple vocabulary (short words)');\n    }\n\n    return patterns;\n  }\n\n  private generateMeterPatterns(meter: MeterAnalysis): string[] {\n    const patterns: string[] = [];\n\n    if (meter.consistency > 70) {\n      patterns.push(`Strong ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    } else if (meter.consistency > 40) {\n      patterns.push(`Emerging ${meter.type} meter (${meter.consistency.toFixed(0)}% consistent)`);\n    }\n\n    if (meter.type !== 'irregular') {\n      patterns.push(`Meter: ${meter.pattern}`);\n    }\n\n    return patterns;\n  }\n\n  private generateEnhancedSuggestions(\n    lineAnalyses: EnhancedLineAnalysis[],\n    pattern: number[],\n    meterAnalysis: MeterAnalysis\n  ): string[] {\n    const suggestions: string[] = [];\n\n    // Sugerencias basadas en la estructura del poema actual\n    if (lineAnalyses.length < pattern.length) {\n      const missing = pattern.length - lineAnalyses.length;\n      suggestions.push(`Add ${missing} more line${missing > 1 ? 's' : ''} to complete the pattern`);\n    } else if (lineAnalyses.length > pattern.length) {\n      const extra = lineAnalyses.length - pattern.length;\n      suggestions.push(`Remove ${extra} line${extra > 1 ? 's' : ''} to match the pattern`);\n    }\n\n    // Sugerencias rítmicas basadas en el análisis métrico\n    if (meterAnalysis.consistency < 60) {\n      suggestions.push(\n        `Improve rhythm consistency: ${meterAnalysis.type} meter detected but inconsistent`\n      );\n    }\n\n    if (meterAnalysis.type === 'irregular' && lineAnalyses.length > 2) {\n      suggestions.push('Consider using a regular meter pattern for better poetic flow');\n    }\n\n    // Sugerencias específicas por línea\n    lineAnalyses.forEach((line, index) => {\n      if (!line.match && index < pattern.length) {\n        const lineSuggestions = this.rita.generateSuggestions(line.text, pattern[index]);\n        suggestions.push(`Line ${index + 1}: ${lineSuggestions[0]}`);\n\n        const diff = pattern[index] - line.count;\n        if (diff > 0) {\n          const shortWords = line.words.filter((w) => w.syllables === 1);\n          if (shortWords.length > 0) {\n            suggestions.push(`  → Try replacing \"${shortWords[0].word}\" with a longer synonym`);\n          }\n        } else if (diff < 0) {\n          const longWords = line.words\n            .filter((w) => w.syllables > 2)\n            .sort((a, b) => b.syllables - a.syllables);\n          if (longWords.length > 0) {\n            suggestions.push(\n              `  → Try replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter word`\n            );\n          }\n        }\n      }\n    });\n\n    // Sugerencias de dispositivos literarios\n    const linesWithAlliteration = lineAnalyses.filter(\n      (l) => l.alliterations && l.alliterations.length > 0\n    );\n    if (linesWithAlliteration.length === 0 && lineAnalyses.length > 2) {\n      suggestions.push('Consider adding alliteration for poetic effect');\n    }\n\n    const hasRhyme = lineAnalyses.some((line) =>\n      line.words.some(\n        (word) => (word.pos && word.pos.startsWith('nn')) || word.pos.startsWith('vb')\n      )\n    );\n    if (!hasRhyme && lineAnalyses.length > 1) {\n      suggestions.push('Try incorporating rhyme for musical quality');\n    }\n\n    return suggestions.slice(0, 6);\n  }\n\n  private getPreviousWord(words: { word: string }[], currentWord: string): string | undefined {\n    const currentIndex = words.findIndex((w) => w.word.toLowerCase() === currentWord.toLowerCase());\n    return currentIndex > 0 ? words[currentIndex - 1].word : undefined;\n  }\n\n  private createResultForQualityAssessment(\n    formKey: string,\n    lineAnalyses: EnhancedLineAnalysis[]\n  ): EnhancedPoetryResult {\n    const form = POETRY_FORMS[formKey];\n    const ok = lineAnalyses.length === form.pattern.length && lineAnalyses.every((l) => l.match);\n\n    return {\n      ok,\n      form: formKey,\n      totalLines: {\n        expected: form.pattern.length,\n        actual: lineAnalyses.length,\n      },\n      lines: lineAnalyses,\n      summary: '',\n      suggestions: [],\n      overallAlliterations: [],\n      detectedPatterns: [],\n    };\n  }\n\n  isCompletePoem(): boolean {\n    const result = this.result();\n    if (!result) return false;\n\n    return (\n      result.lines.length === result.totalLines.expected && result.lines.every((line) => line.match)\n    );\n  }\n\n  getQuickStats(): {\n    totalSyllables: number;\n    avgSyllablesPerLine: number;\n    vocabularyRichness: number;\n  } {\n    const result = this.result();\n    if (!result || result.lines.length === 0) {\n      return { totalSyllables: 0, avgSyllablesPerLine: 0, vocabularyRichness: 0 };\n    }\n\n    const totalSyllables = result.lines.reduce((sum, line) => sum + line.count, 0);\n    const avgSyllablesPerLine = totalSyllables / result.lines.length;\n\n    const allWords = result.lines.flatMap((line) => line.words.map((w) => w.word.toLowerCase()));\n    const uniqueWords = new Set(allWords);\n    const vocabularyRichness = (uniqueWords.size / allWords.length) * 100;\n\n    return {\n      totalSyllables,\n      avgSyllablesPerLine: Math.round(avgSyllablesPerLine * 10) / 10,\n      vocabularyRichness: Math.round(vocabularyRichness * 10) / 10,\n    };\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "PoetryPatternsService",
            "id": "injectable-PoetryPatternsService-80b0cf2d8c512fa3d287dcf6c2c96e860136e9c66d1f6e82cb0d45daeff632996b97a6abb3d5c058c7715e20051557c5974bec052e4c26a8d90bee1cedbfa98b",
            "file": "src/app/services/poetry/poetry-patterns.service.ts",
            "properties": [
                {
                    "name": "forms",
                    "defaultValue": "POETRY_FORMS",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "detectPossibleForms",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 27,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getAllForms",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 18,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getFormInfo",
                    "args": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 14,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getFormOptions",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 40,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getFormPattern",
                    "args": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number[]",
                    "typeParameters": [],
                    "line": 10,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "validateFormCompatibility",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 22,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable } from '@angular/core';\nimport { POETRY_FORMS } from '../../data/poetry-forms.data';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetryPatternsService {\n  private readonly forms = POETRY_FORMS;\n\n  getFormPattern(formId: string): number[] {\n    return this.forms[formId]?.pattern || [];\n  }\n\n  getFormInfo(formId: string) {\n    return this.forms[formId];\n  }\n\n  getAllForms() {\n    return Object.values(this.forms);\n  }\n\n  validateFormCompatibility(lines: string[], formId: string): boolean {\n    const pattern = this.getFormPattern(formId);\n    return lines.length === pattern.length;\n  }\n\n  detectPossibleForms(lines: string[]): string[] {\n    const possibleForms: string[] = [];\n    const lineCount = lines.length;\n\n    Object.entries(this.forms).forEach(([formId, form]) => {\n      if (form.lines === lineCount) {\n        possibleForms.push(formId);\n      }\n    });\n\n    return possibleForms;\n  }\n\n  getFormOptions() {\n    return Object.values(this.forms).map((form) => ({\n      value: form.id,\n      label: form.name,\n      description: form.pattern.join('-'),\n    }));\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "PoetrySuggestionsService",
            "id": "injectable-PoetrySuggestionsService-24eb12fada130bc88b863f4d93cc015155ad8963e6b439cd89626c34ffadb8c508817746d6d4f5f7e11b910ca3bb30339b231a1a9016833254b2677222c8462e",
            "file": "src/app/services/poetry/poetry-suggestions.service.ts",
            "properties": [
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "deduplicateAndRank",
                    "args": [
                        {
                            "name": "alternatives",
                            "type": "AlternativeWord[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "originalWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "context",
                            "type": "SuggestionContext",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "AlternativeWord[]",
                    "typeParameters": [],
                    "line": 79,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "alternatives",
                            "type": "AlternativeWord[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "originalWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "context",
                            "type": "SuggestionContext",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateLineSuggestions",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 118,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getWordAlternatives",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<WordSuggestionData>",
                    "typeParameters": [],
                    "line": 114,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getWordAlternativesEnhanced",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "context",
                            "type": "SuggestionContext",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "{}"
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<WordSuggestionData>",
                    "typeParameters": [],
                    "line": 24,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "context",
                            "type": "SuggestionContext",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "{}",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "searchBySyllables",
                    "args": [
                        {
                            "name": "syllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<AlternativeWord[]>",
                    "typeParameters": [],
                    "line": 61,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "syllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService, type AlternativeWord } from './rita.service';\n\nexport interface WordSuggestionData {\n  original: string;\n  currentSyllables: number;\n  targetSyllables: number;\n  alternatives: AlternativeWord[];\n}\n\nexport interface SuggestionContext {\n  pos?: string;\n  lineIndex?: number;\n  isLineEnd?: boolean;\n  previousWord?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PoetrySuggestionsService {\n  private readonly rita = inject(RitaService);\n\n  async getWordAlternativesEnhanced(\n    word: string,\n    targetSyllables: number,\n    context: SuggestionContext = {}\n  ): Promise<WordSuggestionData> {\n    const currentSyllables = this.rita.analyzeLine(word).syllables;\n\n    // Búsqueda simple y efectiva - CORREGIR parámetros\n    const [exactMatches, rhymes, phonetic] = await Promise.all([\n      this.searchBySyllables(targetSyllables), // ❌ Eliminar context.pos\n      context.isLineEnd\n        ? this.rita.findRhymes(word, targetSyllables).then((r) => r.perfectRhymes)\n        : Promise.resolve([]),\n      this.rita.suggestAlternatives(word, targetSyllables, 6),\n    ]);\n\n    const allAlternatives = [\n      ...exactMatches,\n      ...rhymes.map((w) => ({\n        word: w, // ✅ w es string, no AlternativeWord\n        syllables: targetSyllables,\n        reason: 'rhyme-match' as const,\n        pos: this.rita.analyzeGrammar(w).pos,\n      })),\n      ...phonetic,\n    ];\n\n    const unique = this.deduplicateAndRank(allAlternatives, word, context);\n\n    return {\n      original: word,\n      currentSyllables,\n      targetSyllables,\n      alternatives: unique.slice(0, 10),\n    };\n  }\n\n  private async searchBySyllables(syllables: number): Promise<AlternativeWord[]> {\n    // ❌ Eliminar pos parameter\n    try {\n      // Búsqueda simple por primera letra y sílabas\n      const results = await this.rita.suggestAlternatives('a', syllables, 8);\n\n      // CORREGIR: results ya son AlternativeWord[], no strings\n      return results.map((altWord) => ({\n        // ✅ altWord es AlternativeWord\n        ...altWord,\n        reason: 'exact-match' as const,\n      }));\n    } catch (error) {\n      console.warn('Search by syllables failed:', error);\n      return [];\n    }\n  }\n\n  private deduplicateAndRank(\n    alternatives: AlternativeWord[],\n    originalWord: string,\n    context: SuggestionContext\n  ): AlternativeWord[] {\n    const seen = new Set<string>();\n    const unique = alternatives.filter((alt) => {\n      const key = alt.word.toLowerCase();\n      if (seen.has(key) || key === originalWord.toLowerCase()) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n\n    return unique.sort((a, b) => {\n      if (a.reason === 'exact-match' && b.reason !== 'exact-match') return -1;\n      if (b.reason === 'exact-match' && a.reason !== 'exact-match') return 1;\n\n      if (context.isLineEnd) {\n        if (a.reason === 'rhyme-match' && b.reason !== 'rhyme-match') return -1;\n        if (b.reason === 'rhyme-match' && a.reason !== 'rhyme-match') return 1;\n      }\n\n      if (context.pos) {\n        const aMatchesPOS = a.pos === context.pos;\n        const bMatchesPOS = b.pos === context.pos;\n        if (aMatchesPOS && !bMatchesPOS) return -1;\n        if (bMatchesPOS && !aMatchesPOS) return 1;\n      }\n\n      return 0;\n    });\n  }\n\n  async getWordAlternatives(word: string, targetSyllables: number): Promise<WordSuggestionData> {\n    return this.getWordAlternativesEnhanced(word, targetSyllables);\n  }\n\n  generateLineSuggestions(line: string, targetSyllables: number): string[] {\n    return this.rita.generateSuggestions(line, targetSyllables);\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "RhymeAnalysisService",
            "id": "injectable-RhymeAnalysisService-41d23a934805c1e0266376535441a4f68f9177e738b5b3e6b11525f00a5d9a79108b602cc51de2ccb1b0f714769ed493952a29943cf3d4829715050ceb17ced6",
            "file": "src/app/services/poetry/rhyme-analysis.service.ts",
            "properties": [
                {
                    "name": "rita",
                    "defaultValue": "inject(RitaService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "analyzeRhymeScheme",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 10,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectCrossLineAlliterations",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "AlliterationMatch[]",
                    "typeParameters": [],
                    "line": 14,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectRhymePattern",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "literal type",
                    "typeParameters": [],
                    "line": 58,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RitaService, type AlliterationMatch } from './rita.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RhymeAnalysisService {\n  private readonly rita = inject(RitaService);\n\n  analyzeRhymeScheme(lines: string[]): string {\n    return this.rita.analyzeRhymeScheme(lines);\n  }\n\n  detectCrossLineAlliterations(lines: string[]): AlliterationMatch[] {\n    const allWords: { word: string; lineIndex: number; wordIndex: number }[] = [];\n\n    lines.forEach((line, lineIndex) => {\n      const words = line.split(/\\s+/).filter((w) => /[a-zA-Z]/.test(w));\n      words.forEach((word, wordIndex) => {\n        allWords.push({ word, lineIndex, wordIndex });\n      });\n    });\n\n    const crossLineAlliterations: AlliterationMatch[] = [];\n    const processed = new Set<number>();\n\n    for (let i = 0; i < allWords.length - 1; i++) {\n      if (processed.has(i)) continue;\n\n      const matchingWords: string[] = [allWords[i].word];\n      const positions: number[] = [i];\n\n      for (let j = i + 1; j < allWords.length && j < i + 10; j++) {\n        try {\n          if (this.rita.isRhyme(allWords[i].word, allWords[j].word)) {\n            matchingWords.push(allWords[j].word);\n            positions.push(j);\n            processed.add(j);\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      if (matchingWords.length > 2) {\n        crossLineAlliterations.push({\n          words: matchingWords,\n          positions,\n          sound: matchingWords[0][0],\n        });\n        processed.add(i);\n      }\n    }\n\n    return crossLineAlliterations;\n  }\n\n  detectRhymePattern(lines: string[]): { scheme: string; consistency: number } {\n    const scheme = this.analyzeRhymeScheme(lines);\n    const uniqueRhymes = new Set(scheme.split(''));\n    const consistency = uniqueRhymes.size / scheme.length;\n\n    return { scheme, consistency };\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "RitaService",
            "id": "injectable-RitaService-a8d9e2fad6c4a388a6d481d49cb9a00191fe1ccf051c90ecbeb8b39e2c70341564a50356d74e4613f40c81ce13642b2b73f0a0bd7fd868e7bb1083c41474df1c",
            "file": "src/app/services/poetry/rita.service.ts",
            "properties": [
                {
                    "name": "cache",
                    "defaultValue": "new Map<string, SyllableAnalysis>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 73,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "utils",
                    "defaultValue": "inject(UtilsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 74,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "analyzeGrammar",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "GrammaticalAnalysis",
                    "typeParameters": [],
                    "line": 397,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "analyzeLine",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "SyllableAnalysis",
                    "typeParameters": [],
                    "line": 76,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "analyzeRhymeScheme",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 329,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "analyzeWords",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "WordAnalysis[]",
                    "typeParameters": [],
                    "line": 126,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "clearCache",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 466,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "detectAlliterations",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "AlliterationMatch[]",
                    "typeParameters": [],
                    "line": 238,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "detectTypos",
                    "args": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<literal type[]>",
                    "typeParameters": [],
                    "line": 427,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "lines",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "findRhymes",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<RhymeMatch>",
                    "typeParameters": [],
                    "line": 274,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateSuggestions",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 356,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getLastWord",
                    "args": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 461,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "line",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isRhyme",
                    "args": [
                        {
                            "name": "word1",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "word2",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 321,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "word1",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "word2",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "suggestAlternatives",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "maxResults",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "10"
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<AlternativeWord[]>",
                    "typeParameters": [],
                    "line": 146,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "targetSyllables",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "maxResults",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "10",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, inject } from '@angular/core';\nimport { RiTa } from 'rita';\nimport { UtilsService } from '../core/utils.service';\n\nexport interface SyllableAnalysis {\n  syllables: number;\n  breakdown: string[];\n  stresses: string;\n  phones: string;\n}\n\nexport interface WordAnalysis {\n  word: string;\n  syllables: number;\n  phones: string;\n  pos: string;\n  stresses: string;\n}\n\nexport interface AlternativeWord {\n  word: string;\n  syllables: number;\n  reason:\n    | 'exact-match'\n    | 'rhyme-match'\n    | 'sound-match'\n    | 'semantic-rhyme'\n    | 'spelling-match'\n    | 'morphological';\n  pos?: string;\n}\n\nexport interface AlliterationMatch {\n  words: string[];\n  positions: number[];\n  sound: string;\n}\n\nexport interface RhymeMatch {\n  word: string;\n  rhymesWith: string[];\n  perfectRhymes: string[];\n  nearRhymes: string[];\n}\n\nexport interface AdvancedSearchOptions {\n  syllables?: number;\n  pos?: string;\n  startsWith?: string;\n  endsWith?: string;\n  contains?: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\nexport interface GrammaticalAnalysis {\n  word: string;\n  pos: string;\n  posLabel: string;\n  isNoun: boolean;\n  isVerb: boolean;\n  isAdjective: boolean;\n  isAdverb: boolean;\n  conjugations?: string[];\n  pluralForm?: string;\n  stemForm?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RitaService {\n  private readonly cache = new Map<string, SyllableAnalysis>();\n  private readonly utils = inject(UtilsService);\n\n  analyzeLine(line: string): SyllableAnalysis {\n    const trimmedLine = line.trim();\n\n    if (!trimmedLine) {\n      return { syllables: 0, breakdown: [], stresses: '', phones: '' };\n    }\n\n    const cacheKey = `line:${trimmedLine}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const words = RiTa.tokenize(trimmedLine).filter((word) => /[a-zA-Z]/.test(word));\n\n    let totalSyllables = 0;\n    const syllables: string[] = [];\n    const stresses: string[] = [];\n    const phones: string[] = [];\n\n    words.forEach((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const wordSyllables = syllableStr ? syllableStr.split('/') : [word];\n      totalSyllables += wordSyllables.length;\n\n      syllables.push(...wordSyllables);\n\n      const wordPhones = RiTa.phones(word);\n      if (wordPhones) {\n        phones.push(wordPhones);\n      } else {\n        phones.push('');\n      }\n\n      const stress = RiTa.stresses(word);\n      if (stress) {\n        stresses.push(stress);\n      }\n    });\n\n    const result: SyllableAnalysis = {\n      syllables: totalSyllables,\n      breakdown: syllables,\n      stresses: stresses.join('/'),\n      phones: phones.join(' '),\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  analyzeWords(line: string): WordAnalysis[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n\n    return words.map((word) => {\n      const syllableStr = RiTa.syllables(word);\n      const syllableCount = syllableStr ? syllableStr.split('/').length : 0;\n      const phones = RiTa.phones(word) || '';\n      const pos = RiTa.pos(word)[0] || 'unknown';\n      const stresses = RiTa.stresses(word) || '';\n\n      return {\n        word,\n        syllables: syllableCount,\n        phones,\n        pos,\n        stresses,\n      };\n    });\n  }\n\n  async suggestAlternatives(\n    word: string,\n    targetSyllables: number,\n    maxResults = 10\n  ): Promise<AlternativeWord[]> {\n    const alternatives: AlternativeWord[] = [];\n\n    try {\n      // Búsqueda por sílabas exactas\n      const exactMatches: string[] = [];\n      const allWords = await RiTa.search(new RegExp(`^${word[0]}`, 'i'));\n\n      for (const w of allWords.slice(0, 50)) {\n        try {\n          if (typeof w !== 'string') continue;\n\n          const syllableCount = RiTa.syllables(w).split('/').length;\n          if (syllableCount === targetSyllables && w.toLowerCase() !== word.toLowerCase()) {\n            exactMatches.push(w);\n            if (exactMatches.length >= 5) break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      exactMatches.forEach((w: string) => {\n        alternatives.push({\n          word: w,\n          syllables: targetSyllables,\n          reason: 'exact-match',\n          pos: RiTa.pos(w)[0],\n        });\n      });\n\n      // Búsqueda por rimas\n      if (alternatives.length < maxResults) {\n        const rhymes = await RiTa.rhymes(word);\n        for (const r of rhymes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof r !== 'string') continue;\n\n            const rSyllables = RiTa.syllables(r).split('/').length;\n            if (rSyllables === targetSyllables && r.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: r,\n                syllables: targetSyllables,\n                reason: 'rhyme-match',\n                pos: RiTa.pos(r)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n\n      // Búsqueda por sonido similar\n      if (alternatives.length < maxResults) {\n        const soundAlikes = await RiTa.soundsLike(word);\n        for (const s of soundAlikes) {\n          if (alternatives.length >= maxResults) break;\n          try {\n            if (typeof s !== 'string') continue;\n\n            const sSyllables = RiTa.syllables(s).split('/').length;\n            if (sSyllables === targetSyllables && s.toLowerCase() !== word.toLowerCase()) {\n              alternatives.push({\n                word: s,\n                syllables: targetSyllables,\n                reason: 'sound-match',\n                pos: RiTa.pos(s)[0],\n              });\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error finding alternatives:', error);\n    }\n\n    const uniqueAlternatives = alternatives.filter(\n      (alt, index, self) =>\n        index === self.findIndex((a) => a.word.toLowerCase() === alt.word.toLowerCase())\n    );\n\n    return uniqueAlternatives.slice(0, maxResults);\n  }\n\n  detectAlliterations(line: string): AlliterationMatch[] {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    const alliterations: AlliterationMatch[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      try {\n        if (RiTa.isAlliteration(words[i], words[i + 1])) {\n          const matchingWords = [words[i], words[i + 1]];\n          const positions = [i, i + 1];\n          let j = i + 2;\n\n          while (j < words.length && RiTa.isAlliteration(words[i], words[j])) {\n            matchingWords.push(words[j]);\n            positions.push(j);\n            j++;\n          }\n\n          const phones = RiTa.phones(words[i]);\n          const sound = phones ? phones.split('-')[0] : words[i][0];\n\n          alliterations.push({\n            words: matchingWords,\n            positions,\n            sound,\n          });\n\n          i = j - 1;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    return alliterations;\n  }\n\n  async findRhymes(word: string, targetSyllables?: number): Promise<RhymeMatch> {\n    try {\n      const allRhymes = await RiTa.rhymes(word);\n      const soundAlikes = await RiTa.soundsLike(word);\n\n      let perfectRhymes = allRhymes.filter((r: unknown) => typeof r === 'string');\n      let nearRhymes = soundAlikes.filter(\n        (s: unknown) => typeof s === 'string' && !allRhymes.includes(s)\n      );\n\n      if (targetSyllables !== undefined) {\n        perfectRhymes = perfectRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n\n        nearRhymes = nearRhymes.filter((r: string) => {\n          try {\n            const syllables = RiTa.syllables(r).split('/').length;\n            return syllables === targetSyllables;\n          } catch {\n            return false;\n          }\n        });\n      }\n\n      return {\n        word,\n        rhymesWith: [...perfectRhymes, ...nearRhymes].slice(0, 20),\n        perfectRhymes: perfectRhymes.slice(0, 10),\n        nearRhymes: nearRhymes.slice(0, 10),\n      };\n    } catch (error) {\n      console.warn('Error finding rhymes:', error);\n      return {\n        word,\n        rhymesWith: [],\n        perfectRhymes: [],\n        nearRhymes: [],\n      };\n    }\n  }\n\n  isRhyme(word1: string, word2: string): boolean {\n    try {\n      return RiTa.isRhyme(word1.toLowerCase(), word2.toLowerCase());\n    } catch {\n      return false;\n    }\n  }\n\n  analyzeRhymeScheme(lines: string[]): string {\n    const scheme: string[] = [];\n    let currentLetter = 'A';\n\n    for (let i = 0; i < lines.length; i++) {\n      const lastWord = this.getLastWord(lines[i]);\n      let rhymeLetter = null;\n\n      for (let j = 0; j < i; j++) {\n        const previousLastWord = this.getLastWord(lines[j]);\n        if (this.isRhyme(lastWord, previousLastWord)) {\n          rhymeLetter = scheme[j];\n          break;\n        }\n      }\n\n      if (rhymeLetter) {\n        scheme.push(rhymeLetter);\n      } else {\n        scheme.push(currentLetter);\n        currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n      }\n    }\n\n    return scheme.join('');\n  }\n\n  generateSuggestions(line: string, targetSyllables: number): string[] {\n    const analysis = this.analyzeLine(line);\n    const currentSyllables = analysis.syllables;\n    const difference = targetSyllables - currentSyllables;\n\n    if (difference === 0) {\n      return ['✓ Perfect! This line matches the target syllable count.'];\n    }\n\n    const suggestions: string[] = [];\n\n    if (difference > 0) {\n      suggestions.push(`Add ${difference} syllable${difference > 1 ? 's' : ''} to this line.`);\n      suggestions.push('Try adding descriptive adjectives or adverbs.');\n\n      const words = this.analyzeWords(line);\n      const shortWords = words.filter((w) => w.syllables === 1);\n      if (shortWords.length > 0) {\n        suggestions.push(\n          `Consider replacing short words like \"${shortWords[0].word}\" with longer alternatives.`\n        );\n      }\n    } else {\n      const absDiff = Math.abs(difference);\n      suggestions.push(`Remove ${absDiff} syllable${absDiff > 1 ? 's' : ''} from this line.`);\n      suggestions.push('Try using shorter words or removing unnecessary words.');\n\n      const words = this.analyzeWords(line);\n      const longWords = words\n        .filter((w) => w.syllables > 2)\n        .sort((a, b) => b.syllables - a.syllables);\n      if (longWords.length > 0) {\n        suggestions.push(\n          `Consider replacing \"${longWords[0].word}\" (${longWords[0].syllables} syllables) with a shorter alternative.`\n        );\n      }\n    }\n\n    return suggestions;\n  }\n\n  analyzeGrammar(word: string): GrammaticalAnalysis {\n    const pos = RiTa.pos(word)[0] || 'unknown';\n\n    const analysis: GrammaticalAnalysis = {\n      word,\n      pos,\n      posLabel: this.utils.getPosLabel(pos),\n      isNoun: RiTa.isNoun(word) === 'true',\n      isVerb: RiTa.isVerb(word) === 'true',\n      isAdjective: RiTa.isAdjective(word) === 'true',\n      isAdverb: RiTa.isAdverb(word) === 'true',\n      stemForm: RiTa.stem(word),\n    };\n\n    if (analysis.isVerb) {\n      analysis.conjugations = [\n        RiTa.conjugate(word, { tense: RiTa.PAST }),\n        RiTa.conjugate(word, { tense: RiTa.PRESENT }),\n        RiTa.pastPart(word),\n        RiTa.presentPart(word),\n      ].filter(Boolean);\n    }\n\n    if (analysis.isNoun) {\n      analysis.pluralForm = RiTa.pluralize(word);\n    }\n\n    return analysis;\n  }\n\n  async detectTypos(lines: string[]): Promise<\n    {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[]\n  > {\n    const typos: {\n      line: number;\n      word: string;\n      suggestions: string[];\n    }[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const words = RiTa.tokenize(lines[i]).filter((w) => /[a-zA-Z]/.test(w));\n\n      for (const word of words) {\n        if (!RiTa.hasWord(word) && word.length > 2) {\n          const suggestions = await RiTa.spellsLike(word, { limit: 3 });\n\n          if (suggestions.length > 0) {\n            typos.push({\n              line: i,\n              word,\n              suggestions,\n            });\n          }\n        }\n      }\n    }\n\n    return typos;\n  }\n\n  private getLastWord(line: string): string {\n    const words = RiTa.tokenize(line).filter((word) => /[a-zA-Z]/.test(word));\n    return words[words.length - 1]?.toLowerCase() || '';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "ThemeService",
            "id": "injectable-ThemeService-eb0a14693c99d5a747e1b15c8801151fe40229ec9c63b60b26b5aaae24252d941375e426f3836e3816b01f27e79a6fead9ac2666a47f86b491549df40bb3a721",
            "file": "src/app/services/core/theme.service.ts",
            "properties": [
                {
                    "name": "currentTheme",
                    "defaultValue": "signal<Theme>(this.getInitialTheme())",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 11,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "THEME_KEY",
                    "defaultValue": "'app-theme'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 9,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "applyTheme",
                    "args": [
                        {
                            "name": "theme",
                            "type": "Theme",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 32,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "theme",
                            "type": "Theme",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getInitialTheme",
                    "args": [],
                    "optional": false,
                    "returnType": "Theme",
                    "typeParameters": [],
                    "line": 19,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "setTheme",
                    "args": [
                        {
                            "name": "theme",
                            "type": "Theme",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 41,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "theme",
                            "type": "Theme",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "toggleTheme",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 37,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable, signal, effect } from '@angular/core';\n\nexport type Theme = 'light' | 'dark';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class ThemeService {\n  private readonly THEME_KEY = 'app-theme';\n\n  readonly currentTheme = signal<Theme>(this.getInitialTheme());\n\n  constructor() {\n    effect(() => {\n      this.applyTheme(this.currentTheme());\n    });\n  }\n\n  private getInitialTheme(): Theme {\n    const stored = localStorage.getItem(this.THEME_KEY) as Theme | null;\n    if (stored === 'light' || stored === 'dark') {\n      return stored;\n    }\n\n    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {\n      return 'dark';\n    }\n\n    return 'light';\n  }\n\n  private applyTheme(theme: Theme): void {\n    document.documentElement.setAttribute('data-theme', theme);\n    localStorage.setItem(this.THEME_KEY, theme);\n  }\n\n  toggleTheme(): void {\n    this.currentTheme.update((current) => (current === 'light' ? 'dark' : 'light'));\n  }\n\n  setTheme(theme: Theme): void {\n    this.currentTheme.set(theme);\n  }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 11
            },
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "UtilsService",
            "id": "injectable-UtilsService-681d428fc9fe44e56308b4d6ad7183dc70ebae14a79607632f27185b4ab1fc6734639772c01886b67f3b1cfac558e1f29153235dffac59872bc233a3f91ee762",
            "file": "src/app/services/core/utils.service.ts",
            "properties": [
                {
                    "name": "posLabels",
                    "defaultValue": "{\n    // Nouns\n    nn: 'noun',\n    nns: 'noun (plural)',\n    nnp: 'proper noun',\n    nnps: 'proper noun (plural)',\n\n    // Verbs\n    vb: 'verb',\n    vbd: 'verb (past)',\n    vbg: 'verb (gerund)',\n    vbn: 'verb (past participle)',\n    vbp: 'verb (present)',\n    vbz: 'verb (3rd person)',\n\n    // Adjectives\n    jj: 'adjective',\n    jjr: 'adjective (comparative)',\n    jjs: 'adjective (superlative)',\n\n    // Adverbs\n    rb: 'adverb',\n    rbr: 'adverb (comparative)',\n    rbs: 'adverb (superlative)',\n\n    // Determiners\n    dt: 'determiner',\n    wdt: 'wh-determiner',\n    pdt: 'predeterminer',\n\n    // Prepositions\n    in: 'preposition',\n\n    // Conjunctions\n    cc: 'conjunction',\n\n    // Pronouns\n    prp: 'pronoun',\n    prp$: 'possessive pronoun',\n    wp: 'wh-pronoun',\n    wp$: 'possessive wh-pronoun',\n\n    // Interjections\n    uh: 'interjection',\n\n    // Particles\n    rp: 'particle',\n\n    // Other\n    cd: 'cardinal number',\n    ex: 'existential there',\n    fw: 'foreign word',\n    ls: 'list marker',\n    md: 'modal',\n    pos: 'possessive ending',\n    sym: 'symbol',\n    to: 'to',\n    punc: 'punctuation',\n  }",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Record<string | string>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "getAllPosLabels",
                    "args": [],
                    "optional": false,
                    "returnType": "Record<string, string>",
                    "typeParameters": [],
                    "line": 71,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getPosLabel",
                    "args": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 67,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class UtilsService {\n  private readonly posLabels: Record<string, string> = {\n    // Nouns\n    nn: 'noun',\n    nns: 'noun (plural)',\n    nnp: 'proper noun',\n    nnps: 'proper noun (plural)',\n\n    // Verbs\n    vb: 'verb',\n    vbd: 'verb (past)',\n    vbg: 'verb (gerund)',\n    vbn: 'verb (past participle)',\n    vbp: 'verb (present)',\n    vbz: 'verb (3rd person)',\n\n    // Adjectives\n    jj: 'adjective',\n    jjr: 'adjective (comparative)',\n    jjs: 'adjective (superlative)',\n\n    // Adverbs\n    rb: 'adverb',\n    rbr: 'adverb (comparative)',\n    rbs: 'adverb (superlative)',\n\n    // Determiners\n    dt: 'determiner',\n    wdt: 'wh-determiner',\n    pdt: 'predeterminer',\n\n    // Prepositions\n    in: 'preposition',\n\n    // Conjunctions\n    cc: 'conjunction',\n\n    // Pronouns\n    prp: 'pronoun',\n    prp$: 'possessive pronoun',\n    wp: 'wh-pronoun',\n    wp$: 'possessive wh-pronoun',\n\n    // Interjections\n    uh: 'interjection',\n\n    // Particles\n    rp: 'particle',\n\n    // Other\n    cd: 'cardinal number',\n    ex: 'existential there',\n    fw: 'foreign word',\n    ls: 'list marker',\n    md: 'modal',\n    pos: 'possessive ending',\n    sym: 'symbol',\n    to: 'to',\n    punc: 'punctuation',\n  };\n\n  getPosLabel(pos: string): string {\n    return this.posLabels[pos.toLowerCase()] || pos;\n  }\n\n  getAllPosLabels(): Record<string, string> {\n    return { ...this.posLabels };\n  }\n}\n",
            "extends": [],
            "type": "injectable"
        }
    ],
    "guards": [],
    "interceptors": [],
    "classes": [],
    "directives": [],
    "components": [
        {
            "name": "AccordionComponent",
            "id": "component-AccordionComponent-445bbb3611363790961e8dd46d8670559cb580dfa625ff8e5753fdfd74d4a0dd0733a38ffb833669a2075dc10f754f5d434e8a5cbd9f810ff3d873dcad6e5bf0",
            "file": "src/app/components/accordion/accordion.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-accordion",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./accordion.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "expanded",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 10,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 11,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "title",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 9,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "toggle",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 13,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-accordion',\n  standalone: true,\n  templateUrl: './accordion.component.html',\n})\nexport class AccordionComponent {\n  @Input() title = '';\n  @Input() expanded = false;\n  @Input() icon?: string;\n\n  toggle(): void {\n    this.expanded = !this.expanded;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<div class=\"metro-accordion\">\n  <button\n    type=\"button\"\n    class=\"metro-accordion-header\"\n    (click)=\"toggle()\"\n    [attr.aria-expanded]=\"expanded\"\n  >\n    <div class=\"accordion-title-section\">\n      @if (icon) {\n        <span [class]=\"icon + ' accordion-icon'\"></span>\n      }\n      <span class=\"accordion-title\">{{ title }}</span>\n    </div>\n    \n    @if (expanded) {\n      <span class=\"icon-[iconoir--nav-arrow-up] accordion-chevron\"></span>\n    } @else {\n      <span class=\"icon-[iconoir--nav-arrow-down] accordion-chevron\"></span>\n    }\n  </button>\n  \n  @if (expanded) {\n    <div class=\"metro-accordion-content\">\n      <ng-content />\n    </div>\n  }\n</div>"
        },
        {
            "name": "AnalysisPanelComponent",
            "id": "component-AnalysisPanelComponent-f2a42957f3f30f2b7246baa47e7c33b1118eac16884b9e1e6f425c3bae42c6ca989d0625fcf28555f49e38197c6602cc67404c0587adeeac9088413966955290",
            "file": "src/app/components/analysis-panel/analysis-panel.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-analysis-panel",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./analysis-panel.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "compact",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 19,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "metrics",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 18,
                    "type": "AnalysisMetric[]",
                    "decorators": []
                },
                {
                    "name": "title",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 17,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "getMetricVariant",
                    "args": [
                        {
                            "name": "metric",
                            "type": "AnalysisMetric",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 21,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "metric",
                            "type": "AnalysisMetric",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getProgressWidth",
                    "args": [
                        {
                            "name": "metric",
                            "type": "AnalysisMetric",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 25,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "metric",
                            "type": "AnalysisMetric",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\n\nexport interface AnalysisMetric {\n  label: string;\n  value: number | string;\n  maxValue?: number;\n  variant?: 'default' | 'success' | 'warning' | 'error';\n  icon?: string;\n}\n\n@Component({\n  selector: 'app-analysis-panel',\n  standalone: true,\n  templateUrl: './analysis-panel.component.html',\n})\nexport class AnalysisPanelComponent {\n  @Input() title = '';\n  @Input() metrics: AnalysisMetric[] = [];\n  @Input() compact = false;\n\n  getMetricVariant(metric: AnalysisMetric): string {\n    return `metric-${metric.variant || 'default'}`;\n  }\n\n  getProgressWidth(metric: AnalysisMetric): string {\n    if (metric.maxValue && typeof metric.value === 'number') {\n      const percentage = (metric.value / metric.maxValue) * 100;\n      return `${Math.min(percentage, 100)}%`;\n    }\n    return '0%';\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card [padding]=\"compact ? 'small' : 'medium'\">\n  <div class=\"analysis-panel\">\n    <h3 class=\"panel-title\">{{ title }}</h3>\n    \n    <div class=\"metrics-grid\">\n      @for (metric of metrics; track metric.label) {\n        <div class=\"metric-item\">\n          <div class=\"metric-header\">\n            @if (metric.icon) {\n              <span [class]=\"metric.icon + ' metric-icon'\"></span>\n            }\n            <span class=\"metric-label\">{{ metric.label }}</span>\n            <span class=\"metric-value\">{{ metric.value }}</span>\n          </div>\n          \n          @if (metric.maxValue && typeof metric.value === 'number') {\n            <div class=\"metric-progress\">\n              <div \n                class=\"metric-progress-bar\"\n                [class]=\"getMetricVariant(metric)\"\n                [style.width]=\"getProgressWidth(metric)\"\n              ></div>\n            </div>\n          }\n        </div>\n      }\n    </div>\n  </div>\n</app-card>"
        },
        {
            "name": "App",
            "id": "component-App-d566eac646c0cfc02f333c6a49e8b033094c7ed70572abe3bdaf977b8f63e1087861db722ebe0fe42cccb8fa47461be98b034dfa2fcf71eafcebe5c3425dcc98",
            "file": "src/app/app.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-root",
            "styleUrls": [],
            "styles": [],
            "template": "<app-poetry-page />",
            "templateUrl": [],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": false,
            "imports": [
                {
                    "name": "PoetryPageComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component } from '@angular/core';\nimport { PoetryPageComponent } from './components/poetry-page/poetry-page.component';\n\n@Component({\n  selector: 'app-root',\n  imports: [PoetryPageComponent],\n  template: '<app-poetry-page />',\n})\nexport class App {}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": []
        },
        {
            "name": "BadgeComponent",
            "id": "component-BadgeComponent-f2f34ee1e09d2a39b10636d8b030818597c54c5c0d1370aa3a3f018e4c561f2bae574245bedc1f7752007b5a38cb4a15815ce0cd399de85b75db1defffc2a5fc",
            "file": "src/app/components/badge/badge.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-badge",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./badge.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 11,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "size",
                    "defaultValue": "'medium'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 10,
                    "type": "\"small\" | \"medium\"",
                    "decorators": []
                },
                {
                    "name": "variant",
                    "defaultValue": "'default'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 9,
                    "type": "\"default\" | \"info\" | \"success\" | \"warning\" | \"error\"",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-badge',\n  standalone: true,\n  templateUrl: './badge.component.html',\n})\nexport class BadgeComponent {\n  @Input() variant: 'default' | 'info' | 'success' | 'warning' | 'error' = 'default';\n  @Input() size: 'small' | 'medium' = 'medium';\n  @Input() icon?: string;\n\n  get badgeClasses(): string {\n    return `badge-${this.variant} badge-${this.size}`;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "accessors": {
                "badgeClasses": {
                    "name": "badgeClasses",
                    "getSignature": {
                        "name": "badgeClasses",
                        "type": "string",
                        "returnType": "string",
                        "line": 13
                    }
                }
            },
            "templateData": "<span [class]=\"badgeClasses\">\n  @if (icon) {\n    <span [class]=\"icon\"></span>\n  }\n  <ng-content />\n</span>"
        },
        {
            "name": "ButtonComponent",
            "id": "component-ButtonComponent-1038697c02f5d2e6b3d474c47190ad32dada1bff889730491450094713a066cbef2b7929a59f5cca48c6bfd43a917cfef4bc2a36ce5fbf78ee21df4e4ad225e8",
            "file": "src/app/components/button/button.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-button",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./button.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "disabled",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 13,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "icon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 12,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "label",
                    "defaultValue": "'Button'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 11,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "size",
                    "defaultValue": "'medium'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 10,
                    "type": "\"small\" | \"medium\" | \"large\"",
                    "decorators": []
                },
                {
                    "name": "variant",
                    "defaultValue": "'primary'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 9,
                    "type": "\"primary\" | \"secondary\" | \"outline\"",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "clicked",
                    "defaultValue": "new EventEmitter<Event>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 14,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'app-button',\n  standalone: true,\n  templateUrl: './button.component.html',\n})\nexport class ButtonComponent {\n  @Input() variant: 'primary' | 'secondary' | 'outline' = 'primary';\n  @Input() size: 'small' | 'medium' | 'large' = 'medium';\n  @Input() label = 'Button';\n  @Input() icon?: string;\n  @Input() disabled = false;\n  @Output() clicked = new EventEmitter<Event>();\n\n  get buttonClasses(): string {\n    const sizeClasses = {\n      small: 'btn-small',\n      medium: 'btn-medium',\n      large: 'btn-large',\n    };\n\n    const variantClasses = {\n      primary: 'btn-primary',\n      secondary: 'btn-secondary',\n      outline: 'btn-outline',\n    };\n\n    return `btn-base ${sizeClasses[this.size]} ${variantClasses[this.variant]}`;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "accessors": {
                "buttonClasses": {
                    "name": "buttonClasses",
                    "getSignature": {
                        "name": "buttonClasses",
                        "type": "string",
                        "returnType": "string",
                        "line": 16
                    }
                }
            },
            "templateData": "<button\n  type=\"button\"\n  (click)=\"!disabled && clicked.emit($event)\"\n  [class]=\"buttonClasses\"\n  [disabled]=\"disabled\"\n>\n  @if (icon) {\n    <span [class]=\"icon\"></span>\n  }\n  {{ label }}\n</button>\n"
        },
        {
            "name": "CardComponent",
            "id": "component-CardComponent-27824ee1b72b2fa55dedcdc921e8fbb3d83c9866b34f3a4887eb045a87e9a633c5ed5fe1867da44c85f54ed02cba5ff890694de7c9ff6bf05ea6789502cce200",
            "file": "src/app/components/card/card.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-card",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./card.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "clickable",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 11,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "padding",
                    "defaultValue": "'medium'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 10,
                    "type": "\"none\" | \"small\" | \"medium\" | \"large\"",
                    "decorators": []
                },
                {
                    "name": "variant",
                    "defaultValue": "'default'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 9,
                    "type": "\"default\" | \"elevated\"",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-card',\n  standalone: true,\n  templateUrl: './card.component.html',\n})\nexport class CardComponent {\n  @Input() variant: 'default' | 'elevated' = 'default';\n  @Input() padding: 'none' | 'small' | 'medium' | 'large' = 'medium';\n  @Input() clickable = false;\n\n  get cardClasses(): string {\n    const classes = [`card-${this.variant}`, `card-padding-${this.padding}`];\n\n    if (this.clickable) {\n      classes.push('clickable');\n    }\n\n    return classes.join(' ');\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "accessors": {
                "cardClasses": {
                    "name": "cardClasses",
                    "getSignature": {
                        "name": "cardClasses",
                        "type": "string",
                        "returnType": "string",
                        "line": 13
                    }
                }
            },
            "templateData": "<div \n  [class]=\"cardClasses\"\n  [class.clickable]=\"clickable\"\n>\n  <ng-content />\n</div>"
        },
        {
            "name": "EmptyStateComponent",
            "id": "component-EmptyStateComponent-288721b8bc86bd21b9f9d82c06301ed7b6ef16204c71d454d699da0c51c4a8d21386251ae3a5baf2f01b7a78756881c27c8ddda60f7a1c29a554e4141a4f6e56",
            "file": "src/app/components/empty-state/empty-state.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-empty-state",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./empty-state.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "actionLabel",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 14,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "description",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 13,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "icon",
                    "defaultValue": "'icon-[iconoir--page-search]'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 11,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "title",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 12,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "action",
                    "defaultValue": "new EventEmitter<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 15,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "ButtonComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { ButtonComponent } from '../button/button.component';\n\n@Component({\n  selector: 'app-empty-state',\n  standalone: true,\n  imports: [ButtonComponent],\n  templateUrl: './empty-state.component.html',\n})\nexport class EmptyStateComponent {\n  @Input() icon = 'icon-[iconoir--page-search]';\n  @Input() title = '';\n  @Input() description = '';\n  @Input() actionLabel?: string;\n  @Output() action = new EventEmitter<void>();\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<div class=\"empty-state\">\n  <span [class]=\"icon + ' empty-state-icon'\"></span>\n  <h3 class=\"empty-state-title\">{{ title }}</h3>\n  @if (description) {\n    <p class=\"empty-state-description\">{{ description }}</p>\n  }\n  @if (actionLabel) {\n    <app-button\n      variant=\"primary\"\n      (clicked)=\"action.emit()\"\n      [label]=\"actionLabel\"\n    />\n  }\n</div>"
        },
        {
            "name": "FooterComponent",
            "id": "component-FooterComponent-6fcce356e0a15a4d237d1ef58c76703bf97489a49bc0cd69a76c13efa849a4e0ba8970d3197f9d5e25f478fe797f9cee3827105907427788f2a4665665573306",
            "file": "src/app/components/footer/footer.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-footer",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./footer.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-footer',\n  standalone: true,\n  templateUrl: './footer.component.html',\n})\nexport class FooterComponent {}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<footer class=\"metro-footer\">\n  <div class=\"footer-content\">\n    <!-- Información del sitio -->\n    <div class=\"footer-info\">\n      <div class=\"footer-logo\">\n        <span class=\"icon-[iconoir--flower] text-lg text-primary\"></span>\n        <span class=\"footer-title\">harawihark</span>\n      </div>\n      <p class=\"footer-description\">\n        Advanced syllable-meter checker with AI-powered suggestions\n      </p>\n    </div>\n\n    <!-- Enlaces rápidos -->\n    <div class=\"footer-links\">\n      <div class=\"link-group\">\n        <h4 class=\"link-group-title\">resources</h4>\n        <a \n          href=\"https://github.com/benitoanagua/HarawiHark\" \n          target=\"_blank\" \n          rel=\"noopener noreferrer\"\n          class=\"footer-link\"\n        >\n          <span class=\"icon-[iconoir--github]\"></span>\n          GitHub\n        </a>\n        <a href=\"#\" class=\"footer-link\">\n          <span class=\"icon-[iconoir--book-stack]\"></span>\n          Documentation\n        </a>\n      </div>\n      \n      <div class=\"link-group\">\n        <h4 class=\"link-group-title\">poetry forms</h4>\n        <span class=\"footer-link\">haiku</span>\n        <span class=\"footer-link\">tanka</span>\n        <span class=\"footer-link\">limerick</span>\n        <span class=\"footer-link\">cinquain</span>\n      </div>\n    </div>\n\n    <!-- Copyright -->\n    <div class=\"footer-bottom\">\n      <p class=\"copyright\">\n        &copy; 2024 harawihark. Built with Angular & Tailwind.\n      </p>\n    </div>\n  </div>\n</footer>"
        },
        {
            "name": "HeaderComponent",
            "id": "component-HeaderComponent-9b2873b67b9a271cce994020211b9be78f50c52587eedaf3968f4ad3c2f81c558229f2b1dfa3f3c73d4c21a4b05038498ee98ae268f19158f11a3c6472280b4a",
            "file": "src/app/components/header/header.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-header",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./header.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "ThemeToggleComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component } from '@angular/core';\nimport { ThemeToggleComponent } from '../theme-toggle/theme-toggle.component';\n\n@Component({\n  selector: 'app-header',\n  standalone: true,\n  imports: [ThemeToggleComponent],\n  templateUrl: './header.component.html',\n})\nexport class HeaderComponent {}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<header class=\"metro-header\">\n  <div class=\"header-content\">\n    <!-- Logo y nombre del sitio -->\n    <div class=\"logo-section\">\n      <div class=\"logo-wrapper\">\n        <span class=\"icon-[iconoir--flower] text-2xl text-primary\"></span>\n        <h1 class=\"logo-title\">harawihark</h1>\n      </div>\n    </div>\n\n    <!-- Navegación -->\n    <div class=\"nav-section\">\n      <!-- Enlace GitHub -->\n      <a \n        href=\"https://github.com/benitoanagua/HarawiHark\" \n        target=\"_blank\" \n        rel=\"noopener noreferrer\"\n        class=\"github-link\"\n        aria-label=\"GitHub Repository\"\n      >\n        <span class=\"icon-[iconoir--github] text-xl\"></span>\n      </a>\n      \n      <!-- Theme Toggle -->\n      <app-theme-toggle />\n    </div>\n  </div>\n</header>"
        },
        {
            "name": "InputComponent",
            "id": "component-InputComponent-fb4a73b3a4f3ed8acf809fe1e6c9ab3eda66abaea03f162608c6190e9b0db00073d6af15352c56ef85ae5388677d03000560fdd867353d464d185efef933d70f",
            "file": "src/app/components/input/input.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [
                {
                    "name": ")"
                }
            ],
            "selector": "app-input",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./input.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "disabled",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 21,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "error",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 20,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "id",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 23,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "label",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 18,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "placeholder",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 19,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "rows",
                    "defaultValue": "6",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 22,
                    "type": "number",
                    "decorators": []
                },
                {
                    "name": "type",
                    "defaultValue": "'text'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 17,
                    "type": "\"text\" | \"textarea\"",
                    "decorators": []
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 26,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "inputBlur",
                    "defaultValue": "new EventEmitter<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 37,
                    "type": "EventEmitter"
                },
                {
                    "name": "inputChange",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 36,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "_value",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 34
                },
                {
                    "name": "onChange",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 39,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "onTouched",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 42,
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "onBlur",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 69,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onInput",
                    "args": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 62,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnChange",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "string",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ]
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 50,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "string",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnTouched",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": []
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 54,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setDisabledState",
                    "args": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 58,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "writeValue",
                    "args": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 46,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter, forwardRef } from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\n\n@Component({\n  selector: 'app-input',\n  standalone: true,\n  templateUrl: './input.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => InputComponent),\n      multi: true,\n    },\n  ],\n})\nexport class InputComponent implements ControlValueAccessor {\n  @Input() type: 'text' | 'textarea' = 'text';\n  @Input() label = '';\n  @Input() placeholder = '';\n  @Input() error = '';\n  @Input() disabled = false;\n  @Input() rows = 6;\n  @Input() id = '';\n\n  @Input()\n  get value(): string {\n    return this._value;\n  }\n  set value(val: string) {\n    this._value = val || '';\n    this.onChange(this._value);\n  }\n\n  _value = '';\n\n  @Output() inputChange = new EventEmitter<string>();\n  @Output() inputBlur = new EventEmitter<void>();\n\n  private onChange: (value: string) => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private onTouched: () => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n\n  writeValue(value: string): void {\n    this._value = value || '';\n  }\n\n  registerOnChange(fn: (value: string) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  onInput(event: Event): void {\n    const target = event.target as HTMLInputElement | HTMLTextAreaElement;\n    this._value = target.value;\n    this.onChange(this._value);\n    this.inputChange.emit(this._value);\n  }\n\n  onBlur(): void {\n    this.onTouched();\n    this.inputBlur.emit();\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "implements": [
                "ControlValueAccessor"
            ],
            "accessors": {
                "value": {
                    "name": "value",
                    "setSignature": {
                        "name": "value",
                        "type": "void",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "args": [
                            {
                                "name": "val",
                                "type": "string",
                                "deprecated": false,
                                "deprecationMessage": ""
                            }
                        ],
                        "returnType": "void",
                        "line": 29,
                        "jsdoctags": [
                            {
                                "name": "val",
                                "type": "string",
                                "deprecated": false,
                                "deprecationMessage": "",
                                "tagName": {
                                    "text": "param"
                                }
                            }
                        ]
                    },
                    "getSignature": {
                        "name": "value",
                        "type": "string",
                        "returnType": "string",
                        "line": 26
                    }
                }
            },
            "templateData": "<div class=\"input-wrapper\">\n  @if (label) {\n    <label class=\"input-label\" [for]=\"id\">{{ label }}</label>\n  }\n\n  @if (type === 'textarea') {\n    <textarea\n      class=\"input-base input-textarea\"\n      [class.input-error]=\"error\"\n      [placeholder]=\"placeholder\"\n      [disabled]=\"disabled\"\n      [rows]=\"rows\"\n      [value]=\"_value\"\n      [id]=\"id\"\n      (input)=\"onInput($event)\"\n      (blur)=\"onBlur()\"\n    ></textarea>\n  } @else {\n    <input\n      class=\"input-base input-text\"\n      [class.input-error]=\"error\"\n      [type]=\"type\"\n      [placeholder]=\"placeholder\"\n      [disabled]=\"disabled\"\n      [value]=\"_value\"\n      [id]=\"id\"\n      (input)=\"onInput($event)\"\n      (blur)=\"onBlur()\"\n    />\n  }\n\n  @if (error) {\n    <span class=\"input-error-text\">{{ error }}</span>\n  }\n</div>\n"
        },
        {
            "name": "LoadingSpinnerComponent",
            "id": "component-LoadingSpinnerComponent-82c632d05ccd9ac4bb1e4bf1550bcf185a46bcf00d5f0d315cb9e3ff22fe2bc58ae35bccd713f3bbf0fb647626fc4dc2d22b0371b799aa396a653e9f1acd2a5b",
            "file": "src/app/components/loading-spinner/loading-spinner.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-loading-spinner",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./loading-spinner.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "size",
                    "defaultValue": "'medium'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 9,
                    "type": "\"small\" | \"medium\" | \"large\"",
                    "decorators": []
                },
                {
                    "name": "text",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 10,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-loading-spinner',\n  standalone: true,\n  templateUrl: './loading-spinner.component.html',\n})\nexport class LoadingSpinnerComponent {\n  @Input() size: 'small' | 'medium' | 'large' = 'medium';\n  @Input() text?: string;\n\n  get spinnerClasses(): string {\n    return `spinner-${this.size}`;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "accessors": {
                "spinnerClasses": {
                    "name": "spinnerClasses",
                    "getSignature": {
                        "name": "spinnerClasses",
                        "type": "string",
                        "returnType": "string",
                        "line": 12
                    }
                }
            },
            "templateData": "<div class=\"spinner-wrapper\">\n  <div [class]=\"spinnerClasses\"></div>\n  @if (text) {\n    <p class=\"spinner-text\">{{ text }}</p>\n  }\n</div>"
        },
        {
            "name": "MeterAnalysisSectionComponent",
            "id": "component-MeterAnalysisSectionComponent-9f00e166e3e19d3629003d81337f3bf5f91c72287dd86cac17ed51823a28b986e023fc4f5256d558f8bd09ab287056621d5756e3672c8193bd7bae96ade5792c",
            "file": "src/app/components/meter-analysis-section/meter-analysis-section.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-meter-analysis-section",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./meter-analysis-section.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "required": true,
                    "name": "result",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "optional": false,
                    "line": 14,
                    "type": "EnhancedPoetryResult",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                },
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "BadgeComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CardComponent } from '../card/card.component';\nimport { BadgeComponent } from '../badge/badge.component';\nimport { EnhancedPoetryResult } from '../../services/poetry';\n\n@Component({\n  selector: 'app-meter-analysis-section',\n  standalone: true,\n  imports: [CommonModule, CardComponent, BadgeComponent],\n  templateUrl: './meter-analysis-section.component.html',\n})\nexport class MeterAnalysisSectionComponent {\n  @Input({ required: true }) result!: EnhancedPoetryResult;\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card padding=\"large\">\n  <div class=\"meter-analysis-container\">\n    <h3 class=\"section-title\">rhythm & meter analysis</h3>\n    \n    @if (result.meterAnalysis; as meter) {\n      <div class=\"meter-info\">\n        <div class=\"meter-header\">\n          <app-badge \n            [variant]=\"meter.consistency > 70 ? 'success' : meter.consistency > 40 ? 'warning' : 'error'\"\n            size=\"medium\"\n            icon=\"icon-[iconoir--music-double]\"\n          >\n            {{ meter.type }} meter\n          </app-badge>\n          <span class=\"consistency-score\">\n            {{ meter.consistency.toFixed(0) }}% consistent\n          </span>\n        </div>\n        \n        <p class=\"meter-pattern\">{{ meter.pattern }}</p>\n        <p class=\"meter-description\">{{ meter.description }}</p>\n        \n        @if (meter.examples.length > 0) {\n          <div class=\"meter-examples\">\n            <h4>examples of {{ meter.type }} meter:</h4>\n            <ul class=\"examples-list\">\n              @for (example of meter.examples; track $index) {\n                <li class=\"example-item\">{{ example }}</li>\n              }\n            </ul>\n          </div>\n        }\n      </div>\n    } @else {\n      <div class=\"no-meter-analysis\">\n        <span class=\"icon-[iconoir--music-off] no-meter-icon\"></span>\n        <p class=\"no-meter-text\">No consistent meter pattern detected</p>\n      </div>\n    }\n  </div>\n</app-card>"
        },
        {
            "name": "PoemEditorComponent",
            "id": "component-PoemEditorComponent-a56b44b571d9f11956ac64c2d44cdaa16514a066df6ee71d0e042c39fcddd2a5766a3a63cfdc0986277af1590531913ed1fa109dfcd2fbb705ddf4b9b15a8a30",
            "file": "src/app/components/poem-editor/poem-editor.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-poem-editor",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./poem-editor.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "analyzer",
                    "defaultValue": "inject(PoetryAnalyzerService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "currentForm",
                    "defaultValue": "computed(() => this.patterns.getFormInfo(this.selectedForm()))",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 24,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "formOptions",
                    "defaultValue": "POETRY_FORM_OPTIONS",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 20,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "lineCount",
                    "defaultValue": "computed(() => this.lines().length)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 30,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "lines",
                    "defaultValue": "computed(() =>\n    this.poemText()\n      .split('\\n')\n      .filter((line) => line.trim().length > 0)\n  )",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 25,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "patterns",
                    "defaultValue": "inject(PoetryPatternsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "poemText",
                    "defaultValue": "signal('')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "selectedForm",
                    "defaultValue": "signal('haiku')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 21,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "totalSyllables",
                    "defaultValue": "computed(() => {\n    return this.lines().reduce((total, line) => {\n      return total + this.analyzer['rita'].analyzeLine(line).syllables;\n    }, 0);\n  })",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 31,
                    "modifierKind": [
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "analyze",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 62,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "clear",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 56,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "loadExample",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 47,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onFormChange",
                    "args": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 37,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "formId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onTextChange",
                    "args": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 42,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "SelectComponent",
                    "type": "component"
                },
                {
                    "name": "InputComponent",
                    "type": "component"
                },
                {
                    "name": "ButtonComponent",
                    "type": "component"
                },
                {
                    "name": "CardComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, signal, computed, inject } from '@angular/core';\nimport { SelectComponent } from '../select/select.component';\nimport { InputComponent } from '../input/input.component';\nimport { ButtonComponent } from '../button/button.component';\nimport { CardComponent } from '../card/card.component';\nimport { POETRY_FORM_OPTIONS, POETRY_EXAMPLES } from '../../data/poetry-forms.data';\nimport { PoetryAnalyzerService } from '../../services/poetry';\nimport { PoetryPatternsService } from '../../services/poetry';\n\n@Component({\n  selector: 'app-poem-editor',\n  standalone: true,\n  imports: [SelectComponent, InputComponent, ButtonComponent, CardComponent],\n  templateUrl: './poem-editor.component.html',\n})\nexport class PoemEditorComponent {\n  private readonly analyzer = inject(PoetryAnalyzerService);\n  private readonly patterns = inject(PoetryPatternsService);\n\n  readonly formOptions = POETRY_FORM_OPTIONS;\n  readonly selectedForm = signal('haiku');\n  readonly poemText = signal('');\n\n  readonly currentForm = computed(() => this.patterns.getFormInfo(this.selectedForm()));\n  readonly lines = computed(() =>\n    this.poemText()\n      .split('\\n')\n      .filter((line) => line.trim().length > 0)\n  );\n  readonly lineCount = computed(() => this.lines().length);\n  readonly totalSyllables = computed(() => {\n    return this.lines().reduce((total, line) => {\n      return total + this.analyzer['rita'].analyzeLine(line).syllables;\n    }, 0);\n  });\n\n  onFormChange(formId: string): void {\n    this.selectedForm.set(formId);\n    this.analyzer.selectedForm.set(formId);\n  }\n\n  onTextChange(text: string): void {\n    this.poemText.set(text);\n    this.analyzer.poemText.set(text);\n  }\n\n  loadExample(): void {\n    const formId = this.selectedForm();\n    const example = POETRY_EXAMPLES[formId];\n    if (example) {\n      this.poemText.set(example.join('\\n'));\n      this.analyzer.poemText.set(example.join('\\n'));\n    }\n  }\n\n  clear(): void {\n    this.poemText.set('');\n    this.analyzer.poemText.set('');\n    this.analyzer.clear();\n  }\n\n  analyze(): void {\n    const formId = this.selectedForm();\n    const lines = this.lines();\n\n    if (lines.length === 0) return;\n\n    this.analyzer.analyze(formId, lines);\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card padding=\"large\">\n  <div class=\"editor-container\">\n    <!-- Header -->\n    <div class=\"editor-header\">\n      <h2 class=\"editor-title\">poetry analyzer</h2>\n      <p class=\"editor-subtitle\">\n        write your poem and get advanced syllable analysis with word suggestions\n      </p>\n    </div>\n\n    <!-- Form Selection -->\n    <div class=\"form-section\">\n      <app-select\n        id=\"poetry-form\"\n        label=\"poetry form\"\n        [options]=\"formOptions\"\n        [value]=\"selectedForm()\"\n        (selectChange)=\"onFormChange($event)\"\n      />\n\n      @if (currentForm(); as form) {\n      <div class=\"form-info\">\n        <div class=\"form-info-header\">\n          <span class=\"form-pattern\">pattern: {{ form.pattern.join('-') }} syllables</span>\n          <span class=\"form-lines\">{{ form.lines }} lines</span>\n        </div>\n        <p class=\"form-description\">{{ form.description }} · {{ form.origin }}</p>\n      </div>\n      }\n    </div>\n\n    <!-- Poem Input -->\n    <div class=\"input-section\">\n      <app-input\n        id=\"poem-text\"\n        type=\"textarea\"\n        label=\"your poem\"\n        placeholder=\"write each line on a new line...\"\n        [rows]=\"8\"\n        [value]=\"poemText()\"\n        (inputChange)=\"onTextChange($event)\"\n      />\n\n      <div class=\"input-stats\">\n        <span>{{ lineCount() }} lines</span>\n        <span>{{ totalSyllables() }} total syllables</span>\n      </div>\n    </div>\n\n    <!-- Actions -->\n    <div class=\"actions-section\">\n      <app-button\n        variant=\"primary\"\n        size=\"medium\"\n        label=\"analyze poem\"\n        icon=\"icon-[iconoir--search]\"\n        [disabled]=\"lineCount() === 0\"\n        (clicked)=\"analyze()\"\n      />\n\n      <app-button\n        variant=\"secondary\"\n        size=\"medium\"\n        label=\"load example\"\n        icon=\"icon-[iconoir--page]\"\n        (clicked)=\"loadExample()\"\n      />\n      \n      <app-button\n        variant=\"outline\"\n        size=\"medium\"\n        label=\"clear\"\n        icon=\"icon-[iconoir--cancel]\"\n        (clicked)=\"clear()\"\n      />\n    </div>\n  </div>\n</app-card>\n"
        },
        {
            "name": "PoemQualityComponent",
            "id": "component-PoemQualityComponent-756155cc22d7214540ca6b4767bd661b2b9b62b808a0128e54597e77bea1f5d8773a8768ee09c5c460a7252aa52f02c7d29dd8ee648ed3ebea448750c749f05d",
            "file": "src/app/components/poem-quality/poem-quality.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-poem-quality",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./poem-quality.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "required": true,
                    "name": "metrics",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "optional": false,
                    "line": 14,
                    "type": "QualityMetrics",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "getGradeVariant",
                    "args": [
                        {
                            "name": "grade",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "\"success\" | \"info\" | \"warning\" | \"error\"",
                    "typeParameters": [],
                    "line": 30,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "grade",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getMetricColor",
                    "args": [
                        {
                            "name": "value",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 23,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getMetricEntries",
                    "args": [],
                    "optional": false,
                    "returnType": "literal type[]",
                    "typeParameters": [],
                    "line": 16,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                },
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "BadgeComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { QualityMetrics } from '../../services/poetry';\nimport { CardComponent } from '../card/card.component';\nimport { BadgeComponent } from '../badge/badge.component';\n\n@Component({\n  selector: 'app-poem-quality',\n  standalone: true,\n  imports: [CommonModule, CardComponent, BadgeComponent],\n  templateUrl: './poem-quality.component.html',\n})\nexport class PoemQualityComponent {\n  @Input({ required: true }) metrics!: QualityMetrics;\n\n  getMetricEntries(): { name: string; value: number }[] {\n    return Object.entries(this.metrics.breakdown).map(([key, value]) => ({\n      name: key.replace(/([A-Z])/g, ' $1').toLowerCase(),\n      value,\n    }));\n  }\n\n  getMetricColor(value: number): string {\n    if (value >= 80) return 'metric-excellent';\n    if (value >= 70) return 'metric-good';\n    if (value >= 60) return 'metric-fair';\n    return 'metric-poor';\n  }\n\n  getGradeVariant(grade: string): 'success' | 'info' | 'warning' | 'error' {\n    switch (grade) {\n      case 'A+':\n      case 'A':\n        return 'success';\n      case 'B+':\n      case 'B':\n        return 'info';\n      case 'C+':\n      case 'C':\n        return 'warning';\n      default:\n        return 'error';\n    }\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card padding=\"large\" *ngIf=\"metrics\">\n  <div class=\"quality-container\">\n    <!-- Header con puntuación -->\n    <div class=\"quality-header\">\n      <div class=\"score-section\">\n        <h3 class=\"quality-title\">quality assessment</h3>\n        <div class=\"score-display\">\n          <span class=\"score-number\">{{ metrics.score.toFixed(1) }}</span>\n          <span class=\"score-max\">/100</span>\n          <app-badge [variant]=\"getGradeVariant(metrics.grade)\" size=\"medium\" class=\"grade-badge\">\n            {{ metrics.grade }}\n          </app-badge>\n        </div>\n      </div>\n    </div>\n\n    <!-- Breakdown de métricas -->\n    <div class=\"metrics-breakdown\">\n      <h4 class=\"breakdown-title\">detailed breakdown</h4>\n      <div class=\"metrics-grid\">\n        <div class=\"metric-item\" *ngFor=\"let metric of getMetricEntries()\">\n          <div class=\"metric-header\">\n            <span class=\"metric-name\">{{ metric.name }}</span>\n            <span class=\"metric-score\">{{ metric.value.toFixed(1) }}%</span>\n          </div>\n          <div class=\"metric-bar\">\n            <div\n              class=\"metric-fill\"\n              [style.width.%]=\"metric.value\"\n              [class]=\"getMetricColor(metric.value)\"\n            ></div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Fortalezas y mejoras -->\n    <div class=\"feedback-section\">\n      <div class=\"strengths\">\n        <h4 class=\"feedback-title\">\n          <span class=\"icon-[iconoir--check] feedback-icon\"></span>\n          strengths\n        </h4>\n        <ul class=\"feedback-list\">\n          <li *ngFor=\"let strength of metrics.strengths\">{{ strength }}</li>\n        </ul>\n      </div>\n\n      <div class=\"improvements\">\n        <h4 class=\"feedback-title\">\n          <span class=\"icon-[iconoir--light-bulb] feedback-icon\"></span>\n          suggestions\n        </h4>\n        <ul class=\"feedback-list\">\n          <li *ngFor=\"let improvement of metrics.improvements\">{{ improvement }}</li>\n        </ul>\n      </div>\n    </div>\n  </div>\n</app-card>\n"
        },
        {
            "name": "PoemResultsComponent",
            "id": "component-PoemResultsComponent-a50df5006989955540050e2032e9c9b45ecaad2e05593e7a056003b75bef1400869e3465b20005e0743470369b2517bd2b5b60ee52432d74b7868c4075cffaf4",
            "file": "src/app/components/poem-results/poem-results.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-poem-results",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./poem-results.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "required": true,
                    "name": "result",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "optional": false,
                    "line": 17,
                    "type": "EnhancedPoetryResult",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "wordSelected",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 18,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "utils",
                    "defaultValue": "inject(UtilsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "getPosLabel",
                    "args": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 24,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onWordClick",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 20,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "BadgeComponent",
                    "type": "component"
                },
                {
                    "name": "StatusMessageComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter, inject } from '@angular/core';\nimport { CardComponent } from '../card/card.component';\nimport { BadgeComponent } from '../badge/badge.component';\nimport { StatusMessageComponent } from '../status-message/status-message.component';\nimport { EnhancedPoetryResult } from '../../services/poetry';\nimport { UtilsService } from '../../services/core/utils.service';\n\n@Component({\n  selector: 'app-poem-results',\n  standalone: true,\n  imports: [CardComponent, BadgeComponent, StatusMessageComponent],\n  templateUrl: './poem-results.component.html',\n})\nexport class PoemResultsComponent {\n  private readonly utils = inject(UtilsService);\n\n  @Input({ required: true }) result!: EnhancedPoetryResult;\n  @Output() wordSelected = new EventEmitter<string>();\n\n  onWordClick(word: string): void {\n    this.wordSelected.emit(word);\n  }\n\n  getPosLabel(pos: string): string {\n    return this.utils.getPosLabel(pos);\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card padding=\"large\">\n  <div class=\"results-container\">\n    <!-- Status Header -->\n    <app-status-message\n      [title]=\"result.ok ? 'perfect match' : 'pattern mismatch'\"\n      [message]=\"result.summary\"\n      [severity]=\"result.ok ? 'success' : 'warning'\"\n    />\n\n    <!-- Detected Patterns Section -->\n    @if (result.detectedPatterns && result.detectedPatterns.length > 0) {\n    <div class=\"patterns-section\">\n      <h3 class=\"section-title\">detected patterns</h3>\n      <div class=\"patterns-list\">\n        @for (pattern of result.detectedPatterns; track $index) {\n        <div class=\"pattern-item\">\n          <span class=\"icon-[iconoir--sparks] pattern-icon\"></span>\n          <span class=\"pattern-text\">{{ pattern }}</span>\n        </div>\n        }\n      </div>\n    </div>\n    }\n\n    <!-- Alliteration Section -->\n    @if (result.overallAlliterations && result.overallAlliterations.length > 0) {\n    <div class=\"alliteration-section\">\n      <h3 class=\"section-title\">alliterations detected</h3>\n      <div class=\"alliteration-list\">\n        @for (alliteration of result.overallAlliterations; track $index) {\n        <div class=\"alliteration-item\">\n          <app-badge variant=\"info\" size=\"small\" icon=\"icon-[iconoir--sound-high]\">\n            {{ alliteration.sound }}\n          </app-badge>\n          <span class=\"alliteration-words\">\n            {{ alliteration.words.join(' • ') }}\n          </span>\n        </div>\n        }\n      </div>\n    </div>\n    }\n\n    <!-- Line Analysis -->\n    <div class=\"line-analysis-section\">\n      <h3 class=\"section-title\">line-by-line analysis</h3>\n\n      <div class=\"lines-container\">\n        @for (line of result.lines; track $index) {\n        <div class=\"line-card\">\n          <!-- Line Header -->\n          <div class=\"line-header\">\n            <span class=\"line-number\"> line {{ $index + 1 }} </span>\n            <app-badge\n              [variant]=\"line.match ? 'success' : 'error'\"\n              size=\"small\"\n              [icon]=\"line.match ? 'icon-[iconoir--check]' : 'icon-[iconoir--cancel]'\"\n            >\n              {{ line.count }}/{{ line.expected }} syllables\n            </app-badge>\n          </div>\n\n          <!-- Line Text with Clickable Words -->\n          <p class=\"line-text\">\n            @for (word of line.words; track $index) {\n            <span\n              class=\"word-token\"\n              [class.word-clickable]=\"!line.match\"\n              [attr.role]=\"!line.match ? 'button' : null\"\n              [attr.tabindex]=\"!line.match ? 0 : null\"\n              (click)=\"!line.match && onWordClick(word.word)\"\n              (keyup.enter)=\"!line.match && onWordClick(word.word)\"\n              (keyup.space)=\"!line.match && onWordClick(word.word)\"\n              [title]=\"getPosLabel(word.pos) + ' • ' + word.syllables + ' syllable(s)'\"\n            >\n              {{ word.word }}\n            </span>\n            }\n          </p>\n\n          <!-- Alliterations in Line -->\n          @if (line.alliterations && line.alliterations.length > 0) {\n          <div class=\"line-alliterations\">\n            @for (alliteration of line.alliterations; track $index) {\n            <app-badge variant=\"info\" size=\"small\" icon=\"icon-[iconoir--sound-high]\">\n              alliteration: {{ alliteration.words.join(', ') }}\n            </app-badge>\n            }\n          </div>\n          }\n\n          <!-- Syllable Breakdown -->\n          @if (line.syllables && line.syllables.length > 0) {\n          <div class=\"syllable-breakdown\">\n            <span class=\"breakdown-label\">syllables:</span>\n            <div class=\"syllable-chips\">\n              @for (syllable of line.syllables; track $index) {\n              <span class=\"syllable-chip\">{{ syllable }}</span>\n              }\n            </div>\n          </div>\n          }\n\n          <!-- Stress Pattern -->\n          @if (line.stresses) {\n          <div class=\"stress-pattern\">\n            <span class=\"breakdown-label\">stress:</span>\n            <span class=\"stress-value\">{{ line.stresses }}</span>\n          </div>\n          }\n\n          <!-- Word Details -->\n          <details class=\"word-details\">\n            <summary class=\"word-details-summary\">view word analysis</summary>\n            <div class=\"word-details-content\">\n              @for (word of line.words; track $index) {\n              <div class=\"word-detail-item\">\n                <span class=\"word-detail-word\">{{ word.word }}</span>\n                <div class=\"word-detail-meta\">\n                  <span class=\"word-detail-syllables\">\n                    {{ word.syllables }} syllable{{ word.syllables !== 1 ? 's' : '' }}\n                  </span>\n                  <span class=\"word-detail-pos\">{{ getPosLabel(word.pos) }}</span>\n                  @if (word.phones) {\n                  <span class=\"word-detail-phones\">{{ word.phones }}</span>\n                  }\n                </div>\n              </div>\n              }\n            </div>\n          </details>\n        </div>\n        }\n      </div>\n    </div>\n\n    <!-- Rhyme Scheme -->\n    @if (result.rhymeScheme) {\n    <div class=\"rhyme-section\">\n      <h4 class=\"section-title\">rhyme scheme</h4>\n      <div class=\"rhyme-scheme\">\n        <span class=\"rhyme-value\">{{ result.rhymeScheme }}</span>\n      </div>\n    </div>\n    }\n\n    <!-- Suggestions -->\n    @if (result.suggestions && result.suggestions.length > 0) {\n    <div class=\"suggestions-section\">\n      <h4 class=\"section-title\">suggestions for improvement</h4>\n      <ul class=\"suggestions-list\">\n        @for (suggestion of result.suggestions; track $index) {\n        <li class=\"suggestion-item\">\n          <span class=\"icon-[iconoir--light-bulb] suggestion-icon\"></span>\n          <span>{{ suggestion }}</span>\n        </li>\n        }\n      </ul>\n    </div>\n    }\n  </div>\n</app-card>"
        },
        {
            "name": "PoetryPageComponent",
            "id": "component-PoetryPageComponent-16461c5d05d2a4dcd0e8777a450accaf3583557eadfa5f779d736406b7042e395e7878ce0c840b40c6f8880e3214457bc19da6ef6929223a414e7217dc9726cf",
            "file": "src/app/components/poetry-page/poetry-page.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-poetry-page",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./poetry-page.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "analysisTabs",
                    "defaultValue": "signal<Tab[]>([\n    { id: 'structure', label: 'structure', icon: 'icon-[iconoir--layout-left]' },\n    { id: 'rhythm', label: 'rhythm', icon: 'icon-[iconoir--music-double]' },\n    { id: 'quality', label: 'quality', icon: 'icon-[iconoir--star]' },\n    { id: 'stats', label: 'stats', icon: 'icon-[iconoir--dashboard]' },\n  ])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 41,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "analyzer",
                    "defaultValue": "inject(PoetryAnalyzerService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 38,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "selectedAnalysisTab",
                    "defaultValue": "signal('structure')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 40,
                    "modifierKind": [
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "fallbackCopyToClipboard",
                    "args": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 82,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "text",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getQuickStats",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 105,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onAnalysisTabChange",
                    "args": [
                        {
                            "name": "tabId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 48,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "tabId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onAssessQuality",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 96,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onCloseSuggestions",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 60,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onExportPoem",
                    "args": [],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 64,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        134
                    ]
                },
                {
                    "name": "onReplaceWord",
                    "args": [
                        {
                            "name": "newWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 56,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "newWord",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onShowMeterAnalysis",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 101,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onWordSelected",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 52,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CommonModule",
                    "type": "module"
                },
                {
                    "name": "BadgeComponent",
                    "type": "component"
                },
                {
                    "name": "ButtonComponent",
                    "type": "component"
                },
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "HeaderComponent",
                    "type": "component"
                },
                {
                    "name": "FooterComponent",
                    "type": "component"
                },
                {
                    "name": "PoemEditorComponent",
                    "type": "component"
                },
                {
                    "name": "PoemResultsComponent",
                    "type": "component"
                },
                {
                    "name": "PoemQualityComponent",
                    "type": "component"
                },
                {
                    "name": "WordSuggestionsComponent",
                    "type": "component"
                },
                {
                    "name": "QuickStatsPanelComponent",
                    "type": "component"
                },
                {
                    "name": "MeterAnalysisSectionComponent",
                    "type": "component"
                },
                {
                    "name": "TabsComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { CommonModule } from '@angular/common';\nimport { Component, inject, signal } from '@angular/core';\nimport { BadgeComponent } from '../badge/badge.component';\nimport { ButtonComponent } from '../button/button.component';\nimport { CardComponent } from '../card/card.component';\nimport { HeaderComponent } from '../header/header.component';\nimport { FooterComponent } from '../footer/footer.component';\nimport { PoemEditorComponent } from '../poem-editor/poem-editor.component';\nimport { PoemResultsComponent } from '../poem-results/poem-results.component';\nimport { PoemQualityComponent } from '../poem-quality/poem-quality.component';\nimport { WordSuggestionsComponent } from '../word-suggestions/word-suggestions.component';\nimport { QuickStatsPanelComponent } from '../quick-stats-panel/quick-stats-panel.component';\nimport { MeterAnalysisSectionComponent } from '../meter-analysis-section/meter-analysis-section.component';\nimport { TabsComponent, Tab } from '../tabs/tabs.component';\nimport { PoetryAnalyzerService } from '../../services/poetry';\n\n@Component({\n  selector: 'app-poetry-page',\n  standalone: true,\n  imports: [\n    CommonModule,\n    BadgeComponent,\n    ButtonComponent,\n    CardComponent,\n    HeaderComponent,\n    FooterComponent,\n    PoemEditorComponent,\n    PoemResultsComponent,\n    PoemQualityComponent,\n    WordSuggestionsComponent,\n    QuickStatsPanelComponent,\n    MeterAnalysisSectionComponent,\n    TabsComponent,\n  ],\n  templateUrl: './poetry-page.component.html',\n})\nexport class PoetryPageComponent {\n  readonly analyzer = inject(PoetryAnalyzerService);\n\n  readonly selectedAnalysisTab = signal('structure');\n  readonly analysisTabs = signal<Tab[]>([\n    { id: 'structure', label: 'structure', icon: 'icon-[iconoir--layout-left]' },\n    { id: 'rhythm', label: 'rhythm', icon: 'icon-[iconoir--music-double]' },\n    { id: 'quality', label: 'quality', icon: 'icon-[iconoir--star]' },\n    { id: 'stats', label: 'stats', icon: 'icon-[iconoir--dashboard]' },\n  ]);\n\n  onAnalysisTabChange(tabId: string): void {\n    this.selectedAnalysisTab.set(tabId);\n  }\n\n  onWordSelected(word: string): void {\n    this.analyzer.selectWordEnhanced(word);\n  }\n\n  onReplaceWord(newWord: string): void {\n    this.analyzer.replaceWord(this.analyzer.wordAlternatives()?.original || '', newWord);\n  }\n\n  onCloseSuggestions(): void {\n    this.analyzer.selectWordEnhanced(null);\n  }\n\n  async onExportPoem(): Promise<void> {\n    const result = this.analyzer.result();\n    if (!result) return;\n\n    const poemText = result.lines.map((line) => line.text).join('\\n');\n    const formInfo = this.analyzer.selectedForm();\n\n    const exportText = `${formInfo.toUpperCase()} POEM\\n\\n${poemText}\\n\\n— Created with HarawiHark`;\n\n    try {\n      await navigator.clipboard.writeText(exportText);\n      console.log('Poem copied to clipboard');\n    } catch (error) {\n      console.error('Failed to copy poem to clipboard:', error);\n      this.fallbackCopyToClipboard(exportText);\n    }\n  }\n\n  private fallbackCopyToClipboard(text: string): void {\n    const textArea = document.createElement('textarea');\n    textArea.value = text;\n    document.body.appendChild(textArea);\n    textArea.select();\n    try {\n      document.execCommand('copy');\n      console.log('Poem copied to clipboard (fallback)');\n    } catch (error) {\n      console.error('Fallback copy failed:', error);\n    }\n    document.body.removeChild(textArea);\n  }\n\n  onAssessQuality(): void {\n    this.analyzer.assessQuality();\n    this.selectedAnalysisTab.set('quality');\n  }\n\n  onShowMeterAnalysis(): void {\n    this.selectedAnalysisTab.set('rhythm');\n  }\n\n  getQuickStats() {\n    const stats = this.analyzer.getQuickStats();\n    return {\n      ...stats,\n      patternMatch: this.analyzer.isCompletePoem() ? 'Perfect' : 'Partial',\n    };\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<article class=\"page-container\">\n  <app-header />\n\n  <section class=\"page-content\">\n    <!-- Hero Section -->\n    <div class=\"hero-section\">\n      <div class=\"hero-icon-container\">\n        <span class=\"icon-[iconoir--flower] hero-icon\"></span>\n        <h1 class=\"hero-title\">harawihark</h1>\n      </div>\n      <p class=\"hero-subtitle\">advanced syllable-meter checker with phonetic analysis</p>\n    </div>\n\n    <!-- Editor Section -->\n    <div class=\"editor-section\">\n      <app-poem-editor />\n    </div>\n\n    <!-- Word Suggestions Section -->\n    @if (analyzer.wordAlternatives(); as alternatives) {\n    <div class=\"suggestions-section\">\n      <app-word-suggestions [data]=\"alternatives\" (replaceWord)=\"onReplaceWord($event)\"\n        (closeSuggestions)=\"onCloseSuggestions()\" />\n    </div>\n    }\n\n    <!-- Main Results Section -->\n    @if (analyzer.result(); as result) {\n    <div class=\"results-section\">\n      <app-tabs [tabs]=\"analysisTabs()\" [selectedTab]=\"selectedAnalysisTab()\"\n        (tabChange)=\"onAnalysisTabChange($event)\" />\n\n      @switch (selectedAnalysisTab()) { @case ('structure') {\n      <app-poem-results [result]=\"result\" (wordSelected)=\"onWordSelected($event)\" />\n      } @case ('rhythm') {\n      <app-meter-analysis-section [result]=\"result\" />\n      } @case ('quality') { @if (analyzer.qualityMetrics()) {\n      <app-poem-quality [metrics]=\"analyzer.qualityMetrics()!\" />\n      } @else {\n      <app-card padding=\"large\">\n        <div class=\"text-center py-8\">\n          <p class=\"text-onSurfaceVariant\">Click \"Assess Quality\" to see quality metrics</p>\n        </div>\n      </app-card>\n      } } @case ('stats') {\n      <app-quick-stats-panel [stats]=\"getQuickStats()\" />\n      } }\n\n      <!-- Botones de análisis manteniendo la funcionalidad existente -->\n      <div class=\"analysis-actions\">\n        <div class=\"actions-row\">\n          <app-button variant=\"primary\" size=\"medium\" label=\"assess quality\" icon=\"icon-[iconoir--star]\"\n            (clicked)=\"onAssessQuality()\" />\n\n          <app-button variant=\"outline\" size=\"medium\" label=\"analyze rhythm\" icon=\"icon-[iconoir--music-double]\"\n            (clicked)=\"onShowMeterAnalysis()\" />\n\n          <app-button variant=\"outline\" size=\"medium\" label=\"export poem\" icon=\"icon-[iconoir--cloud-download]\"\n            (clicked)=\"onExportPoem()\" />\n        </div>\n      </div>\n    </div>\n    } @else {\n    <!-- Empty State -->\n    <div class=\"empty-state-section\">\n      <app-card padding=\"large\">\n        <div class=\"empty-content\">\n          <span class=\"icon-[iconoir--flower] empty-icon\"></span>\n          <h3 class=\"empty-title\">ready to analyze</h3>\n          <p class=\"empty-description\">\n            Write your poem or load an example to see syllable analysis and suggestions\n          </p>\n        </div>\n      </app-card>\n    </div>\n    }\n\n    <!-- Info Section -->\n    <div class=\"info-section\">\n      <div class=\"info-content\">\n        <span class=\"icon-[iconoir--light-bulb] info-icon\"></span>\n        <div class=\"info-text\">\n          <h4 class=\"info-title\">how it works</h4>\n          <p class=\"info-description\">\n            Harawihark uses advanced phonetic analysis to count syllables accurately, detect rhyme\n            schemes, and provide intelligent suggestions for improving your poetry.\n          </p>\n          <ul class=\"info-features\">\n            <li>\n              <span class=\"icon-[iconoir--sound-high] feature-icon\"></span>\n              Real-time syllable counting with RiTa.js\n            </li>\n            <li>\n              <span class=\"icon-[iconoir--music-double] feature-icon\"></span>\n              Advanced meter analysis (iambic, trochaic, etc.)\n            </li>\n            <li>\n              <span class=\"icon-[iconoir--star] feature-icon\"></span>\n              Quality assessment with detailed metrics\n            </li>\n            <li>\n              <span class=\"icon-[iconoir--book-stack] feature-icon\"></span>\n              8 different poetic forms supported\n            </li>\n          </ul>\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <app-footer />\n</article>"
        },
        {
            "name": "QuickStatsPanelComponent",
            "id": "component-QuickStatsPanelComponent-adb9d00591ba62e85d96b36572bd9ee90487f799978398ea24a1c5c2540d976ad34f768888ebd52f01e34b9dda05e6936e6bcc7182796135f68827978d87ef23",
            "file": "src/app/components/quick-stats-panel/quick-stats-panel.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-quick-stats-panel",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./quick-stats-panel.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "required": true,
                    "name": "stats",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "optional": false,
                    "line": 19,
                    "type": "QuickStats",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "BadgeComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\nimport { CardComponent } from '../card/card.component';\nimport { BadgeComponent } from '../badge/badge.component';\n\nexport interface QuickStats {\n  totalSyllables: number;\n  avgSyllablesPerLine: number;\n  vocabularyRichness: number;\n  patternMatch: string;\n}\n\n@Component({\n  selector: 'app-quick-stats-panel',\n  standalone: true,\n  imports: [CardComponent, BadgeComponent],\n  templateUrl: './quick-stats-panel.component.html',\n})\nexport class QuickStatsPanelComponent {\n  @Input({ required: true }) stats!: QuickStats;\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card padding=\"medium\">\n  <div class=\"stats-container\">\n    <h3 class=\"stats-title\">quick stats</h3>\n    \n    <div class=\"stats-grid\">\n      <div class=\"stat-item\">\n        <div class=\"stat-icon\">\n          <span class=\"icon-[iconoir--sound-high]\"></span>\n        </div>\n        <div class=\"stat-content\">\n          <span class=\"stat-value\">{{ stats.totalSyllables }}</span>\n          <span class=\"stat-label\">total syllables</span>\n        </div>\n      </div>\n      \n      <div class=\"stat-item\">\n        <div class=\"stat-icon\">\n          <span class=\"icon-[iconoir--layout-left]\"></span>\n        </div>\n        <div class=\"stat-content\">\n          <span class=\"stat-value\">{{ stats.avgSyllablesPerLine }}</span>\n          <span class=\"stat-label\">avg per line</span>\n        </div>\n      </div>\n      \n      <div class=\"stat-item\">\n        <div class=\"stat-icon\">\n          <span class=\"icon-[iconoir--book-stack]\"></span>\n        </div>\n        <div class=\"stat-content\">\n          <span class=\"stat-value\">{{ stats.vocabularyRichness }}%</span>\n          <span class=\"stat-label\">vocabulary richness</span>\n        </div>\n      </div>\n      \n      <div class=\"stat-item\">\n        <div class=\"stat-icon\">\n          <span class=\"icon-[iconoir--check]\"></span>\n        </div>\n        <div class=\"stat-content\">\n          <span class=\"stat-value\">{{ stats.patternMatch }}</span>\n          <span class=\"stat-label\">pattern match</span>\n        </div>\n      </div>\n    </div>\n  </div>\n</app-card>"
        },
        {
            "name": "SelectComponent",
            "id": "component-SelectComponent-3d3b3a668c59b4c80e2beae9f494be39347e4d0b0c447b11b5aa7a9376f4e3b82c1289dffb65c84d1a0aa2f0974374d1df99eeaabcb1fbf2257e6342344964ef",
            "file": "src/app/components/select/select.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [
                {
                    "name": ")"
                }
            ],
            "selector": "app-select",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./select.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "disabled",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 25,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "id",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 26,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "label",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 24,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "options",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 23,
                    "type": "SelectOption[]",
                    "decorators": []
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 29,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "selectChange",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 39,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "_value",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 37
                },
                {
                    "name": "onChange",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 41,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "onTouched",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 44,
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "onBlur",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 71,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onSelectChange",
                    "args": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 64,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnChange",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "string",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ]
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 52,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [
                                {
                                    "name": "value",
                                    "type": "string",
                                    "deprecated": false,
                                    "deprecationMessage": ""
                                }
                            ],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnTouched",
                    "args": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": []
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 56,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "function",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "function": [],
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setDisabledState",
                    "args": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 60,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "writeValue",
                    "args": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 48,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter, forwardRef } from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\n\nexport interface SelectOption {\n  value: string;\n  label: string;\n  description?: string;\n}\n\n@Component({\n  selector: 'app-select',\n  standalone: true,\n  templateUrl: './select.component.html',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => SelectComponent),\n      multi: true,\n    },\n  ],\n})\nexport class SelectComponent implements ControlValueAccessor {\n  @Input() options: SelectOption[] = [];\n  @Input() label = '';\n  @Input() disabled = false;\n  @Input() id = '';\n\n  @Input()\n  get value(): string {\n    return this._value;\n  }\n  set value(val: string) {\n    this._value = val || '';\n    this.onChange(this._value);\n  }\n\n  _value = '';\n\n  @Output() selectChange = new EventEmitter<string>();\n\n  private onChange: (value: string) => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n  private onTouched: () => void = () => {\n    // Placeholder for ControlValueAccessor\n  };\n\n  writeValue(value: string): void {\n    this._value = value || '';\n  }\n\n  registerOnChange(fn: (value: string) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  onSelectChange(event: Event): void {\n    const target = event.target as HTMLSelectElement;\n    this._value = target.value;\n    this.onChange(this._value);\n    this.selectChange.emit(this._value);\n  }\n\n  onBlur(): void {\n    this.onTouched();\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "implements": [
                "ControlValueAccessor"
            ],
            "accessors": {
                "value": {
                    "name": "value",
                    "setSignature": {
                        "name": "value",
                        "type": "void",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "args": [
                            {
                                "name": "val",
                                "type": "string",
                                "deprecated": false,
                                "deprecationMessage": ""
                            }
                        ],
                        "returnType": "void",
                        "line": 32,
                        "jsdoctags": [
                            {
                                "name": "val",
                                "type": "string",
                                "deprecated": false,
                                "deprecationMessage": "",
                                "tagName": {
                                    "text": "param"
                                }
                            }
                        ]
                    },
                    "getSignature": {
                        "name": "value",
                        "type": "string",
                        "returnType": "string",
                        "line": 29
                    }
                }
            },
            "templateData": "<div class=\"select-wrapper\">\n  @if (label) {\n    <label class=\"select-label\" [for]=\"id\">{{ label }}</label>\n  }\n\n  <select\n    class=\"select-base\"\n    [id]=\"id\"\n    [disabled]=\"disabled\"\n    [value]=\"_value\"\n    (change)=\"onSelectChange($event)\"\n    (blur)=\"onBlur()\"\n  >\n    <option value=\"\" disabled>select an option</option>\n    @for (option of options; track option.value) {\n      <option [value]=\"option.value\">\n        {{ option.label }}\n        @if (option.description) {\n          - {{ option.description }}\n        }\n      </option>\n    }\n  </select>\n\n  <span class=\"icon-[iconoir--nav-arrow-down] select-icon\"></span>\n</div>\n"
        },
        {
            "name": "StatusMessageComponent",
            "id": "component-StatusMessageComponent-c8867b15fb72f362856e811071a6d5305341f272e4e8be4e7be7d41541a7c490d223eb1cebcb4f2382a911c73208b8953238927e8c1ba622a993138a3eec8618",
            "file": "src/app/components/status-message/status-message.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-status-message",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./status-message.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "actionLabel",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 14,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "message",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 12,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "severity",
                    "defaultValue": "'info'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 13,
                    "type": "\"info\" | \"warning\" | \"error\" | \"success\"",
                    "decorators": []
                },
                {
                    "name": "title",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 11,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "action",
                    "defaultValue": "new EventEmitter<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 15,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "ButtonComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { ButtonComponent } from '../button/button.component';\n\n@Component({\n  selector: 'app-status-message',\n  standalone: true,\n  imports: [ButtonComponent],\n  templateUrl: './status-message.component.html',\n})\nexport class StatusMessageComponent {\n  @Input() title = '';\n  @Input() message = '';\n  @Input() severity: 'info' | 'warning' | 'error' | 'success' = 'info';\n  @Input() actionLabel?: string;\n  @Output() action = new EventEmitter<void>();\n\n  get iconClass(): string {\n    const icons = {\n      info: 'icon-[iconoir--info-circle]',\n      warning: 'icon-[iconoir--warning-triangle]',\n      error: 'icon-[iconoir--cancel]',\n      success: 'icon-[iconoir--check]',\n    };\n    return icons[this.severity];\n  }\n\n  get containerClasses(): string {\n    return `status-message status-${this.severity}`;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "accessors": {
                "iconClass": {
                    "name": "iconClass",
                    "getSignature": {
                        "name": "iconClass",
                        "type": "string",
                        "returnType": "string",
                        "line": 17
                    }
                },
                "containerClasses": {
                    "name": "containerClasses",
                    "getSignature": {
                        "name": "containerClasses",
                        "type": "string",
                        "returnType": "string",
                        "line": 27
                    }
                }
            },
            "templateData": "<div [class]=\"containerClasses\">\n  <span [class]=\"iconClass + ' status-icon'\"></span>\n  <div class=\"status-content\">\n    <h4 class=\"status-title\">{{ title }}</h4>\n    <p class=\"status-message-text\">{{ message }}</p>\n  </div>\n  @if (actionLabel) {\n    <app-button\n      variant=\"outline\"\n      size=\"small\"\n      (clicked)=\"action.emit()\"\n      [label]=\"actionLabel\"\n    />\n  }\n</div>"
        },
        {
            "name": "TabsComponent",
            "id": "component-TabsComponent-192ae07a5674905f61ca8210aa66bbe833e06114770fb1716f27a820eee787d134e3ee4c181c46e308c196513dffe79f1b27bfdb3e920a818479dea83fd3eb79",
            "file": "src/app/components/tabs/tabs.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-tabs",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./tabs.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "selectedTab",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 17,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "tabs",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 16,
                    "type": "Tab[]",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "tabChange",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 18,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "selectTab",
                    "args": [
                        {
                            "name": "tabId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 20,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "tabId",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\n\nexport interface Tab {\n  id: string;\n  label: string;\n  icon?: string;\n  disabled?: boolean;\n}\n\n@Component({\n  selector: 'app-tabs',\n  standalone: true,\n  templateUrl: './tabs.component.html',\n})\nexport class TabsComponent {\n  @Input() tabs: Tab[] = [];\n  @Input() selectedTab = '';\n  @Output() tabChange = new EventEmitter<string>();\n\n  selectTab(tabId: string): void {\n    if (this.selectedTab !== tabId) {\n      this.selectedTab = tabId;\n      this.tabChange.emit(tabId);\n    }\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<!-- tabs.component.html -->\n<nav class=\"metro-tabs\" role=\"tablist\">\n  @for (tab of tabs; track tab.id) {\n    <button\n      type=\"button\"\n      role=\"tab\"\n      [class]=\"['metro-tab', { 'metro-tab-active': selectedTab === tab.id }]\"\n      [disabled]=\"tab.disabled\"\n      (click)=\"selectTab(tab.id)\"\n    >\n      @if (tab.icon) {\n        <span [class]=\"tab.icon + ' metro-tab-icon'\"></span>\n      }\n      <span class=\"metro-tab-label\">{{ tab.label }}</span>\n    </button>\n  }\n</nav>"
        },
        {
            "name": "ThemeToggleComponent",
            "id": "component-ThemeToggleComponent-aafed5dfe050566eeca5b938a79533dc90a7b837f66fab553c21dcde794cb628caf5fe9c643b29b5011d2ac623df203bc75d21ac5face7cb60293df369187946",
            "file": "src/app/components/theme-toggle/theme-toggle.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-theme-toggle",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./theme-toggle.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "currentTheme",
                    "defaultValue": "this.themeService.currentTheme",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 12,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "themeService",
                    "defaultValue": "inject(ThemeService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 10,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "toggleTheme",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 14,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, inject } from '@angular/core';\nimport { ThemeService } from '../../services/core/theme.service';\n\n@Component({\n  selector: 'app-theme-toggle',\n  standalone: true,\n  templateUrl: './theme-toggle.component.html',\n})\nexport class ThemeToggleComponent {\n  private readonly themeService = inject(ThemeService);\n\n  protected readonly currentTheme = this.themeService.currentTheme;\n\n  toggleTheme(): void {\n    this.themeService.toggleTheme();\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<button\n  type=\"button\"\n  class=\"theme-toggle\"\n  (click)=\"toggleTheme()\"\n  [attr.aria-label]=\"'Switch to ' + (currentTheme() === 'light' ? 'dark' : 'light') + ' theme'\"\n>\n  @if (currentTheme() === 'light') {\n    <span class=\"icon-[iconoir--sun-light] text-xl\"></span>\n  } @else {\n    <span class=\"icon-[iconoir--moon-sat] text-xl\"></span>\n  }\n</button>"
        },
        {
            "name": "TooltipComponent",
            "id": "component-TooltipComponent-592c1dbb983d59c443eec14b1ca96e74c56c798f0b264a481c137734bb7f0f06d4735f9ed940cbd49f7ad6678d2ba42f2243ba137c2dce9651f5e0656e08db07",
            "file": "src/app/components/tooltip/tooltip.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-tooltip",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./tooltip.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "position",
                    "defaultValue": "'top'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 10,
                    "type": "\"top\" | \"bottom\" | \"left\" | \"right\"",
                    "decorators": []
                },
                {
                    "name": "text",
                    "defaultValue": "''",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 9,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-tooltip',\n  standalone: true,\n  templateUrl: './tooltip.component.html',\n})\nexport class TooltipComponent {\n  @Input() text = '';\n  @Input() position: 'top' | 'bottom' | 'left' | 'right' = 'top';\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<div class=\"metro-tooltip\" [class]=\"'tooltip-' + position\">\n  <ng-content />\n  <div class=\"tooltip-content\">\n    {{ text }}\n  </div>\n</div>"
        },
        {
            "name": "WordSuggestionsComponent",
            "id": "component-WordSuggestionsComponent-cb5dd51b3901ccfb6e8f596a40f1b5716022e024a90062b44cedd2e61de52de8cca89a46172e15f6436244e829e76ea5d28c3bbe250870bfa01fbc6e7995baa3",
            "file": "src/app/components/word-suggestions/word-suggestions.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-word-suggestions",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./word-suggestions.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "required": true,
                    "name": "data",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "optional": false,
                    "line": 17,
                    "type": "WordSuggestionData",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "closeSuggestions",
                    "defaultValue": "new EventEmitter<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 19,
                    "type": "EventEmitter"
                },
                {
                    "name": "replaceWord",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 18,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "utils",
                    "defaultValue": "inject(UtilsService)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15,
                    "modifierKind": [
                        123,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "getPosLabel",
                    "args": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 39,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "pos",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getReasonLabel",
                    "args": [
                        {
                            "name": "reason",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 21,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "reason",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getReasonVariant",
                    "args": [
                        {
                            "name": "reason",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "\"success\" | \"info\" | \"default\"",
                    "typeParameters": [],
                    "line": 33,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "reason",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onReplaceWord",
                    "args": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 43,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "word",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "CardComponent",
                    "type": "component"
                },
                {
                    "name": "BadgeComponent",
                    "type": "component"
                },
                {
                    "name": "ButtonComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter, inject } from '@angular/core';\nimport { CardComponent } from '../card/card.component';\nimport { BadgeComponent } from '../badge/badge.component';\nimport { ButtonComponent } from '../button/button.component';\nimport { UtilsService } from '../../services/core/utils.service';\nimport { WordSuggestionData } from '../../services/poetry';\n\n@Component({\n  selector: 'app-word-suggestions',\n  standalone: true,\n  imports: [CardComponent, BadgeComponent, ButtonComponent],\n  templateUrl: './word-suggestions.component.html',\n})\nexport class WordSuggestionsComponent {\n  private readonly utils = inject(UtilsService);\n\n  @Input({ required: true }) data!: WordSuggestionData;\n  @Output() replaceWord = new EventEmitter<string>();\n  @Output() closeSuggestions = new EventEmitter<void>();\n\n  getReasonLabel(reason: string): string {\n    const labels: Record<string, string> = {\n      'exact-match': 'exact syllables',\n      'rhyme-match': 'rhymes with original',\n      'sound-match': 'similar sound',\n      'semantic-rhyme': 'semantic rhyme',\n      'spelling-match': 'spelling match',\n      morphological: 'morphological variant',\n    };\n    return labels[reason] || reason;\n  }\n\n  getReasonVariant(reason: string): 'success' | 'info' | 'default' {\n    if (reason === 'exact-match') return 'success';\n    if (reason === 'rhyme-match' || reason === 'semantic-rhyme') return 'info';\n    return 'default';\n  }\n\n  getPosLabel(pos: string): string {\n    return this.utils.getPosLabel(pos);\n  }\n\n  onReplaceWord(word: string): void {\n    this.replaceWord.emit(word);\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "extends": [],
            "templateData": "<app-card padding=\"large\">\n  <div class=\"suggestions-container\">\n    <!-- Header -->\n    <div class=\"suggestions-header\">\n      <div>\n        <h3 class=\"suggestions-title\">suggestions for \"{{ data.original }}\"</h3>\n        <p class=\"suggestions-subtitle\">\n          needs {{ data.targetSyllables }} syllable{{ data.targetSyllables !== 1 ? 's' : '' }}\n          (currently {{ data.currentSyllables }})\n        </p>\n      </div>\n      <button\n        type=\"button\"\n        class=\"close-button\"\n        (click)=\"closeSuggestions.emit()\"\n        aria-label=\"Close suggestions\"\n      >\n        <span class=\"icon-[iconoir--cancel] close-icon\"></span>\n      </button>\n    </div>\n\n    <!-- Alternatives List -->\n    @if (data.alternatives.length > 0) {\n      <div class=\"alternatives-list\">\n        @for (alt of data.alternatives; track alt.word) {\n          <div class=\"alternative-item\">\n            <div class=\"alternative-content\">\n              <div class=\"alternative-main\">\n                <span class=\"alternative-word\">{{ alt.word }}</span>\n                <app-badge\n                  [variant]=\"getReasonVariant(alt.reason)\"\n                  size=\"small\"\n                >\n                  {{ getReasonLabel(alt.reason) }}\n                </app-badge>\n              </div>\n              <div class=\"alternative-meta\">\n                <span class=\"syllable-count\">\n                  <span class=\"icon-[iconoir--sound-high] syllable-icon\"></span>\n                  {{ alt.syllables }} syllable{{ alt.syllables !== 1 ? 's' : '' }}\n                </span>\n                @if (alt.pos) {\n                  <span class=\"pos-tag\">{{ getPosLabel(alt.pos) }}</span>\n                }\n              </div>\n            </div>\n            <app-button\n              variant=\"outline\"\n              size=\"small\"\n              label=\"use\"\n              icon=\"icon-[iconoir--check]\"\n              (clicked)=\"onReplaceWord(alt.word)\"\n            />\n          </div>\n        }\n      </div>\n    } @else {\n      <div class=\"no-alternatives\">\n        <span class=\"icon-[iconoir--search] no-alternatives-icon\"></span>\n        <p class=\"no-alternatives-text\">\n          No alternatives found with {{ data.targetSyllables }} syllables\n        </p>\n      </div>\n    }\n  </div>\n</app-card>"
        }
    ],
    "modules": [],
    "miscellaneous": {
        "variables": [
            {
                "name": "ALL_CSS_VARS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "[]",
                "defaultValue": "[...THEME_CSS_VARS, ...TERMINAL_CSS_VARS]"
            },
            {
                "name": "appConfig",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/app.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "ApplicationConfig",
                "defaultValue": "{\n  providers: [\n    provideBrowserGlobalErrorListeners(),\n    provideZoneChangeDetection({ eventCoalescing: true }),\n    provideRouter(routes),\n  ],\n}"
            },
            {
                "name": "outputDir",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/cli.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "string",
                "defaultValue": "'src/styles'"
            },
            {
                "name": "POETRY_EXAMPLES",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/data/poetry-forms.data.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Record<string, string[]>",
                "defaultValue": "{\n  haiku: ['an old silent pond', 'a frog jumps into the pond', 'splash! silence again'],\n  tanka: [\n    'the falling flower',\n    'i saw drift back to the branch',\n    'was a butterfly',\n    'dancing in the gentle breeze',\n    \"nature's art in motion\",\n  ],\n  cinquain: [\n    'moon',\n    'silent light',\n    'casting silver shadows',\n    'illuminating the dark night',\n    'peace',\n  ],\n  limerick: [\n    'there once was a coder so bright',\n    'who worked on his app every night',\n    'with angular and code',\n    'he built a fine node',\n    \"and launched it to everyone's delight\",\n  ],\n  redondilla: [\n    'in fields of green and gold so bright',\n    'where flowers dance in morning light',\n    'the world awakens from the night',\n    'and fills my heart with pure delight',\n  ],\n  lanterne: ['moon', 'bright glow', 'silver light', 'shining through night', 'peace'],\n  diamante: [\n    'day',\n    'bright warm',\n    'shining glowing heating',\n    'sunrise sunset twilight darkness',\n    'cooling dimming fading',\n    'cold dark',\n    'night',\n  ],\n  fibonacci: ['I', 'am', 'writing', 'syllables', 'in fibonacci', 'a mathematical poetry sequence'],\n}"
            },
            {
                "name": "POETRY_FORM_OPTIONS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/data/poetry-forms.data.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "Object.values(POETRY_FORMS).map((form) => ({\n  value: form.id,\n  label: form.name,\n  description: form.pattern.join('-'),\n}))"
            },
            {
                "name": "POETRY_FORMS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/data/poetry-forms.data.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Record<string, PoetryForm>",
                "defaultValue": "{\n  haiku: {\n    id: 'haiku',\n    name: 'haiku',\n    pattern: [5, 7, 5],\n    lines: 3,\n    origin: 'japanese',\n    description: 'traditional nature poem with 3 lines',\n  },\n  tanka: {\n    id: 'tanka',\n    name: 'tanka',\n    pattern: [5, 7, 5, 7, 7],\n    lines: 5,\n    origin: 'japanese',\n    description: 'extended court poetry with 5 lines',\n  },\n  cinquain: {\n    id: 'cinquain',\n    name: 'cinquain',\n    pattern: [2, 4, 6, 8, 2],\n    lines: 5,\n    origin: 'american',\n    description: 'didactic poem with ascending/descending pattern',\n  },\n  limerick: {\n    id: 'limerick',\n    name: 'limerick',\n    pattern: [8, 8, 5, 5, 8],\n    lines: 5,\n    origin: 'english',\n    description: 'humorous poem with AABBA rhyme scheme',\n  },\n  redondilla: {\n    id: 'redondilla',\n    name: 'redondilla',\n    pattern: [8, 8, 8, 8],\n    lines: 4,\n    origin: 'spanish',\n    description: 'quatrain with consonant rhyme',\n  },\n  lanterne: {\n    id: 'lanterne',\n    name: 'lanterne',\n    pattern: [1, 2, 3, 4, 1],\n    lines: 5,\n    origin: 'japanese-inspired',\n    description: 'lantern-shaped syllabic poem',\n  },\n  diamante: {\n    id: 'diamante',\n    name: 'diamante',\n    pattern: [1, 2, 3, 4, 3, 2, 1],\n    lines: 7,\n    origin: 'modern',\n    description: 'diamond-shaped contrast poem',\n  },\n  fibonacci: {\n    id: 'fibonacci',\n    name: 'fibonacci',\n    pattern: [1, 1, 2, 3, 5, 8],\n    lines: 6,\n    origin: 'mathematical',\n    description: 'follows fibonacci sequence',\n  },\n}"
            },
            {
                "name": "root",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/cli.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "process.cwd()"
            },
            {
                "name": "routes",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/app.routes.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Routes",
                "defaultValue": "[]"
            },
            {
                "name": "SCHEMES",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "literal type[]",
                "defaultValue": "[\n  { name: 'tonal-spot', variant: SchemeTonalSpot },\n  { name: 'neutral', variant: SchemeNeutral },\n  { name: 'vibrant', variant: SchemeVibrant },\n  { name: 'expressive', variant: SchemeExpressive },\n  { name: 'monochrome', variant: SchemeMonochrome },\n  { name: 'content', variant: SchemeContent },\n  { name: 'fidelity', variant: SchemeFidelity },\n  { name: 'fruit-salad', variant: SchemeFruitSalad },\n  { name: 'rainbow', variant: SchemeRainbow },\n]"
            },
            {
                "name": "SEED_COLOR",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "string",
                "defaultValue": "'#F4C2C2'"
            },
            {
                "name": "SELECTED_SCHEME",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "string",
                "defaultValue": "'fidelity'"
            },
            {
                "name": "TERMINAL_COLORS_CONFIG",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "object",
                "defaultValue": "{\n  red: { hue: 10, chroma: 84, tone: 50 },\n  green: { hue: 145, chroma: 48, tone: 50 },\n  yellow: { hue: 90, chroma: 70, tone: 60 },\n  blue: { hue: 245, chroma: 80, tone: 50 },\n  magenta: { hue: 330, chroma: 68, tone: 50 },\n  cyan: { hue: 200, chroma: 48, tone: 50 },\n}"
            },
            {
                "name": "TERMINAL_CSS_VARS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "[]",
                "defaultValue": "[\n  'red',\n  'redContainer',\n  'onRedContainer',\n  'green',\n  'greenContainer',\n  'onGreenContainer',\n  'yellow',\n  'yellowContainer',\n  'onYellowContainer',\n  'blue',\n  'blueContainer',\n  'onBlueContainer',\n  'magenta',\n  'magentaContainer',\n  'onMagentaContainer',\n  'cyan',\n  'cyanContainer',\n  'onCyanContainer',\n\n  'inverseRed',\n  'inverseRedContainer',\n  'inverseOnRedContainer',\n  'inverseGreen',\n  'inverseGreenContainer',\n  'inverseOnGreenContainer',\n  'inverseYellow',\n  'inverseYellowContainer',\n  'inverseOnYellowContainer',\n  'inverseBlue',\n  'inverseBlueContainer',\n  'inverseOnBlueContainer',\n  'inverseMagenta',\n  'inverseMagentaContainer',\n  'inverseOnMagentaContainer',\n  'inverseCyan',\n  'inverseCyanContainer',\n  'inverseOnCyanContainer',\n]"
            },
            {
                "name": "THEME_CONFIG",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "object",
                "defaultValue": "{\n  seedColor: SEED_COLOR,\n  selectedScheme: SELECTED_SCHEME,\n  availableSchemes: SCHEMES.map((s) => s.name),\n  materialVariables: THEME_CSS_VARS.length,\n  terminalVariables: TERMINAL_CSS_VARS.length,\n  totalVariables: ALL_CSS_VARS.length,\n}"
            },
            {
                "name": "THEME_CSS_VARS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "[]",
                "defaultValue": "[\n  'primary',\n  'onPrimary',\n  'primaryContainer',\n  'onPrimaryContainer',\n  'secondary',\n  'onSecondary',\n  'secondaryContainer',\n  'onSecondaryContainer',\n  'tertiary',\n  'onTertiary',\n  'tertiaryContainer',\n  'onTertiaryContainer',\n  'error',\n  'onError',\n  'errorContainer',\n  'onErrorContainer',\n  'background',\n  'onBackground',\n  'surface',\n  'surfaceDim',\n  'surfaceBright',\n  'surfaceContainerLowest',\n  'surfaceContainerLow',\n  'surfaceContainer',\n  'surfaceContainerHigh',\n  'surfaceContainerHighest',\n  'onSurface',\n  'surfaceVariant',\n  'onSurfaceVariant',\n  'outline',\n  'outlineVariant',\n  'shadow',\n  'scrim',\n  'inverseSurface',\n  'inverseOnSurface',\n  'inversePrimary',\n]"
            }
        ],
        "functions": [
            {
                "name": "capitalizeFirst",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "str",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "string",
                "jsdoctags": [
                    {
                        "name": "str",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "createTerminalColorVariations",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "baseHct",
                        "type": "Hct",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "isDark",
                        "type": "boolean",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "literal type",
                "jsdoctags": [
                    {
                        "name": "baseHct",
                        "type": "Hct",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "isDark",
                        "type": "boolean",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "extractColors",
                "file": "src/lib/material-theme/theme-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "scheme",
                        "type": "DynamicScheme",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "Record<string, string>",
                "jsdoctags": [
                    {
                        "name": "scheme",
                        "type": "DynamicScheme",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "generateTerminalColors",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "seedColor",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "defaultValue": "SEED_COLOR"
                    }
                ],
                "returnType": "literal type",
                "jsdoctags": [
                    {
                        "name": "seedColor",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "defaultValue": "SEED_COLOR",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "generateTerminalCSS",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [],
                "returnType": "string"
            },
            {
                "name": "generateTerminalFiles",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "root",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "outputDir",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "void",
                "jsdoctags": [
                    {
                        "name": "root",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "outputDir",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "generateThemeFiles",
                "file": "src/lib/material-theme/theme-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "root",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "outputDir",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "void",
                "jsdoctags": [
                    {
                        "name": "root",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "outputDir",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "getAvailableSchemes",
                "file": "src/lib/material-theme/theme.config.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [],
                "returnType": "string[]"
            },
            {
                "name": "getColorFromScheme",
                "file": "src/lib/material-theme/theme-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "prop",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "scheme",
                        "type": "DynamicScheme",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "number",
                "jsdoctags": [
                    {
                        "name": "prop",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "scheme",
                        "type": "DynamicScheme",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "getConfigInfo",
                "file": "src/lib/material-theme/theme.config.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [],
                "returnType": "string"
            },
            {
                "name": "getSchemeConstructor",
                "file": "src/lib/material-theme/theme.config.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "schemeName",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "SchemeConstructor",
                "jsdoctags": [
                    {
                        "name": "schemeName",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "harmonizeWithSeed",
                "file": "src/lib/material-theme/terminal-generator.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "baseColor",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "seedColor",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "number",
                "jsdoctags": [
                    {
                        "name": "baseColor",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "seedColor",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "isValidScheme",
                "file": "src/lib/material-theme/theme.config.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "schemeName",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "boolean",
                "jsdoctags": [
                    {
                        "name": "schemeName",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            }
        ],
        "typealiases": [
            {
                "name": "AllColors",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "MaterialColors | TerminalColors",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 193
            },
            {
                "name": "MaterialColors",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 200
            },
            {
                "name": "MeterType",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "\"iambic\" | \"trochaic\" | \"anapestic\" | \"dactylic\" | \"irregular\"",
                "file": "src/app/services/poetry/meter-analysis.service.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 193
            },
            {
                "name": "SchemeConstructor",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 186
            },
            {
                "name": "TerminalColors",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "",
                "file": "src/lib/material-theme/theme.config.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 199
            },
            {
                "name": "Theme",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "\"light\" | \"dark\"",
                "file": "src/app/services/core/theme.service.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 193
            }
        ],
        "enumerations": [],
        "groupedVariables": {
            "src/lib/material-theme/theme.config.ts": [
                {
                    "name": "ALL_CSS_VARS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "[]",
                    "defaultValue": "[...THEME_CSS_VARS, ...TERMINAL_CSS_VARS]"
                },
                {
                    "name": "SCHEMES",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type[]",
                    "defaultValue": "[\n  { name: 'tonal-spot', variant: SchemeTonalSpot },\n  { name: 'neutral', variant: SchemeNeutral },\n  { name: 'vibrant', variant: SchemeVibrant },\n  { name: 'expressive', variant: SchemeExpressive },\n  { name: 'monochrome', variant: SchemeMonochrome },\n  { name: 'content', variant: SchemeContent },\n  { name: 'fidelity', variant: SchemeFidelity },\n  { name: 'fruit-salad', variant: SchemeFruitSalad },\n  { name: 'rainbow', variant: SchemeRainbow },\n]"
                },
                {
                    "name": "SEED_COLOR",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "defaultValue": "'#F4C2C2'"
                },
                {
                    "name": "SELECTED_SCHEME",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "defaultValue": "'fidelity'"
                },
                {
                    "name": "TERMINAL_COLORS_CONFIG",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "defaultValue": "{\n  red: { hue: 10, chroma: 84, tone: 50 },\n  green: { hue: 145, chroma: 48, tone: 50 },\n  yellow: { hue: 90, chroma: 70, tone: 60 },\n  blue: { hue: 245, chroma: 80, tone: 50 },\n  magenta: { hue: 330, chroma: 68, tone: 50 },\n  cyan: { hue: 200, chroma: 48, tone: 50 },\n}"
                },
                {
                    "name": "TERMINAL_CSS_VARS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "[]",
                    "defaultValue": "[\n  'red',\n  'redContainer',\n  'onRedContainer',\n  'green',\n  'greenContainer',\n  'onGreenContainer',\n  'yellow',\n  'yellowContainer',\n  'onYellowContainer',\n  'blue',\n  'blueContainer',\n  'onBlueContainer',\n  'magenta',\n  'magentaContainer',\n  'onMagentaContainer',\n  'cyan',\n  'cyanContainer',\n  'onCyanContainer',\n\n  'inverseRed',\n  'inverseRedContainer',\n  'inverseOnRedContainer',\n  'inverseGreen',\n  'inverseGreenContainer',\n  'inverseOnGreenContainer',\n  'inverseYellow',\n  'inverseYellowContainer',\n  'inverseOnYellowContainer',\n  'inverseBlue',\n  'inverseBlueContainer',\n  'inverseOnBlueContainer',\n  'inverseMagenta',\n  'inverseMagentaContainer',\n  'inverseOnMagentaContainer',\n  'inverseCyan',\n  'inverseCyanContainer',\n  'inverseOnCyanContainer',\n]"
                },
                {
                    "name": "THEME_CONFIG",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "defaultValue": "{\n  seedColor: SEED_COLOR,\n  selectedScheme: SELECTED_SCHEME,\n  availableSchemes: SCHEMES.map((s) => s.name),\n  materialVariables: THEME_CSS_VARS.length,\n  terminalVariables: TERMINAL_CSS_VARS.length,\n  totalVariables: ALL_CSS_VARS.length,\n}"
                },
                {
                    "name": "THEME_CSS_VARS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "[]",
                    "defaultValue": "[\n  'primary',\n  'onPrimary',\n  'primaryContainer',\n  'onPrimaryContainer',\n  'secondary',\n  'onSecondary',\n  'secondaryContainer',\n  'onSecondaryContainer',\n  'tertiary',\n  'onTertiary',\n  'tertiaryContainer',\n  'onTertiaryContainer',\n  'error',\n  'onError',\n  'errorContainer',\n  'onErrorContainer',\n  'background',\n  'onBackground',\n  'surface',\n  'surfaceDim',\n  'surfaceBright',\n  'surfaceContainerLowest',\n  'surfaceContainerLow',\n  'surfaceContainer',\n  'surfaceContainerHigh',\n  'surfaceContainerHighest',\n  'onSurface',\n  'surfaceVariant',\n  'onSurfaceVariant',\n  'outline',\n  'outlineVariant',\n  'shadow',\n  'scrim',\n  'inverseSurface',\n  'inverseOnSurface',\n  'inversePrimary',\n]"
                }
            ],
            "src/app/app.config.ts": [
                {
                    "name": "appConfig",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/app.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "ApplicationConfig",
                    "defaultValue": "{\n  providers: [\n    provideBrowserGlobalErrorListeners(),\n    provideZoneChangeDetection({ eventCoalescing: true }),\n    provideRouter(routes),\n  ],\n}"
                }
            ],
            "src/lib/material-theme/cli.ts": [
                {
                    "name": "outputDir",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/cli.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "defaultValue": "'src/styles'"
                },
                {
                    "name": "root",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/lib/material-theme/cli.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "process.cwd()"
                }
            ],
            "src/app/data/poetry-forms.data.ts": [
                {
                    "name": "POETRY_EXAMPLES",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/data/poetry-forms.data.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Record<string, string[]>",
                    "defaultValue": "{\n  haiku: ['an old silent pond', 'a frog jumps into the pond', 'splash! silence again'],\n  tanka: [\n    'the falling flower',\n    'i saw drift back to the branch',\n    'was a butterfly',\n    'dancing in the gentle breeze',\n    \"nature's art in motion\",\n  ],\n  cinquain: [\n    'moon',\n    'silent light',\n    'casting silver shadows',\n    'illuminating the dark night',\n    'peace',\n  ],\n  limerick: [\n    'there once was a coder so bright',\n    'who worked on his app every night',\n    'with angular and code',\n    'he built a fine node',\n    \"and launched it to everyone's delight\",\n  ],\n  redondilla: [\n    'in fields of green and gold so bright',\n    'where flowers dance in morning light',\n    'the world awakens from the night',\n    'and fills my heart with pure delight',\n  ],\n  lanterne: ['moon', 'bright glow', 'silver light', 'shining through night', 'peace'],\n  diamante: [\n    'day',\n    'bright warm',\n    'shining glowing heating',\n    'sunrise sunset twilight darkness',\n    'cooling dimming fading',\n    'cold dark',\n    'night',\n  ],\n  fibonacci: ['I', 'am', 'writing', 'syllables', 'in fibonacci', 'a mathematical poetry sequence'],\n}"
                },
                {
                    "name": "POETRY_FORM_OPTIONS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/data/poetry-forms.data.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "Object.values(POETRY_FORMS).map((form) => ({\n  value: form.id,\n  label: form.name,\n  description: form.pattern.join('-'),\n}))"
                },
                {
                    "name": "POETRY_FORMS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/data/poetry-forms.data.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Record<string, PoetryForm>",
                    "defaultValue": "{\n  haiku: {\n    id: 'haiku',\n    name: 'haiku',\n    pattern: [5, 7, 5],\n    lines: 3,\n    origin: 'japanese',\n    description: 'traditional nature poem with 3 lines',\n  },\n  tanka: {\n    id: 'tanka',\n    name: 'tanka',\n    pattern: [5, 7, 5, 7, 7],\n    lines: 5,\n    origin: 'japanese',\n    description: 'extended court poetry with 5 lines',\n  },\n  cinquain: {\n    id: 'cinquain',\n    name: 'cinquain',\n    pattern: [2, 4, 6, 8, 2],\n    lines: 5,\n    origin: 'american',\n    description: 'didactic poem with ascending/descending pattern',\n  },\n  limerick: {\n    id: 'limerick',\n    name: 'limerick',\n    pattern: [8, 8, 5, 5, 8],\n    lines: 5,\n    origin: 'english',\n    description: 'humorous poem with AABBA rhyme scheme',\n  },\n  redondilla: {\n    id: 'redondilla',\n    name: 'redondilla',\n    pattern: [8, 8, 8, 8],\n    lines: 4,\n    origin: 'spanish',\n    description: 'quatrain with consonant rhyme',\n  },\n  lanterne: {\n    id: 'lanterne',\n    name: 'lanterne',\n    pattern: [1, 2, 3, 4, 1],\n    lines: 5,\n    origin: 'japanese-inspired',\n    description: 'lantern-shaped syllabic poem',\n  },\n  diamante: {\n    id: 'diamante',\n    name: 'diamante',\n    pattern: [1, 2, 3, 4, 3, 2, 1],\n    lines: 7,\n    origin: 'modern',\n    description: 'diamond-shaped contrast poem',\n  },\n  fibonacci: {\n    id: 'fibonacci',\n    name: 'fibonacci',\n    pattern: [1, 1, 2, 3, 5, 8],\n    lines: 6,\n    origin: 'mathematical',\n    description: 'follows fibonacci sequence',\n  },\n}"
                }
            ],
            "src/app/app.routes.ts": [
                {
                    "name": "routes",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/app.routes.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Routes",
                    "defaultValue": "[]"
                }
            ]
        },
        "groupedFunctions": {
            "src/lib/material-theme/terminal-generator.ts": [
                {
                    "name": "capitalizeFirst",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "str",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "string",
                    "jsdoctags": [
                        {
                            "name": "str",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "createTerminalColorVariations",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "baseHct",
                            "type": "Hct",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "isDark",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "literal type",
                    "jsdoctags": [
                        {
                            "name": "baseHct",
                            "type": "Hct",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "isDark",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateTerminalColors",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "seedColor",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "SEED_COLOR"
                        }
                    ],
                    "returnType": "literal type",
                    "jsdoctags": [
                        {
                            "name": "seedColor",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "SEED_COLOR",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateTerminalCSS",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [],
                    "returnType": "string"
                },
                {
                    "name": "generateTerminalFiles",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "root",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "void",
                    "jsdoctags": [
                        {
                            "name": "root",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "harmonizeWithSeed",
                    "file": "src/lib/material-theme/terminal-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "baseColor",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "seedColor",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "number",
                    "jsdoctags": [
                        {
                            "name": "baseColor",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "seedColor",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "src/lib/material-theme/theme-generator.ts": [
                {
                    "name": "extractColors",
                    "file": "src/lib/material-theme/theme-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "scheme",
                            "type": "DynamicScheme",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "Record<string, string>",
                    "jsdoctags": [
                        {
                            "name": "scheme",
                            "type": "DynamicScheme",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "generateThemeFiles",
                    "file": "src/lib/material-theme/theme-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "root",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "void",
                    "jsdoctags": [
                        {
                            "name": "root",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "outputDir",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getColorFromScheme",
                    "file": "src/lib/material-theme/theme-generator.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "prop",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "scheme",
                            "type": "DynamicScheme",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "number",
                    "jsdoctags": [
                        {
                            "name": "prop",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "scheme",
                            "type": "DynamicScheme",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "src/lib/material-theme/theme.config.ts": [
                {
                    "name": "getAvailableSchemes",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [],
                    "returnType": "string[]"
                },
                {
                    "name": "getConfigInfo",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [],
                    "returnType": "string"
                },
                {
                    "name": "getSchemeConstructor",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "schemeName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "SchemeConstructor",
                    "jsdoctags": [
                        {
                            "name": "schemeName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isValidScheme",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "schemeName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "boolean",
                    "jsdoctags": [
                        {
                            "name": "schemeName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ]
        },
        "groupedEnumerations": {},
        "groupedTypeAliases": {
            "src/lib/material-theme/theme.config.ts": [
                {
                    "name": "AllColors",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "MaterialColors | TerminalColors",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 193
                },
                {
                    "name": "MaterialColors",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 200
                },
                {
                    "name": "SchemeConstructor",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 186
                },
                {
                    "name": "TerminalColors",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "",
                    "file": "src/lib/material-theme/theme.config.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 199
                }
            ],
            "src/app/services/poetry/meter-analysis.service.ts": [
                {
                    "name": "MeterType",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "\"iambic\" | \"trochaic\" | \"anapestic\" | \"dactylic\" | \"irregular\"",
                    "file": "src/app/services/poetry/meter-analysis.service.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 193
                }
            ],
            "src/app/services/core/theme.service.ts": [
                {
                    "name": "Theme",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "\"light\" | \"dark\"",
                    "file": "src/app/services/core/theme.service.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 193
                }
            ]
        }
    },
    "routes": {
        "name": "<root>",
        "kind": "module",
        "children": []
    },
    "coverage": {
        "count": 0,
        "status": "low",
        "files": [
            {
                "filePath": "src/app/app.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "appConfig",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/app.routes.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "routes",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/app.ts",
                "type": "component",
                "linktype": "component",
                "name": "App",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/components/accordion/accordion.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "AccordionComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/analysis-panel/analysis-panel.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "AnalysisPanelComponent",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/components/analysis-panel/analysis-panel.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "AnalysisMetric",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/components/badge/badge.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "BadgeComponent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/button/button.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ButtonComponent",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/components/card/card.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "CardComponent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/empty-state/empty-state.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "EmptyStateComponent",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/components/footer/footer.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "FooterComponent",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/components/header/header.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "HeaderComponent",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/components/input/input.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "InputComponent",
                "coveragePercent": 0,
                "coverageCount": "0/20",
                "status": "low"
            },
            {
                "filePath": "src/app/components/loading-spinner/loading-spinner.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "LoadingSpinnerComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/components/meter-analysis-section/meter-analysis-section.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "MeterAnalysisSectionComponent",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poem-editor/poem-editor.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PoemEditorComponent",
                "coveragePercent": 0,
                "coverageCount": "0/15",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poem-quality/poem-quality.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PoemQualityComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poem-results/poem-results.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PoemResultsComponent",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/components/poetry-page/poetry-page.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PoetryPageComponent",
                "coveragePercent": 0,
                "coverageCount": "0/13",
                "status": "low"
            },
            {
                "filePath": "src/app/components/quick-stats-panel/quick-stats-panel.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "QuickStatsPanelComponent",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/app/components/quick-stats-panel/quick-stats-panel.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "QuickStats",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/select/select.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "SelectComponent",
                "coveragePercent": 0,
                "coverageCount": "0/16",
                "status": "low"
            },
            {
                "filePath": "src/app/components/select/select.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "SelectOption",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/status-message/status-message.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "StatusMessageComponent",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/components/tabs/tabs.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "TabsComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/tabs/tabs.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "Tab",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/components/theme-toggle/theme-toggle.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ThemeToggleComponent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/components/tooltip/tooltip.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "TooltipComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/components/word-suggestions/word-suggestions.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "WordSuggestionsComponent",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/app/data/poetry-forms.data.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "POETRY_EXAMPLES",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/data/poetry-forms.data.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "POETRY_FORM_OPTIONS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/data/poetry-forms.data.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "POETRY_FORMS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/models/poetry.model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "LineAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/models/poetry.model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "MeterAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/models/poetry.model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "PoetryForm",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/models/poetry.model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "PoetryResult",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/services/core/theme.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "ThemeService",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/services/core/theme.service.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "Theme",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/services/core/utils.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "UtilsService",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/meter-analysis.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "MeterAnalysisService",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/meter-analysis.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "MeterAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/meter-analysis.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "RhythmSuggestion",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/meter-analysis.service.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "MeterType",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poem-quality.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "PoemQualityService",
                "coveragePercent": 0,
                "coverageCount": "0/14",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poem-quality.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "QualityMetrics",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analysis.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "PoetryAnalysisService",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analysis.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "PoetryStructure",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analyzer.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "PoetryAnalyzerService",
                "coveragePercent": 0,
                "coverageCount": "0/30",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analyzer.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "EnhancedLineAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analyzer.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "EnhancedPoetryResult",
                "coveragePercent": 0,
                "coverageCount": "0/12",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-analyzer.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "WordSuggestionData",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-patterns.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "PoetryPatternsService",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-suggestions.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "PoetrySuggestionsService",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-suggestions.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "SuggestionContext",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/poetry-suggestions.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "WordSuggestionData",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rhyme-analysis.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "RhymeAnalysisService",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "RitaService",
                "coveragePercent": 0,
                "coverageCount": "0/15",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "AdvancedSearchOptions",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "AlliterationMatch",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "AlternativeWord",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "GrammaticalAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/11",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "RhymeMatch",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "SyllableAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/poetry/rita.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "WordAnalysis",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/cli.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "outputDir",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/cli.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "root",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "capitalizeFirst",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "createTerminalColorVariations",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "generateTerminalColors",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "generateTerminalCSS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "generateTerminalFiles",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/terminal-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "harmonizeWithSeed",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "extractColors",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "generateThemeFiles",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme-generator.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "getColorFromScheme",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ThemeColor",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "getAvailableSchemes",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "getConfigInfo",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "getSchemeConstructor",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "isValidScheme",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "ALL_CSS_VARS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "SCHEMES",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "SEED_COLOR",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "SELECTED_SCHEME",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "TERMINAL_COLORS_CONFIG",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "TERMINAL_CSS_VARS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "THEME_CONFIG",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "THEME_CSS_VARS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "AllColors",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "MaterialColors",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "SchemeConstructor",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/lib/material-theme/theme.config.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "TerminalColors",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            }
        ]
    }
}